<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="1.JVM内存区域OOM了解吗？什么情况下会出现OOM？​    对栈来说，如果没有空间来为新的栈帧开辟空间就会产生OOM ​    对永久代如果空间不够会抛出OOM ​    对堆：如果空间不够也GC没用的情况下也会抛出OOM ​    一般可能是内存泄漏或者是内存溢出照成的。 StackOverflow出现的场景？​    对栈来说，如果线程请求的栈深度大于虚拟机所能接受的栈深度会抛出SOF">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="https://huajiaohuixiang.github.io/2021/05/12/JVM/index.html">
<meta property="og:site_name" content="花椒茴香的个人博客">
<meta property="og:description" content="1.JVM内存区域OOM了解吗？什么情况下会出现OOM？​    对栈来说，如果没有空间来为新的栈帧开辟空间就会产生OOM ​    对永久代如果空间不够会抛出OOM ​    对堆：如果空间不够也GC没用的情况下也会抛出OOM ​    一般可能是内存泄漏或者是内存溢出照成的。 StackOverflow出现的场景？​    对栈来说，如果线程请求的栈深度大于虚拟机所能接受的栈深度会抛出SOF">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/花椒茴香/AppData/Roaming/Typora/typora-user-images/image-20210416155252023.png">
<meta property="og:image" content="c:/Users/花椒茴香/AppData/Roaming/Typora/typora-user-images/image-20210416155303079.png">
<meta property="og:image" content="c:/Users/花椒茴香/AppData/Roaming/Typora/typora-user-images/image-20210416155627557.png">
<meta property="og:image" content="c:/Users/花椒茴香/AppData/Roaming/Typora/typora-user-images/image-20210329154236724.png">
<meta property="og:image" content="c:/Users/花椒茴香/AppData/Roaming/Typora/typora-user-images/image-20210329180346655.png">
<meta property="og:image" content="c:/Users/花椒茴香/AppData/Roaming/Typora/typora-user-images/image-20210416161248975.png">
<meta property="og:image" content="c:/Users/花椒茴香/AppData/Roaming/Typora/typora-user-images/image-20210416190044852.png">
<meta property="og:image" content="c:/Users/花椒茴香/AppData/Roaming/Typora/typora-user-images/image-20210416191130738.png">
<meta property="article:published_time" content="2021-05-12T03:24:40.000Z">
<meta property="article:modified_time" content="2021-05-12T03:26:22.394Z">
<meta property="article:author" content="huajiaohuixiang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/花椒茴香/AppData/Roaming/Typora/typora-user-images/image-20210416155252023.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>JVM</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="花椒茴香的个人博客" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">Projects</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/05/12/mysql/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/05/12/Jetson-Nano-%E6%90%AD%E5%BB%BAMysql/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://huajiaohuixiang.github.io/2021/05/12/JVM/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&text=JVM"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&is_video=false&description=JVM"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JVM&body=Check out this article: https://huajiaohuixiang.github.io/2021/05/12/JVM/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&name=JVM&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://huajiaohuixiang.github.io/2021/05/12/JVM/&t=JVM"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text">1.JVM内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OOM%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0OOM%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">OOM了解吗？什么情况下会出现OOM？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StackOverflow%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">StackOverflow出现的场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E4%B8%BA%E4%BA%94%E5%A4%A7%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">1.JVM内存区域分为五大部分：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-Native%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%88%E5%B8%A7-%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E6%98%AF%E8%B0%83%E7%94%A8ni%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%88%E5%B8%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86-%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">1.3.3.</span> <span class="toc-text">堆  几乎所有的对象都在这里分配内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-%EF%BC%9A"><span class="toc-number">1.3.4.</span> <span class="toc-text">方法区 ：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9A"><span class="toc-number">1.3.5.</span> <span class="toc-text">程序计数器：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">3.对象访问定位的方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5%EF%BC%9A2%E7%A7%8D"><span class="toc-number">1.5.</span> <span class="toc-text">5堆内存中对象分配的基本策略：2种</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.5.1.</span> <span class="toc-text">并发问题如何解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.</span> <span class="toc-text">2.垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">如何判断对象是否死亡：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GCRoots%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">GCRoots有哪些？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%B8%B8%E9%87%8F%E6%98%AF%E5%90%A6%E6%97%A0%E7%94%A8%EF%BC%8C%E7%B1%BB%E6%98%AF%E5%90%A6%E6%97%A0%E7%94%A8%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">7.如何判断常量是否无用，类是否无用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-number">2.3.</span> <span class="toc-text">分代收集理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">如何解决跨代引用的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MinorGC-MajorGC-FullGC-%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%95%B4%E5%A0%86%E6%94%B6%E9%9B%86"><span class="toc-number">2.5.</span> <span class="toc-text">MinorGC MajorGC FullGC  新生代、老年代、整堆收集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9AFullGC%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">什么时候会FullGC？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.7.</span> <span class="toc-text">垃圾回收算法？各有什么优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSTW%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">什么是STW？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">什么是安全点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8"><span class="toc-number">2.10.</span> <span class="toc-text">记忆集与卡表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.11.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-Serial-Old"><span class="toc-number">2.11.1.</span> <span class="toc-text">Serial&#x2F;Serial Old</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%84%B6%E5%90%8E%E6%98%AFParNew%EF%BC%8CSerial%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E6%9C%AC"><span class="toc-number">2.11.2.</span> <span class="toc-text">然后是ParNew，Serial的多线程版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%84%B6%E5%90%8E%E6%98%AFParrllel-Scavenge-%E5%92%8CParNew%E6%93%A6%E4%B8%8D%E5%A4%9A"><span class="toc-number">2.11.3.</span> <span class="toc-text">然后是Parrllel Scavenge  和ParNew擦不多</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%84%B6%E5%90%8E%E6%98%AFParallelOld"><span class="toc-number">2.11.4.</span> <span class="toc-text">然后是ParallelOld</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84CMS-2%E6%AC%A1stop-the-world-%E8%AF%A6%E7%BB%86%E7%9C%8B%E4%B8%80%E4%B8%8B"><span class="toc-number">2.11.5.</span> <span class="toc-text">老年代的CMS  2次stop the world  详细看一下</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1-3%E6%AC%A1-stop-the-world"><span class="toc-number">2.11.6.</span> <span class="toc-text">G1 3次 stop the world</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E4%BD%8E%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.11.7.</span> <span class="toc-text">两个低延迟的垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">2.12.</span> <span class="toc-text">内存分配与回收策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">会不会发生内存泄漏？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">3.类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">何时加载类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9A%EF%BC%88%E6%AF%8F%E4%B8%80%E6%AD%A5%E8%AF%A6%E7%BB%86%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">.类加载过程&#x2F;Java对象的创建过程：（每一步详细实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">创建对象的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%94%B1C-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">启动类加载器  由C++实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.4.3.</span> <span class="toc-text">应用程序加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.4.4.</span> <span class="toc-text">自定义加载器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">双亲委派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">为什么要使用双亲委托模型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.</span> <span class="toc-text">破坏双亲委派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK9%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">3.8.</span> <span class="toc-text">JDK9的模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="toc-number">4.</span> <span class="toc-text">4.Java 内存模型 JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%86%85%E5%AD%98"><span class="toc-number">4.1.</span> <span class="toc-text">工作内存与主内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">什么是内存屏障？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DCL%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%8A%A0volatile"><span class="toc-number">4.3.</span> <span class="toc-text">DCL为何需要加volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">volatile如何实现的内存可见性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">volatile如何实现的禁止重排序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.6.</span> <span class="toc-text">volatile 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.7.</span> <span class="toc-text">线程的状态转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JVM%E8%B0%83%E4%BC%98"><span class="toc-number">5.</span> <span class="toc-text">5.JVM调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.1.</span> <span class="toc-text">设置堆大小</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        JVM
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">huajiaohuixiang</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-05-12T03:24:40.000Z" itemprop="datePublished">2021-05-12</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/JVM/" rel="tag">JVM</a>, <a class="tag-link-link" href="/tags/Java/" rel="tag">Java</a>, <a class="tag-link-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h3 id="1-JVM内存区域"><a href="#1-JVM内存区域" class="headerlink" title="1.JVM内存区域"></a>1.JVM内存区域</h3><h4 id="OOM了解吗？什么情况下会出现OOM？"><a href="#OOM了解吗？什么情况下会出现OOM？" class="headerlink" title="OOM了解吗？什么情况下会出现OOM？"></a>OOM了解吗？什么情况下会出现OOM？</h4><p>​    对栈来说，如果没有空间来为新的栈帧开辟空间就会产生OOM</p>
<p>​    对永久代如果空间不够会抛出OOM</p>
<p>​    对堆：如果空间不够也GC没用的情况下也会抛出OOM</p>
<p>​    一般可能是内存泄漏或者是内存溢出照成的。</p>
<h4 id="StackOverflow出现的场景？"><a href="#StackOverflow出现的场景？" class="headerlink" title="StackOverflow出现的场景？"></a>StackOverflow出现的场景？</h4><p>​    对栈来说，如果线程请求的栈深度大于虚拟机所能接受的栈深度会抛出SOF</p>
<h4 id="1-JVM内存区域分为五大部分："><a href="#1-JVM内存区域分为五大部分：" class="headerlink" title="1.JVM内存区域分为五大部分："></a>1.JVM内存区域分为五大部分：</h4><h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>   java线程的栈帧，线程的每一个方法会生成一个栈帧，用于存放该线程的局部变量表、操作数栈、动态连接、方法出口等信息。随着方法的调用与结束，对应着入栈与出栈；局部变量表中存放着方法参数和内部定义的局部变量，基本存储单位是方法槽。<br>    动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用是为了支持方法调用过程中的动态连接(DynamicLinking) 这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析  另外一部分符号引用将在每一次运行期间都转化为直接引用，这部分就称为动态连接<br>    操作数栈：java虚拟机栈中的一个用于计算的临时数据存储区</p>
<h5 id="本地方法栈-Native方法的栈帧-和虚拟机栈差不多，只不过是调用ni方法的栈帧"><a href="#本地方法栈-Native方法的栈帧-和虚拟机栈差不多，只不过是调用ni方法的栈帧" class="headerlink" title="本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧"></a>本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧</h5><h5 id="堆-几乎所有的对象都在这里分配内存"><a href="#堆-几乎所有的对象都在这里分配内存" class="headerlink" title="堆  几乎所有的对象都在这里分配内存"></a>堆  几乎所有的对象都在这里分配内存</h5><p>​    堆分为老年代、新生代、永久代；</p>
<p>​    新生代分为Eden FromSurvivors To Survivors  8：1：1</p>
<p>​    这两个Survivors有什么用呢？</p>
<p>​    在分配内存时，每次只使用一块Eden和 Survivor然后使用标记复制算法将其复制到另一块Survivor上。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）。</p>
<h5 id="方法区-："><a href="#方法区-：" class="headerlink" title="方法区 ："></a>方法区 ：</h5><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<h5 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h5><p>当前线程字节码文件的行号指示器，通过改变该计数器的值来获得下一步执行的字节码指令；程序控制流的指示器，程序当中的分支、循环、线程恢复、跳转、异常处理都要由它指示。由于Java虚拟机通过时间片轮转实现多线程，所以每一个线程都需要一个程序计数器记录当前执行的位置。</p>
<h4 id="3-对象访问定位的方式："><a href="#3-对象访问定位的方式：" class="headerlink" title="3.对象访问定位的方式："></a>3.对象访问定位的方式：</h4><p>​    句柄池：每一个句柄   数据结构中包括对象数据的指针以及类的指针</p>
<p>​    直接指针 在对象数据中存放类指针</p>
<h4 id="5堆内存中对象分配的基本策略：2种"><a href="#5堆内存中对象分配的基本策略：2种" class="headerlink" title="5堆内存中对象分配的基本策略：2种"></a>5堆内存中对象分配的基本策略：2种</h4><p>​    碰撞指针、空闲表</p>
<h5 id="并发问题如何解决"><a href="#并发问题如何解决" class="headerlink" title="并发问题如何解决"></a>并发问题如何解决</h5><p>   CAS乐观锁+失败重试   先创建失败了就重试  </p>
<p>   TLAB  为每个线程在Eden初设一点内存，现在TLAB分配 当TLAB用完后，用CAS+失败重试</p>
<h3 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2.垃圾回收"></a>2.垃圾回收</h3><p>一个长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，就会造成内存泄漏。</p>
<p>ThreadLocalMap中存在内存泄漏。</p>
<h4 id="如何判断对象是否死亡："><a href="#如何判断对象是否死亡：" class="headerlink" title="如何判断对象是否死亡："></a>如何判断对象是否死亡：</h4><p>​    如果没有任何一个对象引用该对象则判断为死亡（可达性方法）</p>
<p>​     （引用计数法）没引用一次加一取消引用减一；不好解决互相引用的问题；</p>
<h5 id="GCRoots有哪些？"><a href="#GCRoots有哪些？" class="headerlink" title="GCRoots有哪些？"></a>GCRoots有哪些？</h5><p>​        虚拟机栈中引用的对象，本地方法栈中引用的对象</p>
<p>​        方法区中常量引用的对象，方法区中类静态属性引用的对象</p>
<h4 id="7-如何判断常量是否无用，类是否无用？"><a href="#7-如何判断常量是否无用，类是否无用？" class="headerlink" title="7.如何判断常量是否无用，类是否无用？"></a>7.如何判断常量是否无用，类是否无用？</h4><p>​    常量无用：没有引用即可</p>
<p>​    类无用：该Class类没有被引用、没有该类的对象还在存活、该类的ClassLoader已经销毁</p>
<h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>如今的垃圾回收器大都是遵循分代收集。建立在两个分代假说：弱分代假说，强分代假说。垃圾回收器应该将Java堆分为不同的存储区域，根据其年龄进行收集。</p>
<p>跨代引用假说，跨代引用相对于同代引用仅占用极少数。</p>
<h4 id="如何解决跨代引用的问题？"><a href="#如何解决跨代引用的问题？" class="headerlink" title="如何解决跨代引用的问题？"></a>如何解决跨代引用的问题？</h4><p>在新生代维护一个记忆集，将老年代分为若干块，标识出哪一块会存在跨代引用，在mingc的时候将它加入到GCroot中。</p>
<h4 id="MinorGC-MajorGC-FullGC-新生代、老年代、整堆收集"><a href="#MinorGC-MajorGC-FullGC-新生代、老年代、整堆收集" class="headerlink" title="MinorGC MajorGC FullGC  新生代、老年代、整堆收集"></a>MinorGC MajorGC FullGC  新生代、老年代、整堆收集</h4><p>正是因为垃圾回收器每次只回收某一个或者某些部分的区域，才有了这三个回收类型的划分。然后根据不同的区域采取不同的回收算法</p>
<h4 id="什么时候会FullGC？"><a href="#什么时候会FullGC？" class="headerlink" title="什么时候会FullGC？"></a>什么时候会FullGC？</h4><ol>
<li>System.gc()方法的调用</li>
<li>老年代空间不足（新生代转入、创建大对象）</li>
<li>CMS无法处理浮动垃圾、有可能出现并发清理失败进而导致另一次完全“Stop The World”的Full GC的产生</li>
</ol>
<h4 id="垃圾回收算法？各有什么优缺点"><a href="#垃圾回收算法？各有什么优缺点" class="headerlink" title="垃圾回收算法？各有什么优缺点"></a>垃圾回收<a href="">算法</a>？各有什么优缺点</h4><p>​    引用计数算法和追踪式算法（引用式算法实现比较简单但是不好解决循环引用的问题）</p>
<p>追踪式算法基于分代假说理论，分别在各自的内存区域回收各自的无用对象，关于如何解决跨代引用，需在新生代上建立一个全局的数据结构（该结构被称 为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会 存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>
<p>​    标志清除  产生内存碎片 /执行效率不稳定：可能需要回收的对象占大部分</p>
<p>​    标记复制    解决了内存碎片 可用空间减为一半，改进后在新生代使用。</p>
<p>​    标记整理    慢，适合老年代</p>
<h4 id="什么是STW？"><a href="#什么是STW？" class="headerlink" title="什么是STW？"></a>什么是STW？</h4><p>必须全部暂停用户线程</p>
<h4 id="什么是安全点？"><a href="#什么是安全点？" class="headerlink" title="什么是安全点？"></a>什么是安全点？</h4><p>可达性分析算法中通过根节点枚举来查找引用链，然后通过OopMap来得到对象的引用地址，因为Oopmap变化是实时的不能为每一条指令都生成oopmap，只在安全点生成oopmap，然后让所有的线程跑到最近的安全点 停下来即可完成STW并且进行根节点枚举。</p>
<h4 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h4><p>—有其他分代区域中对象引用了本区域对象时，其对应的 卡表元素就应该变脏，</p>
<p>通过写屏障（Write Barrier）技术维护卡表状态的</p>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>三个年轻代  Serial ParNew  Parrllel Scavenge</p>
<p>三个老年代  CMS   SerialOld  Parallel Old</p>
<p>然后是G1  SGC ZGC</p>
<h5 id="Serial-Serial-Old"><a href="#Serial-Serial-Old" class="headerlink" title="Serial/Serial Old"></a>Serial/Serial Old</h5><p>这两个的运行过程一样的</p>
<p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416155252023.png" alt="image-20210416155252023"></p>
<p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416155303079.png" alt="image-20210416155303079"></p>
<p>在单核处理器下很好，他说所有收集器占用额外内存最小的。</p>
<h5 id="然后是ParNew，Serial的多线程版本"><a href="#然后是ParNew，Serial的多线程版本" class="headerlink" title="然后是ParNew，Serial的多线程版本"></a>然后是ParNew，Serial的多线程版本</h5><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416155627557.png" alt="image-20210416155627557"></p>
<h5 id="然后是Parrllel-Scavenge-和ParNew擦不多"><a href="#然后是Parrllel-Scavenge-和ParNew擦不多" class="headerlink" title="然后是Parrllel Scavenge  和ParNew擦不多"></a>然后是Parrllel Scavenge  和ParNew擦不多</h5><p>重点关注吞吐量</p>
<h5 id="然后是ParallelOld"><a href="#然后是ParallelOld" class="headerlink" title="然后是ParallelOld"></a>然后是ParallelOld</h5><p>PS的老年代版本 ，标记整理算法/</p>
<h5 id="老年代的CMS-2次stop-the-world-详细看一下"><a href="#老年代的CMS-2次stop-the-world-详细看一下" class="headerlink" title="老年代的CMS  2次stop the world  详细看一下"></a>老年代的CMS  2次stop the world  详细看一下</h5><p>一种以获取最短回收停顿时间为目标的收集器，并发收集、低停顿。到这里就不一样了，运行过程变成了四个。</p>
<p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210329154236724.png" alt="image-20210329154236724"></p>
<p>四个阶段</p>
<p>初始标记（STW）、并发标记、重新标记(STW)、并发清除</p>
<p>单线程                  、单线程与用户并发、多线程、单线程并发</p>
<p>缺点：1.在核数小于四个的情况下咱用核心数多，吞吐量降低</p>
<p>2.无法处理浮动垃圾、有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。是CMS运行期间预留的内存无法满 足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不 得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，</p>
<p>3.标记清除会产生碎片，在无法为新对象分配时会FullGC或者进行整理。但是是单线程的</p>
<h5 id="G1-3次-stop-the-world"><a href="#G1-3次-stop-the-world" class="headerlink" title="G1 3次 stop the world"></a>G1 3次 stop the world</h5><p>开创了收集 器面向局部收集的设计思路和基于Region的内存布局形式。 </p>
<p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210329180346655.png" alt="image-20210329180346655"></p>
<p>且其内存区域是按Region来划分，每一个Region都可以作为Eden From To 或者是老年代，它可以面向堆内存任 何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理。</p>
<p>可以建立起停顿时间模型的收集器，每次收集停顿时间都少于某个时间。</p>
<p>四个阶段（三次STW）</p>
<p>初始标记（STW）、并发标记、最终标记(STW)、筛选回收（STW）</p>
<p>单线程                  、单线程与用户并发、多线程、 多线程</p>
<p>Region引用对象如何解决？解决的思 路我们已经知道（见3.3.1节和3.4.4节）：使用记忆集避免全堆作为GC Roots扫描，</p>
<p>·初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。</p>
<p> ·并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。 </p>
<p>·最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。</p>
<p> ·筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。</p>
<h5 id="两个低延迟的垃圾回收器"><a href="#两个低延迟的垃圾回收器" class="headerlink" title="两个低延迟的垃圾回收器"></a>两个低延迟的垃圾回收器</h5><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416161248975.png" alt="image-20210416161248975"></p>
<p>​    ZGC  染色指针 Region大小可变</p>
<p>​    shenandoahGC  对G1的增强</p>
<h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><p>对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起 一次Minor GC。</p>
<p>大对象直接进入老年代</p>
<p>长期存活的对象将进入老年代，每经过一次minorGC年龄增加一岁，增加到一定程度就会晋升至老年代</p>
<p>动态对象年龄判定：当Survivor空间中相同年龄所有对象占用的空间大于Survivor空间的一半，大于等于该年龄的对象就会直接进入老年代。</p>
<p>空间分配担保：每次MinorGC之前都要检查老年代的连续可用空间是否能够容纳当前新生代所有对象的大小，如果不能容纳就需要FullGC，如果设定了允许担保失败可以不进行FullGC</p>
<h4 id="会不会发生内存泄漏？"><a href="#会不会发生内存泄漏？" class="headerlink" title="会不会发生内存泄漏？"></a>会不会发生内存泄漏？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaopeng527/p/5258413.html">https://www.cnblogs.com/gaopeng527/p/5258413.html</a></p>
<p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</p>
<p>静态集合，容器中的对象在程序结束前不能释放（但是还是可能有用，如果没用了就是泄漏）</p>
<p>HashMap中对象的hash值被改变</p>
<p>各种连接，比如数据库的连接，如果没有close会泄漏</p>
<p>内部类持有外部类，外部类无法GC</p>
<p>ThreadLocalMap中会发生内存泄漏</p>
<h3 id="3-类加载"><a href="#3-类加载" class="headerlink" title="3.类加载"></a>3.类加载</h3><h4 id="何时加载类"><a href="#何时加载类" class="headerlink" title="何时加载类"></a>何时加载类</h4><ol>
<li><p>使用new ，获取类的static，</p>
</li>
<li><p>子类加载的时候发现父类还没有加载</p>
</li>
<li><p>JVM启动的时候main类</p>
</li>
<li><p>使用反射</p>
</li>
<li><p>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
</li>
<li><p>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
</li>
</ol>
<h4 id="类加载过程-Java对象的创建过程：（每一步详细实现）"><a href="#类加载过程-Java对象的创建过程：（每一步详细实现）" class="headerlink" title=".类加载过程/Java对象的创建过程：（每一步详细实现）"></a>.类加载过程/Java对象的创建过程：（每一步详细实现）</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxian1369/p/5498817.html#:~:text=%E5%85%B6%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%8C%85,%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5%E3%80%82">https://www.cnblogs.com/xiaoxian1369/p/5498817.html#:~:text=%E5%85%B6%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%8C%85,%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5%E3%80%82</a></p>
<p>加载（加载进内存、转换成Class实例对象）、</p>
<p>连接（验证、准备：分配空间设置0值、解析）</p>
<p>验证：是确保Class文件的字节流中包含的信息符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>准备：准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初 始值的阶段。</p>
<p>解析：：符号引用-&gt;直接引用</p>
<p>​    直接引用就是直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。</p>
<p>初始化：（执行静态变量复制、静态代码块）</p>
<p>​    执行类构造器·clinit()方法</p>
<h4 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h4><p>​    检查类是否加载</p>
<p>​    分配内存，在堆中分配内存</p>
<p>​    初始化   为变量赋默认值</p>
<p>​    设置对象头  </p>
<p>​    执行<init>()      <init>()是指收集类中的所有实例变量的赋值动作、实例代码块和构造函数</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><h5 id="启动类加载器-由C-实现"><a href="#启动类加载器-由C-实现" class="headerlink" title="启动类加载器  由C++实现"></a>启动类加载器  由C++实现</h5><p>是虚拟机自身的一部分</p>
<p>加载<JAVA_HOME>/lib下的</p>
<h5 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h5><p>加载<JAVA_HOME>/lib/ext/下的</p>
<h5 id="应用程序加载器"><a href="#应用程序加载器" class="headerlink" title="应用程序加载器"></a>应用程序加载器</h5><h5 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h5><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>当一个类加载器接收到一个类加载的任务时，不会立即展开加载，而是将加载任务委托给它的父类加载器去执行，每一层的类都采用相同的方式，直至委托给最顶层的启动类加载器为止。如果父类加载器无法加载委托给它的类，便将类的加载任务退回给下一级类加载器去执行加载。</p>
<p>双亲委托模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载。</p>
<h4 id="为什么要使用双亲委托模型？"><a href="#为什么要使用双亲委托模型？" class="headerlink" title="为什么要使用双亲委托模型？"></a>为什么要使用双亲委托模型？</h4><p>使用双亲委托机制的好处是：能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。使用双亲委托模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委托给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种加载器环境中都是同一个类。相反，如果没有使用双亲委托模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果自己去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行。</p>
<p>双亲委托模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委托的代码都集中在java.lang.ClassLoader的loadClass()方法中，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass方法进行加载。</p>
<h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>自定义一个类加载器，不让他委托给父类</p>
<h4 id="JDK9的模块"><a href="#JDK9的模块" class="headerlink" title="JDK9的模块"></a>JDK9的模块</h4><h3 id="4-Java-内存模型-JMM"><a href="#4-Java-内存模型-JMM" class="headerlink" title="4.Java 内存模型 JMM"></a>4.Java 内存模型 JMM</h3><h4 id="工作内存与主内存"><a href="#工作内存与主内存" class="headerlink" title="工作内存与主内存"></a>工作内存与主内存</h4><p>所有变量都存在主内存，每个线程都还有自己的工作内存，工作内存通过load和store将变量取出或放入。</p>
<h4 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h4><p>大多数现代计算机为了提高性能而采取乱序执行，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。</p>
<p>java的内存屏障通常所谓的四种即<code>LoadLoad</code>,<code>StoreStore</code>,<code>LoadStore</code>,<code>StoreLoad</code>实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p>
<p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
<p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
<p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p>
<p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</p>
<p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p>
<h4 id="DCL为何需要加volatile"><a href="#DCL为何需要加volatile" class="headerlink" title="DCL为何需要加volatile"></a>DCL为何需要加volatile</h4><p>使用了它的禁止重排序，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便 是赋值操作）多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个内存屏障 （Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置</p>
<h4 id="volatile如何实现的内存可见性？"><a href="#volatile如何实现的内存可见性？" class="headerlink" title="volatile如何实现的内存可见性？"></a>volatile如何实现的内存可见性？</h4><p>addl$0x0，(%esp)”的空操作可以将本地处理器的缓存写入内存，该写入动作也会引起处理器或者别的内核缓存无效化，实现了可见性。</p>
<h4 id="volatile如何实现的禁止重排序？"><a href="#volatile如何实现的禁止重排序？" class="headerlink" title="volatile如何实现的禁止重排序？"></a>volatile如何实现的禁止重排序？</h4><p>关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便 是赋值操作）多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个内存屏障 （Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置</p>
<h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><p>​    volatile 变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反映到其他线程之中。从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看 不到不一致的情况，因此可以认为不存在一致性问题。但是由于java中的操作不是原子性的，所以多线程是不安全的。</p>
<p>指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。Volatile修饰的变量可以禁止指令重排序。</p>
<p>在操作前后加一个内存屏障</p>
<p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416190044852.png" alt="image-20210416190044852"></p>
<h4 id="线程的状态转换"><a href="#线程的状态转换" class="headerlink" title="线程的状态转换"></a>线程的状态转换</h4><p>·新建（New）：创建后尚未启动的线程处于这种状态。 </p>
<p>·运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可 能正在执行，也有可能正在等待着操作系统为它分配执行时间。 </p>
<p>·无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线 程显式唤醒。以下方法会让线程陷入无限期的等待状态： ■没有设置Timeout参数的Object::wait()方法； ■没有设置Timeout参数的Thread::join()方法； ■LockSupport::park()方法。 </p>
<p>·限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待 被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状 态： ■Thread::sleep()方法； ■设置了Timeout参数的Object::wait()方法； ■设置了Timeout参数的Thread::join()方法； ■LockSupport::parkNanos()方法； ■LockSupport::parkUntil()方法。 </p>
<p>·阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到 一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时 间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 </p>
<p>·结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</p>
<p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416191130738.png" alt="image-20210416191130738"></p>
<h3 id="5-JVM调优"><a href="#5-JVM调优" class="headerlink" title="5.JVM调优"></a>5.JVM调优</h3><h4 id="设置堆大小"><a href="#设置堆大小" class="headerlink" title="设置堆大小"></a>设置堆大小</h4><p>Xms初始堆大小 </p>
<p>Xmx最大堆大小</p>
<p>PermSize 初始分配的非堆内存</p>
<p>MaxPermSize 最大非堆内存</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">Projects</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text">1.JVM内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OOM%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0OOM%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">OOM了解吗？什么情况下会出现OOM？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StackOverflow%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">StackOverflow出现的场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E4%B8%BA%E4%BA%94%E5%A4%A7%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">1.JVM内存区域分为五大部分：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-Native%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%88%E5%B8%A7-%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E6%98%AF%E8%B0%83%E7%94%A8ni%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%88%E5%B8%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86-%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">1.3.3.</span> <span class="toc-text">堆  几乎所有的对象都在这里分配内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-%EF%BC%9A"><span class="toc-number">1.3.4.</span> <span class="toc-text">方法区 ：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9A"><span class="toc-number">1.3.5.</span> <span class="toc-text">程序计数器：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">3.对象访问定位的方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5%EF%BC%9A2%E7%A7%8D"><span class="toc-number">1.5.</span> <span class="toc-text">5堆内存中对象分配的基本策略：2种</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.5.1.</span> <span class="toc-text">并发问题如何解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.</span> <span class="toc-text">2.垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">如何判断对象是否死亡：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GCRoots%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">GCRoots有哪些？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%B8%B8%E9%87%8F%E6%98%AF%E5%90%A6%E6%97%A0%E7%94%A8%EF%BC%8C%E7%B1%BB%E6%98%AF%E5%90%A6%E6%97%A0%E7%94%A8%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">7.如何判断常量是否无用，类是否无用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-number">2.3.</span> <span class="toc-text">分代收集理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">如何解决跨代引用的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MinorGC-MajorGC-FullGC-%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%95%B4%E5%A0%86%E6%94%B6%E9%9B%86"><span class="toc-number">2.5.</span> <span class="toc-text">MinorGC MajorGC FullGC  新生代、老年代、整堆收集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9AFullGC%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">什么时候会FullGC？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.7.</span> <span class="toc-text">垃圾回收算法？各有什么优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSTW%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">什么是STW？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">什么是安全点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8"><span class="toc-number">2.10.</span> <span class="toc-text">记忆集与卡表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.11.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-Serial-Old"><span class="toc-number">2.11.1.</span> <span class="toc-text">Serial&#x2F;Serial Old</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%84%B6%E5%90%8E%E6%98%AFParNew%EF%BC%8CSerial%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E6%9C%AC"><span class="toc-number">2.11.2.</span> <span class="toc-text">然后是ParNew，Serial的多线程版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%84%B6%E5%90%8E%E6%98%AFParrllel-Scavenge-%E5%92%8CParNew%E6%93%A6%E4%B8%8D%E5%A4%9A"><span class="toc-number">2.11.3.</span> <span class="toc-text">然后是Parrllel Scavenge  和ParNew擦不多</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%84%B6%E5%90%8E%E6%98%AFParallelOld"><span class="toc-number">2.11.4.</span> <span class="toc-text">然后是ParallelOld</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84CMS-2%E6%AC%A1stop-the-world-%E8%AF%A6%E7%BB%86%E7%9C%8B%E4%B8%80%E4%B8%8B"><span class="toc-number">2.11.5.</span> <span class="toc-text">老年代的CMS  2次stop the world  详细看一下</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1-3%E6%AC%A1-stop-the-world"><span class="toc-number">2.11.6.</span> <span class="toc-text">G1 3次 stop the world</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E4%BD%8E%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.11.7.</span> <span class="toc-text">两个低延迟的垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">2.12.</span> <span class="toc-text">内存分配与回收策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">会不会发生内存泄漏？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">3.类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">何时加载类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9A%EF%BC%88%E6%AF%8F%E4%B8%80%E6%AD%A5%E8%AF%A6%E7%BB%86%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">.类加载过程&#x2F;Java对象的创建过程：（每一步详细实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">创建对象的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%94%B1C-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">启动类加载器  由C++实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.4.3.</span> <span class="toc-text">应用程序加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.4.4.</span> <span class="toc-text">自定义加载器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">双亲委派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">为什么要使用双亲委托模型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.</span> <span class="toc-text">破坏双亲委派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK9%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">3.8.</span> <span class="toc-text">JDK9的模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="toc-number">4.</span> <span class="toc-text">4.Java 内存模型 JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%86%85%E5%AD%98"><span class="toc-number">4.1.</span> <span class="toc-text">工作内存与主内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">什么是内存屏障？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DCL%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%8A%A0volatile"><span class="toc-number">4.3.</span> <span class="toc-text">DCL为何需要加volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">volatile如何实现的内存可见性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">volatile如何实现的禁止重排序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.6.</span> <span class="toc-text">volatile 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.7.</span> <span class="toc-text">线程的状态转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JVM%E8%B0%83%E4%BC%98"><span class="toc-number">5.</span> <span class="toc-text">5.JVM调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.1.</span> <span class="toc-text">设置堆大小</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://huajiaohuixiang.github.io/2021/05/12/JVM/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&text=JVM"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&is_video=false&description=JVM"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JVM&body=Check out this article: https://huajiaohuixiang.github.io/2021/05/12/JVM/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&title=JVM"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://huajiaohuixiang.github.io/2021/05/12/JVM/&name=JVM&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://huajiaohuixiang.github.io/2021/05/12/JVM/&t=JVM"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    huajiaohuixiang
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">Projects</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
