<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="temp说说final,finally,finalizefinal 分别修饰类 方法 变量的时候 finalize使用的场合是什么被废弃了已经，不建议使用。GC在回收对象是先将其加入一个队列，然后执行finalize方法在该方法可以实现自救，但finalize只能自己调用一次 finally什么情况下不会执行1 try语句没有执行  2 在try中有System.exit(0)这种语句，会是JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="花椒茴香的个人博客">
<meta property="og:description" content="temp说说final,finally,finalizefinal 分别修饰类 方法 变量的时候 finalize使用的场合是什么被废弃了已经，不建议使用。GC在回收对象是先将其加入一个队列，然后执行finalize方法在该方法可以实现自救，但finalize只能自己调用一次 finally什么情况下不会执行1 try语句没有执行  2 在try中有System.exit(0)这种语句，会是JVM">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-07T13:41:59.000Z">
<meta property="article:modified_time" content="2021-05-12T03:35:43.695Z">
<meta property="article:author" content="huajiaohuixiang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
        
      
    
    <!-- title -->
    <title>Java基础</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="花椒茴香的个人博客" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">Projects</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/03/08/%E9%9B%86%E5%90%88-1/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/03/07/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&text=Java基础"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&is_video=false&description=Java基础"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java基础&body=Check out this article: https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&name=Java基础&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&t=Java基础"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#temp"><span class="toc-number">1.</span> <span class="toc-text">temp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4final-finally-finalize"><span class="toc-number">1.1.</span> <span class="toc-text">说说final,finally,finalize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finalize%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%BA%E5%90%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">finalize使用的场合是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.</span> <span class="toc-text">finally什么情况下不会执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8%E6%96%B0%E5%A2%9E%E4%BA%86%E9%9D%9E%E5%B8%B8%E5%A4%9A%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%8C%E6%9C%AC%E4%B8%93%E9%A2%98%E4%B8%BB%E8%A6%81%E8%AE%A8%E8%AE%BA%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA"><span class="toc-number">1.4.</span> <span class="toc-text">JDK1.8新增了非常多的特性，本专题主要讨论以下几个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">多线程读多写少怎么优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-Java-%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">在 Java 中定义一个不做事且没有参数的构造方法的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.7.</span> <span class="toc-text">如何跳出多层循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%88%B0%E7%BC%93%E5%AD%98%E6%B1%A0%E9%82%A3%E9%87%8C"><span class="toc-number">2.2.</span> <span class="toc-text">可能会到缓存池那里</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">为什么只有值传递？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">重载和重写的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99"><span class="toc-number">4.3.</span> <span class="toc-text">静态方法为什么不能重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">深拷贝与浅拷贝的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">什么是泛型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%AA%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">为什么是伪泛型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">都有什么泛型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%9Fextend-Object-%E5%92%8C%EF%BC%9FSuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">？extend Object  和？Super的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">Object 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.</span> <span class="toc-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E5%92%8CHashMap%E3%80%81HashSet%E6%9F%A5%E6%89%BE%E6%9C%89%E5%85%B3%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">为什么重写 equals 时必须重写 hashCode 方法？（和HashMap、HashSet查找有关）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">面向对象的三大特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">成员变量和局部变量的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">静态方法和实例方法有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">7.5.</span> <span class="toc-text">接口和抽象类的不同?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">8.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%9A%84subString"><span class="toc-number">8.1.</span> <span class="toc-text">String的subString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer-SringBuilder-String-%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.</span> <span class="toc-text">StringBuffer SringBuilder String 区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">9.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">什么是反射？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E9%81%93%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E9%80%94%E5%BE%84"><span class="toc-number">9.2.</span> <span class="toc-text">知道获取Class对象的几种途径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Class%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%87%BA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%87%BA%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">通过Class对象创建出对象，获取出构造器，成员变量，方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E7%9A%84API%E4%BF%AE%E6%94%B9%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%8C%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">通过反射的API修改成员变量的值，调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">9.5.</span> <span class="toc-text">反射优缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">10.</span> <span class="toc-text">java异常体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">Throwable 类常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BB%A7%E6%89%BF%E8%87%AAException%E8%BF%98%E6%98%AFRuntimeException"><span class="toc-number">10.2.</span> <span class="toc-text">写代码的时候怎么处理异常，继承自Exception还是RuntimeException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Error%E8%83%BD%E8%A2%AB%E6%8D%95%E8%8E%B7%E5%90%97%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">Error能被捕获吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">11.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6grow"><span class="toc-number">11.1.</span> <span class="toc-text">ArrayList扩容机制grow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-Add%E8%BF%87%E7%A8%8B"><span class="toc-number">11.2.</span> <span class="toc-text">ArrayList  Add过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashmap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">Hashmap底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashmap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">11.4.</span> <span class="toc-text">Hashmap底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.5.</span> <span class="toc-text">TreeSet的底层数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">11.6.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E6%9C%BA%E5%88%B6-%E2%80%9Cfail-fast%E2%80%9D%EF%BC%9F"><span class="toc-number">11.7.</span> <span class="toc-text">Java集合的快速失败机制 “fail-fast”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.8.</span> <span class="toc-text">comparable 和 Comparator 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E5%92%8CTreeMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.9.</span> <span class="toc-text">HashMap 和TreeMap的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E5%8C%BA%E5%88%AB"><span class="toc-number">11.10.</span> <span class="toc-text">HashMap和HashTable区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable%E5%92%8CConcurrentHashMap%E5%8C%BA%E5%88%AB"><span class="toc-number">11.11.</span> <span class="toc-text">HashTable和ConcurrentHashMap区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%A8%E7%9A%84CAS%E5%92%8CSynchronized"><span class="toc-number">11.12.</span> <span class="toc-text">ConcurrentHashMap中如何用的CAS和Synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">进程线程的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-number">12.2.</span> <span class="toc-text">线程的基本状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">为什么要多线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%AB%99%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">为什么程序计数器、本地方法站、虚拟机栈是私有的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">多线程可能遇到的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">并发编程三要素？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">12.7.</span> <span class="toc-text">上下文是什么？切换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E4%B8%8D%E7%AD%89%E5%AE%83%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9D%9F"><span class="toc-number">12.8.</span> <span class="toc-text">Java如何安全地停止一个线程(不等它运行结束)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">12.9.</span> <span class="toc-text">创建线程的四种方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">12.10.</span> <span class="toc-text">Callable的创建过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.11.</span> <span class="toc-text">runnable 和 callable 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run-%E5%92%8Cstart-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.12.</span> <span class="toc-text">run()和start()的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FutureTask%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">12.13.</span> <span class="toc-text">FutureTask原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.14.</span> <span class="toc-text">Sleep和wait的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8-wait-%E6%96%B9%E6%B3%95%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8-if-%E5%9D%97%E8%BF%98%E6%98%AF%E5%BE%AA%E7%8E%AF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.15.</span> <span class="toc-text">你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95-wait-notify-%E5%92%8C-notifyAll-%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8-Object-%E7%B1%BB%E9%87%8C%EF%BC%9F"><span class="toc-number">12.16.</span> <span class="toc-text">为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-notify-%E5%92%8C-notifyAll-%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">12.17.</span> <span class="toc-text">为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Thread-%E7%B1%BB%E7%9A%84-sleep-%E5%92%8C-yield-%E6%96%B9%E6%B3%95%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%EF%BC%9F"><span class="toc-number">12.18.</span> <span class="toc-text">为什么 Thread 类的 sleep()和 yield ()方法是静态的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">12.19.</span> <span class="toc-text">为什么要线程池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.20.</span> <span class="toc-text">线程池介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">12.21.</span> <span class="toc-text">创建线程池的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Executor-%E6%A1%86%E6%9E%B6%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Executor-%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-number">12.22.</span> <span class="toc-text">什么是 Executor 框架？为什么使用 Executor 框架？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">12.23.</span> <span class="toc-text">自定义线程池ThreadPoolExecutor线程池的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.24.</span> <span class="toc-text">Executors创建的线程池的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%9B%BA%E5%AE%9A%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fixed-Thread-Pool"><span class="toc-number">12.24.1.</span> <span class="toc-text">线程数固定的线程池 Fixed Thread Pool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-Cached-Thread-Pool"><span class="toc-number">12.24.2.</span> <span class="toc-text">可缓存的线程池 Cached Thread Pool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">12.24.3.</span> <span class="toc-text">单线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E6%97%A0%E9%99%90%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">12.24.4.</span> <span class="toc-text">大小无限线程池</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">12.25.</span> <span class="toc-text">线程池有什么优点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">12.26.</span> <span class="toc-text">线程池的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD-submit-%E5%92%8C-execute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.27.</span> <span class="toc-text">线程池中 submit() 和 execute() 方法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">12.28.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.29.</span> <span class="toc-text">如何定义一个注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">12.30.</span> <span class="toc-text">哪里用到了线程池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield-%E6%96%B9%E6%B3%95"><span class="toc-number">12.31.</span> <span class="toc-text">yield()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-out-println-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">12.32.</span> <span class="toc-text">System.out.println()线程安全？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">13.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">13.1.</span> <span class="toc-text">流的划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">13.2.</span> <span class="toc-text">四个抽象基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JAVA%E4%B8%AD%E7%9A%84NIO"><span class="toc-number">13.3.</span> <span class="toc-text">JAVA中的NIO</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Java基础
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">huajiaohuixiang</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-03-07T13:41:59.000Z" itemprop="datePublished">2021-03-07</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Java/" rel="tag">Java</a>, <a class="tag-link-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h3 id="temp"><a href="#temp" class="headerlink" title="temp"></a>temp</h3><h4 id="说说final-finally-finalize"><a href="#说说final-finally-finalize" class="headerlink" title="说说final,finally,finalize"></a>说说final,finally,finalize</h4><p>final 分别修饰类 方法 变量的时候</p>
<h4 id="finalize使用的场合是什么"><a href="#finalize使用的场合是什么" class="headerlink" title="finalize使用的场合是什么"></a>finalize使用的场合是什么</h4><p>被废弃了已经，不建议使用。GC在回收对象是先将其加入一个队列，然后执行finalize方法在该方法可以实现自救，但finalize只能自己调用一次</p>
<h4 id="finally什么情况下不会执行"><a href="#finally什么情况下不会执行" class="headerlink" title="finally什么情况下不会执行"></a>finally什么情况下不会执行</h4><p>1 try语句没有执行 </p>
<p>2 在try中有System.exit(0)这种语句，会是JVM退出</p>
<p>3 在守护线程中Daemond</p>
<h4 id="JDK1-8新增了非常多的特性，本专题主要讨论以下几个"><a href="#JDK1-8新增了非常多的特性，本专题主要讨论以下几个" class="headerlink" title="JDK1.8新增了非常多的特性，本专题主要讨论以下几个"></a>JDK1.8新增了非常多的特性，本专题主要讨论以下几个</h4><ul>
<li><strong>Lambda表达式</strong>：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>
<li><strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li>
<li><strong>默认方法</strong>：默认方法就是一个在接口里面有了一个实现的方法。</li>
<li><strong>新工具</strong>：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li>
<li><strong>Stream API</strong>：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>
<li><strong>Date Time API</strong>：加强对日期与时间的处理。</li>
<li><strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li><strong>Nashorn，JavaScript引擎</strong>：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<h4 id="多线程读多写少怎么优化"><a href="#多线程读多写少怎么优化" class="headerlink" title="多线程读多写少怎么优化"></a>多线程读多写少怎么优化</h4><p>多读少写的场景 如何提高性能<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013452337/article/details/90238052">https://blog.csdn.net/u013452337/article/details/90238052</a></p>
<p>ReentrantedLock（读读、读写、写写都是互斥）-&gt;ReentrantReadWriteLock（改进了读读，读写、写写还是互斥）-&gt;StampeddLock（允许在读的时候获得写锁，然后读锁阻塞）读写锁  但是会造成饥饿问题</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33220089/article/details/105173632">https://blog.csdn.net/qq_33220089/article/details/105173632</a></p>
<p>Mysql悲观锁乐观锁<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33220089/article/details/103920324">https://blog.csdn.net/qq_33220089/article/details/103920324</a></p>
<p>使用读写锁在CopyOnWriteArrayList中，写是往拷贝的数组中写，读是读原来的，写完后在赋值给原来的。通过volatile可见性实现。</p>
<h4 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h4><p>如果子类有一个无参构造函数，而父类没有无参构造函数、只有有参构造函数，则会编译不通过，子类的无参需要先调用父类的无参，而父类有了有参后，默认的无参就不生效了</p>
<p>自己整理的题目以及答案</p>
<h4 id="如何跳出多层循环"><a href="#如何跳出多层循环" class="headerlink" title="如何跳出多层循环"></a>如何跳出多层循环</h4><p>使用带有标号的break   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> a;</span><br></pre></td></tr></table></figure>


<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？"><a href="#讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？" class="headerlink" title="讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？"></a>讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？</h4><p>java有八大基本类型，short、int、long、float、double、boolean、byte、char  对于这个八个基本类型都有对应的包装类型，比如int Integer、Short与short、char与Character。基本类型到包装类型就是装箱、包装类型到基本类型就是拆箱。</p>
<p>对于Integer 来说， Integer i=1     调用了Intteger.valueOf()方法； int n=i 调用了Integer.intValue()方法；</p>
<h4 id="可能会到缓存池那里"><a href="#可能会到缓存池那里" class="headerlink" title="可能会到缓存池那里"></a>可能会到缓存池那里</h4><p>Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。</p>
<p>为了性能和资源之间平衡的最好结果。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>默认是同一个包内可见</p>
<p>protect是同一个包内+所有包的子类</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="为什么只有值传递？"><a href="#为什么只有值传递？" class="headerlink" title="为什么只有值传递？"></a>为什么只有值传递？</h4><p>程序设计语言来说，有值传递和引用传递；</p>
<p>在Java中，函数得到的都是对对象引用的一个拷贝；对于其他设计语言来讲，比如C++ 如果传递的是&amp; 则函数收到的就是这个对象。</p>
<h4 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h4><p>重载是指对象中可以有很多相同方法名相同的函数，根据不同的输入参数，可以做不同的事。方法签名包括方法名与参数。<strong>重载函数可以返回类型和访问修饰符可以不同</strong>。<strong>不能有两个方法签名相同但是返回类型不同的方法。</strong>就是不能依靠返回类型来判别。</p>
<p>重写是指子类对父类继承函数的重新编写，方法名、参数都必须相同。返回值必须比父类的更小或相等，抛出异常的范围要小于父类，访问修饰符的权限要大于等于父类。如果父类方法被final private static 修饰，不能被重写，对于static的函数可以重新声明，代表子类的静态函数。</p>
<p>返回值必须更小（子类）或者相等是指比如父类返回List  子类可以返回ArrayList （对于Void 和基本数据类型不可更改，只能和父类相同）</p>
<p>抛出异常： 也是指抛出的要是父类异常的子类</p>
<h4 id="静态方法为什么不能重写"><a href="#静态方法为什么不能重写" class="headerlink" title="静态方法为什么不能重写"></a>静态方法为什么不能重写</h4><p>静态属性和静态方法只是可以继承没有表现出多态性。根据《java编程思想》中的描述这是因为静态方法和静态属性没有采用动态绑定。即使你定义了相同的静态方法名，他也只是子类和父类的两个方法，并没有继承的关系，并且也会默认隐藏父类的静态方法。具体表现就是，将子类实例向上转型则会调用到基类中的静态方法和属性，不转型就调用子类自身的静态方法和属性。编译器不推荐通过实例去调用静态方法和属性，因为这种调用方式容易造成混淆。</p>
<p>可以通过子类去调用父类的静态方法，但是子类如果有相同名称的静态方法，会默认隐藏父类的静态方法</p>
<h4 id="深拷贝与浅拷贝的区别？"><a href="#深拷贝与浅拷贝的区别？" class="headerlink" title="深拷贝与浅拷贝的区别？"></a>深拷贝与浅拷贝的区别？</h4><p>对于基本属于类型来讲，这两个拷贝是一样的都是拷贝的值。</p>
<p>对于引用数据类型来讲，浅拷贝是指只拷贝当前对象对于对象中的各个属性对象不在继续拷贝。对于深拷贝来讲不仅拷贝当前对象，对于对象中的各个属性也会递归拷贝。</p>
<p>例如：有一个Student 中有teacher属性，对student 进行浅拷贝后，这两个student是不同的对象但是其中的teacher却指向了相同的对象。如果是深拷贝则会指向不同的对象。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h4><p>泛型就是编写模板代码来适应任意类型</p>
<h4 id="为什么是伪泛型？"><a href="#为什么是伪泛型？" class="headerlink" title="为什么是伪泛型？"></a>为什么是伪泛型？</h4><p>Java泛型是伪泛型，对于List<String>和List<Integer>经过JVM编译后都会变成List 里面是通过Object来存储，所以对于List<Integer>我们可以通过反射来向里面添加String而不报错。</p>
<h4 id="都有什么泛型？"><a href="#都有什么泛型？" class="headerlink" title="都有什么泛型？"></a>都有什么泛型？</h4><p>类的泛型，对接口的泛型，对方法的泛型；</p>
<h4 id="？extend-Object-和？Super的区别？"><a href="#？extend-Object-和？Super的区别？" class="headerlink" title="？extend Object  和？Super的区别？"></a>？extend Object  和？Super的区别？</h4><p>？代表所有</p>
<p>?extend  C是指继承于C的都可以，确定了上限</p>
<p>？Super C是指是C的父类都可以，确定了下限</p>
<h3 id="Object-方法"><a href="#Object-方法" class="headerlink" title="Object 方法"></a>Object 方法</h3><p>equals  hashcode wait notify </p>
<h4 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h4><h4 id="为什么重写-equals-时必须重写-hashCode-方法？（和HashMap、HashSet查找有关）"><a href="#为什么重写-equals-时必须重写-hashCode-方法？（和HashMap、HashSet查找有关）" class="headerlink" title="为什么重写 equals 时必须重写 hashCode 方法？（和HashMap、HashSet查找有关）"></a>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？（和HashMap、HashSet查找有关）</h4><p>其实简单的说就是为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。</p>
<p>因为Object的Hashcode方法是native方法有JVMC或C++实现的，如果重写了equals方法而没有重写hashxcode 有可能出翔equals相等而hashcode不同。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="面向对象的三大特性？"><a href="#面向对象的三大特性？" class="headerlink" title="面向对象的三大特性？"></a>面向对象的三大特性？</h4><p>继承、子类拥有父类的所有属性和方法，但是被private修饰的不能访问</p>
<p>封装、</p>
<p>多态 程序中定义的引用类型调用的方法在编译时并不能确定，需要在运行时确定，具体表现就是通过父类来指向子类实现多态 或者通过接口来实现多态</p>
<h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p>面向对象是一种 <strong>对现实世界理解和抽象的方法</strong>，是计算机编程技术发展到一定阶段后的产物。</p>
<p><strong>面向过程</strong>  (Procedure Oriented) 是一种 <strong>以过程为中心</strong> 的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。</p>
<h4 id="成员变量和局部变量的区别？"><a href="#成员变量和局部变量的区别？" class="headerlink" title="成员变量和局部变量的区别？"></a>成员变量和局部变量的区别？</h4><p>语法上 成员变量属于类 局部变量属于方法 成员变量可以用访问修饰符修饰 局部变量不能</p>
<p>内存分配上 成员变量在堆中 局部变量在栈中 如果局部变量是对象的话，也是在堆中分配，栈帧中存放一个引用 （可以分一下引用类型和基本类型）</p>
<p>生存时间：成员变量随着类  局部变量随着方法</p>
<p>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
<h4 id="静态方法和实例方法有什么不同？"><a href="#静态方法和实例方法有什么不同？" class="headerlink" title="静态方法和实例方法有什么不同？"></a>静态方法和实例方法有什么不同？</h4><p>静态方法属于类。对于静态方法其不能访问非静态属性，因为调用该静态方法的时候，该类可能没有对象，成员变量还没有初始化。可以通过类名和对象名来调用。</p>
<p>实例方法属于对象。只能通过对象名来调用实例方法</p>
<h4 id="接口和抽象类的不同"><a href="#接口和抽象类的不同" class="headerlink" title="接口和抽象类的不同?"></a>接口和抽象类的不同?</h4><p>含义上：而抽象类是对类的抽象,用于捕捉子类共同的特征。</p>
<p>抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。</p>
<p>从抽象来看 接口定义了一组行为规范，实现该接口的必须都要实现接口定义的方法</p>
<p>abstract class 表示的是is a关系，interface表示的是like a关系。</p>
<p>可以实现多个接口但只能继承一个抽象类。</p>
<p>语法上：</p>
<p>抽象类必修要有一个abstract方法，且抽象类不能被实例化，其余和普通方法一样，可以实现静态方法与普通方法、普通变量、静态变量、常量；</p>
<p>接口不能拥有普通方法与普通变量，但可以有默认方法实现，静态变量静态方法；</p>
<p>接口的默认访问权限是public，且不能有其他访问权限进行修饰；</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String的subString"><a href="#String的subString" class="headerlink" title="String的subString"></a>String的subString</h4><p>先判断类型lantin1还是utf16   然后分别调用StringLantin1.newString(byte数组，起始位置，长度)或者StringUtf16.newString()</p>
<h4 id="StringBuffer-SringBuilder-String-区别"><a href="#StringBuffer-SringBuilder-String-区别" class="headerlink" title="StringBuffer SringBuilder String 区别"></a>StringBuffer SringBuilder String 区别</h4><p>String类是被final修饰表示不可继承，其成员变量byte数组被private final修饰被final修饰指向数组不变，private并且没有提供修改数组的方法则整个 字符串是不i可变的。因为String的不可变性，我们每次对字符串操作其实都要生成一个新的字符串，然后指向新的字符串。会产生大量临时对象，然后GC会便麻烦。</p>
<p>builder和buffer中都是没有final修饰char数组，StringBuilder、<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。</p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>对于任意一个类我们都能知道这个类的属性和方法，对于任意一个对象我们都能调用它的任意一个属性和方法。这种动态获取信息以及动态调用方法的功能称为反射；</p>
<h4 id="知道获取Class对象的几种途径"><a href="#知道获取Class对象的几种途径" class="headerlink" title="知道获取Class对象的几种途径"></a>知道获取Class对象的几种途径</h4><p>（类名.class、Class.forname()、对象.getClass()</p>
<h4 id="通过Class对象创建出对象，获取出构造器，成员变量，方法"><a href="#通过Class对象创建出对象，获取出构造器，成员变量，方法" class="headerlink" title="通过Class对象创建出对象，获取出构造器，成员变量，方法"></a>通过Class对象创建出对象，获取出构造器，成员变量，方法</h4><p>.getPackage()、getModifiers()、getName()、getSimpleName()、getSuperclass()</p>
<p> 获取类属性<br>    getFields()    //获取所有的公共(public)字段包括父类       返回Field[]数组<br>   getDeclaredFields()  // 获取所有声明的字段(不包括父类)       返回Field[]<br>     getField(String name) //  获取指定的公共字段包括父类       返回Field<br>    getDeclaredField(String name)   // 获取指定的声明的字段(不包括父类)                返回Field</p>
<h4 id="通过反射的API修改成员变量的值，调用方法"><a href="#通过反射的API修改成员变量的值，调用方法" class="headerlink" title="通过反射的API修改成员变量的值，调用方法"></a>通过反射的API修改成员变量的值，调用方法</h4><p>操作类属性<br>**     操作静态属性<br>     类属性对象.get(null)              //返回静态属性的值<br>     类属性对象.set(null,”值”)                //赋值<br>**    操作非静态属性<br>    类属性对象.get(Object obj);<br>    类属性对象.set(Object obj,”值”);</p>
<h4 id="反射优缺点："><a href="#反射优缺点：" class="headerlink" title="反射优缺点："></a>反射优缺点：</h4><p>比较灵活，反射是框架设计的灵魂，</p>
<p>速度会变慢</p>
<h3 id="java异常体系"><a href="#java异常体系" class="headerlink" title="java异常体系"></a>java异常体系</h3><p>​    java异常都是继承于Throwable，分为Exception和Error。错误一般都是很严重的故障，通常不用捕获Error，比如OOM StackOverFlow</p>
<p>​    Exception分为runtime exception和IO Exception，比如Index OurofBound  NullPointer。</p>
<p>Exception还可以按可检查与不可检查来分类，可检查的Exception，如果对其没有做try 或者throws不能通过编译。class not found filenot found 。 </p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常</p>
<p>IO异常和SQL异常是受检查异常。除了runtime其余的都是受检查的异常。</p>
<h4 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h4><ul>
<li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h4 id="写代码的时候怎么处理异常，继承自Exception还是RuntimeException"><a href="#写代码的时候怎么处理异常，继承自Exception还是RuntimeException" class="headerlink" title="写代码的时候怎么处理异常，继承自Exception还是RuntimeException"></a>写代码的时候怎么处理异常，继承自Exception还是RuntimeException</h4><p>通常业务类异常如果希望它是Throwable的，或者带有业务语义的异常，就定义checked；系统类异常就unchecked。</p>
<p>如果我们的服务是很稳定的，可以继承自RuntimeException，不需要try catch去处理。如果不是稳定的，需要调用它的人对逻辑进行补充，那么可以继承自Exception。</p>
<h4 id="Error能被捕获吗？"><a href="#Error能被捕获吗？" class="headerlink" title="Error能被捕获吗？"></a>Error能被捕获吗？</h4><p>Error跟Exception一样都继承自Throwable，是指不应该被捕获的严重错误。实际上在代码中是可以被catch的。但是没用</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="ArrayList扩容机制grow"><a href="#ArrayList扩容机制grow" class="headerlink" title="ArrayList扩容机制grow"></a>ArrayList扩容机制grow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>grow函数调用grow(size+1)在另一个里面会调用newCapacity(size+1)，然后返回新的数组长度（原来的+原来的右移一位），然后调用Arrayss.copyOf()</p>
<h4 id="ArrayList-Add过程"><a href="#ArrayList-Add过程" class="headerlink" title="ArrayList  Add过程"></a>ArrayList  Add过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br><span class="line">add(e, elementData,  size);</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>
<p>一个普通的add 会调用私有的add</p>
<p>先判断当前数组的容量是否和长度相同,相同则表示已经满了需要扩容调用grow</p>
<p>然后elementData[size]=e；</p>
<p>size++;</p>
<h4 id="Hashmap底层实现原理"><a href="#Hashmap底层实现原理" class="headerlink" title="Hashmap底层实现原理"></a>Hashmap底层实现原理</h4><ol>
<li><p>底层结构</p>
<p>内部是Entry数组，Entry包含四个字段，hash值，val，key，next；</p>
<p>数组中每一个位置都当成一个桶，在桶内使用拉链法解决哈希冲突的问题。</p>
<p>数组的大小为2的幂，默认16，寻址可以通过取余，但是太慢，当size为2的幂的时候，通过与size-1 &amp; 按位与会和取余得到相同的结果还很快；扩容的时候一个拆两个也会更容易。在分库的时候一般也是按2的幂来分库，更容易扩展。</p>
</li>
<li><p>put调用putval，1.8链表并不是头插法，是尾插入，要先比较有无key相同的情况。</p>
</li>
<li><p>扩容 </p>
<p>当map中的Entry数量大于阈值，就表明可能存在很多哈希冲突，导致性能下降，会进行扩容。 </p>
<p>先获取原数组+原容量+原阈值 获得新大小（对容量为0等情况进行了考虑）普通情况下得到2倍容量，然后将原数组映射到新数组，再指向新数组，映射是将hash与size与，因为size的后面全是0 的得到的都是0，第一位是1，通过这样可以快速将其分为高位和低位。</p>
</li>
<li><p>树化 每putVal之后会检查当前桶的大小是否大于8 大于8并且总的数组大小大于64会将该桶树化，数组大小小于64的话会扩容，因为扩容也会将该桶内的节点稀释到高位桶中。</p>
</li>
<li><p>加载因子用于控制HashMap的疏密程度，如果Entry数量/数组大小&gt;加载因子，表明将有很多哈希冲突，需要扩容</p>
</li>
<li><p>计算哈希值  null返回0   否则和hashcode的高16位异或。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>get方法，先判断数组是否为空 数组的长度是否大于0，在数组的那个节点是否为null ，然后检查第一个节点是不是，然后判断结构，分别调用tree的方法和链表遍历判断equals</p>
</li>
</ol>
<p>capacity+阈值+扩容</p>
<h4 id="Hashmap底层实现原理-1"><a href="#Hashmap底层实现原理-1" class="headerlink" title="Hashmap底层实现原理"></a>Hashmap底层实现原理</h4><ol>
<li>size方法   size不仅要得到当前的大小，还需要得到当前CAS失败的数量。</li>
</ol>
<h4 id="TreeSet的底层数据结构"><a href="#TreeSet的底层数据结构" class="headerlink" title="TreeSet的底层数据结构"></a>TreeSet的底层数据结构</h4><p>使用TreeMap实现，和HashSet一样</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>
<p>写/删时加锁，并且写的时候写道副本里，然后往副本写，写完后将原指针指向副本。</p>
<p>读直接读。</p>
<p>实现了读写分离。</p>
<h4 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h4><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p>
<p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p>
<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>解决办法：</p>
<p>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</p>
<p>使用CopyOnWriteArrayList来替换ArrayList</p>
<h4 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h4><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<h4 id="HashMap-和TreeMap的区别"><a href="#HashMap-和TreeMap的区别" class="headerlink" title="HashMap 和TreeMap的区别"></a>HashMap 和TreeMap的区别</h4><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>
<h4 id="HashMap和HashTable区别"><a href="#HashMap和HashTable区别" class="headerlink" title="HashMap和HashTable区别"></a>HashMap和HashTable区别</h4><p>HashTable是线程安全的，为每个方法加了Synchronized。HashTable继承于字典类。</p>
<p>Hash Table 中不能存在null   。HashMap中的key和value都可以是null</p>
<p>计算Hash的方式不同，hashtable是使用对象的hashcode，hashmap重新计算了hash值，通过和前面16位异或</p>
<p>计算索引的方法不同：hashtable是取余，hashmap是与length按位与&amp;</p>
<p>扩容hashtable 长度必须是奇数，减少hash碰撞；hashmap的2的幂</p>
<h4 id="HashTable和ConcurrentHashMap区别"><a href="#HashTable和ConcurrentHashMap区别" class="headerlink" title="HashTable和ConcurrentHashMap区别"></a>HashTable和ConcurrentHashMap区别</h4><p>HashTable粗暴的为每个方法加了Synchronized，为整个数组加了锁，效率很低。</p>
<p>ConHashMap在1.7中，将整个数组分为很多Segment，每个Segment中有几个Node，每次只对一个Segment加锁。在1.8中，取消了segment的使用，为每个节点使用CAS和Synchronized保证并发。</p>
<h4 id="ConcurrentHashMap中如何用的CAS和Synchronized"><a href="#ConcurrentHashMap中如何用的CAS和Synchronized" class="headerlink" title="ConcurrentHashMap中如何用的CAS和Synchronized"></a>ConcurrentHashMap中如何用的CAS和Synchronized</h4><p>put方法中，先判断key地方位置是否为空，如果是空就cas写入，如果不为空则需要加锁来对这个链表写入。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="进程线程的区别？"><a href="#进程线程的区别？" class="headerlink" title="进程线程的区别？"></a>进程线程的区别？</h4><p>进程是程序的一次执行，是系统运行程序的基本单位，相对于程序来讲他是动态的。进程是系统进行资源分配的基本单位，系统会为</p>
<p>线程是进程的一个执行单元，是进程内的调度实体，是系统进行资源调度的基本单位。</p>
<p>进程之间是互相独立的地址空间、独立的资源、同一个进程的多个线程之间共享本进程的地址空间，线程共享本进程的资源如内存、I/O、cpu等。在Java中，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p>
<p>进程切换时，消耗的资源大，线程切换时消耗的资源小。</p>
<p>线程之间通信更加方便，同一个进程下，线程共享全局变量，静态变量等数据，但是需要处理多线程并发的问题。</p>
<h4 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h4><p>新建NEW  还没有调用start方法</p>
<p>可运行-运行RUNNABLE   </p>
<p>阻塞  等待锁的时候进入阻塞状态 join </p>
<p>等待 wait()  通过notify()唤醒 </p>
<p>超时等待 sleep(1000) wait（1000） 通过notify()唤醒</p>
<p>终止 线程结束</p>
<h4 id="为什么要多线程？"><a href="#为什么要多线程？" class="headerlink" title="为什么要多线程？"></a>为什么要多线程？</h4><h4 id="为什么程序计数器、本地方法站、虚拟机栈是私有的？"><a href="#为什么程序计数器、本地方法站、虚拟机栈是私有的？" class="headerlink" title="为什么程序计数器、本地方法站、虚拟机栈是私有的？"></a>为什么程序计数器、本地方法站、虚拟机栈是私有的？</h4><h4 id="多线程可能遇到的问题？"><a href="#多线程可能遇到的问题？" class="headerlink" title="多线程可能遇到的问题？"></a>多线程可能遇到的问题？</h4><p>死锁、内存泄漏、不安全</p>
<h4 id="并发编程三要素？"><a href="#并发编程三要素？" class="headerlink" title="并发编程三要素？"></a>并发编程三要素？</h4><p>原子 可见 有序</p>
<h4 id="上下文是什么？切换？"><a href="#上下文是什么？切换？" class="headerlink" title="上下文是什么？切换？"></a>上下文是什么？切换？</h4><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。</p>
<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<h4 id="Java如何安全地停止一个线程-不等它运行结束"><a href="#Java如何安全地停止一个线程-不等它运行结束" class="headerlink" title="Java如何安全地停止一个线程(不等它运行结束)"></a>Java如何安全地停止一个线程(不等它运行结束)</h4><p>共享变量或者 interrupt（）  然后再run中不断判断isInterrupt()</p>
<h4 id="创建线程的四种方式？"><a href="#创建线程的四种方式？" class="headerlink" title="创建线程的四种方式？"></a>创建线程的四种方式？</h4><p>thread runnable callable 线程池</p>
<h4 id="Callable的创建过程？"><a href="#Callable的创建过程？" class="headerlink" title="Callable的创建过程？"></a>Callable的创建过程？</h4><ol>
<li>创建实现Callable接口的类myCallable</li>
<li>以myCallable为参数创建FutureTask对象</li>
<li>将FutureTask作为参数创建Thread对象</li>
<li>调用线程对象的start()方法</li>
</ol>
<h4 id="runnable-和-callable-有什么区别？"><a href="#runnable-和-callable-有什么区别？" class="headerlink" title="runnable 和 callable 有什么区别？"></a>runnable 和 callable 有什么区别？</h4><ol>
<li>返回值callable 通过futuretask.get()获取，且会阻塞当前主进程</li>
<li>runnable只能抛出运行时异常且无法捕获处理</li>
<li>callable的call方法允许抛出异常，可以获得异常信息。</li>
</ol>
<h4 id="run-和start-的区别？"><a href="#run-和start-的区别？" class="headerlink" title="run()和start()的区别？"></a>run()和start()的区别？</h4><p>start()方法用于启动线程，run()方法是线程体。run可以重复调用，而start只能调用一次。我们如果单独的调用run方法就相当于调用了普通的函数。</p>
<p>new一个线程进入到新建状态，start后进入可运行状态，在时间片到了之后就可以执行run方法了</p>
<h4 id="FutureTask原理？"><a href="#FutureTask原理？" class="headerlink" title="FutureTask原理？"></a>FutureTask原理？</h4><p>FutureTask用来表示一个异步执行任务的结果，可以通过get方法获得该结果，如果还没有完成会 阻塞。</p>
<p>FutureTask本身也实现了callable， 可以用它本身来构建futuretask</p>
<h4 id="Sleep和wait的区别"><a href="#Sleep和wait的区别" class="headerlink" title="Sleep和wait的区别"></a>Sleep和wait的区别</h4><p>wait是Object的方法，sleep是线程的方法</p>
<p>wait 释放锁sleep不释放锁</p>
<p>wait后需要notify来唤醒 wait(long time)会自动唤醒但是会争夺锁如果没有获得锁无法继续向下执行</p>
<p>sleep自动唤醒</p>
<h4 id="你是如何调用-wait-方法的？使用-if-块还是循环？为什么？"><a href="#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？" class="headerlink" title="你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h4><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<h4 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h4><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p>
<p>wait(), notify()和 notifyAll()这些方法在同步代码块中调用</p>
<p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p>
<p>综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。</p>
<h4 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h4><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p>
<h4 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h4><p>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<h4 id="为什么要线程池？"><a href="#为什么要线程池？" class="headerlink" title="为什么要线程池？"></a>为什么要线程池？</h4><p>因为对象的创建和销毁是很花费时间的，因为创建一个对象需要获取内存和其它资源。对于线程对象也是如此，所以我们将若干线程放入到线程池中，然后如果有任务来就把任务给线程去执行，减少线程创建和销毁的时间。</p>
<h4 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h4><p>线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p>
<h4 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h4><p>new ThreadPoolExcutor()</p>
<p>使用Excutors工具类创建</p>
<h4 id="什么是-Executor-框架？为什么使用-Executor-框架？"><a href="#什么是-Executor-框架？为什么使用-Executor-框架？" class="headerlink" title="什么是 Executor 框架？为什么使用 Executor 框架？"></a>什么是 Executor 框架？为什么使用 Executor 框架？</h4><p>使用<strong>Executors</strong>工具类可以很方便的创建线程池。</p>
<h4 id="自定义线程池ThreadPoolExecutor线程池的参数"><a href="#自定义线程池ThreadPoolExecutor线程池的参数" class="headerlink" title="自定义线程池ThreadPoolExecutor线程池的参数"></a>自定义线程池ThreadPoolExecutor线程池的参数</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903475197788168">https://juejin.cn/post/6844903475197788168</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> corePoolSize,</span><br><span class="line"><span class="keyword">int</span> maximumPoolSize,</span><br><span class="line"><span class="keyword">long</span> keepAliveTime,</span><br><span class="line">TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">ThreadFactory threadFactory,</span><br><span class="line">RejectedExecutionHandler handler</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>corePoolSize=&gt; </code>线程池里的核心线程数量</p>
</li>
<li><p><code>maximumPoolSize</code>=&gt; 线程池里允许有的最大线程数量</p>
</li>
<li><p><code>keepAliveTime=&gt; </code>空闲线程存活时间</p>
</li>
<li><p><code>unit=&gt; </code>keepAliveTime的时间单位,比如分钟,小时等</p>
</li>
<li><p><code>workQueue=&gt; 缓冲</code>队列</p>
</li>
<li><p><code>threadFactory=&gt; </code>线程工厂用来创建新的线程放入线程池</p>
</li>
<li><p><code>handler=&gt; </code>线程池拒绝任务的处理策略,比如抛出异常等策略</p>
</li>
<li><p>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</p>
<p>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</p>
<p>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</p>
<p>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</p>
</li>
</ul>
<h4 id="Executors创建的线程池的类型"><a href="#Executors创建的线程池的类型" class="headerlink" title="Executors创建的线程池的类型"></a>Executors创建的线程池的类型</h4><p>java.util.concurrent.Executors 提供了一系列静态方法来创建各种线程池。下面例举出了主要的一些线程池及特性，其它未例举线程池的特性可由下面这些推导出来。</p>
<h5 id="线程数固定的线程池-Fixed-Thread-Pool"><a href="#线程数固定的线程池-Fixed-Thread-Pool" class="headerlink" title="线程数固定的线程池 Fixed Thread Pool"></a>线程数固定的线程池 Fixed Thread Pool</h5><p>顾名思义，这种类型线程池线程数量是固定的。如果线程数量设置为n，则任何时刻该线程池最多只有n个线程处于运行状态。当线程池中处于饱和运行状态时，再往线程池中提交的任务会被放到执行队列中。如果线程池处于不饱和状态，线程池也会一直存在，直到ExecuteService 的shutdown方法被调用，线程池才会被清除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建线程数量为5的线程池。&#96;&#96;ExecutorService executorService &#x3D; Executors.newFixedThreadPool(&#96;&#96;5&#96;&#96;);</span><br></pre></td></tr></table></figure>
<p> 它使用的阻塞队列是Linked  无限大，所以可能会堆积大量任务 然后OOM</p>
<h5 id="可缓存的线程池-Cached-Thread-Pool"><a href="#可缓存的线程池-Cached-Thread-Pool" class="headerlink" title="可缓存的线程池 Cached Thread Pool"></a>可缓存的线程池 Cached Thread Pool</h5><p>这种类型的线程池初始大小为0个线程，随着往池里不断提交任务，如果线程池里面没有闲置线程（0个线程也表示没有闲置线程），则会创建新的线程，保证没有任务在等待；如果有闲置线程，则复用闲置状态线程执行任务。处于闲置状态的线程只会在线程池中缓存60秒，闲置时间达到60s的线程会被关闭并移出线程池。在处理大量短暂的（官方说法：short-lived）异步任务时可以显著得提供程序性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个可缓存的线程池 &#96;&#96;ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<p> 他会构建一个 最大线程为无限大的线程池</p>
<h5 id="单线程池"><a href="#单线程池" class="headerlink" title="单线程池"></a>单线程池</h5><p>这或许不能叫线程池了，由于它里面的线程永远只有1个，而且自始至终都只有1个（为什么说这句话，因为要和 Executors.newFixedThreadPool(1) 区别开来），所以还是叫它“单线程池把”。你尽可以往单线程池中添加任务，但是每次只执行1个，且任务是按顺序执行的。如果前面的任务出现了异常，当前线程会被销毁，但1个新的线程会被创建用来执行后面的任务。以上这些和线程数只有1个的线程Fixed Thread Pool一样。两者唯一不同的是， Executors.newFixedThreadPool(1) 可以在运行时修改它里面的线程数，而 Executors.newSingleThreadExecutor() 永远只能有1个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个单线程池&#96;&#96;ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>
<p> 它使用的阻塞队列是Linked  无限大，所以可能会堆积大量任务 然后OOM</p>
<h5 id="大小无限线程池"><a href="#大小无限线程池" class="headerlink" title="大小无限线程池"></a>大小无限线程池</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService &#x3D; Executors.newScheduledThreadPool();</span><br></pre></td></tr></table></figure>
<p>核心线程自定义 可以是Integer.MAX_VALUE</p>
<h4 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h4><ul>
<li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li>
<li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
<li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</li>
</ul>
<p>综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。</p>
<h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><ul>
<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li>
<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>
</ul>
<h4 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h4><p>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</p>
<p>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</p>
<p>异常处理：submit()方便Exception处理</p>
<p><code>submit()</code>执行Runnable的任务时，run()方法没显式抛出异常。<br><code>execute()</code>执行Callable的任务时，call()方法有显式的抛出异常。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="如何定义一个注解"><a href="#如何定义一个注解" class="headerlink" title="如何定义一个注解"></a>如何定义一个注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Hahaha&#123;</span><br><span class="line">	 <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过四种元注解修饰注解：@Target，@Retention，@Documented，@Inherited,</p>
<h4 id="哪里用到了线程池？"><a href="#哪里用到了线程池？" class="headerlink" title="哪里用到了线程池？"></a>哪里用到了线程池？</h4><p>连接数据库的时候Druid</p>
<p><strong>jion()方法：</strong>线程实例的join()方法可以使得一个线程在另一个线程结束后再执行，即也就是说使得<strong>当前线程可以阻塞其他线程执行；</strong></p>
<blockquote>
<p>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。</p>
<p>比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
</blockquote>
<h4 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h4><p>理论上，yield意味着放手，放弃，投降。一个调用yield()方法的线程告诉虚拟机它乐意让其他线程占用自己的位置。这表明该线程没有在做一些紧急的事情。注意，这仅是一个暗示，并不能保证不会产生任何影响。</p>
<h4 id="System-out-println-线程安全？"><a href="#System-out-println-线程安全？" class="headerlink" title="System.out.println()线程安全？"></a>System.out.println()线程安全？</h4><p>是安全的，通过synchronized实现</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ft305977550/article/details/78769573">https://blog.csdn.net/ft305977550/article/details/78769573</a></p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="流的划分"><a href="#流的划分" class="headerlink" title="流的划分"></a>流的划分</h4><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<h4 id="四个抽象基类"><a href="#四个抽象基类" class="headerlink" title="四个抽象基类"></a>四个抽象基类</h4><ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>select  poll  epoll是linux中实现io多路复用的方法，</p>
<h4 id="JAVA中的NIO"><a href="#JAVA中的NIO" class="headerlink" title="JAVA中的NIO"></a>JAVA中的NIO</h4><p>Java的NIO模式的Selector网络通讯，其实就是一个简单的Reactor模型。可以说是Reactor模型的朴素原型。</p>
<p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/Java/Java%20IO.html#%E4%B8%83%E3%80%81nio">http://www.cyc2018.xyz/Java/Java%20IO.html#%E4%B8%83%E3%80%81nio</a></p>
<p><strong>通道</strong> <strong>Channel</strong>  </p>
<p>**缓冲区 ** </p>
<p>**选择器 ** </p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">Projects</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#temp"><span class="toc-number">1.</span> <span class="toc-text">temp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4final-finally-finalize"><span class="toc-number">1.1.</span> <span class="toc-text">说说final,finally,finalize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finalize%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%BA%E5%90%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">finalize使用的场合是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.</span> <span class="toc-text">finally什么情况下不会执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8%E6%96%B0%E5%A2%9E%E4%BA%86%E9%9D%9E%E5%B8%B8%E5%A4%9A%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%8C%E6%9C%AC%E4%B8%93%E9%A2%98%E4%B8%BB%E8%A6%81%E8%AE%A8%E8%AE%BA%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA"><span class="toc-number">1.4.</span> <span class="toc-text">JDK1.8新增了非常多的特性，本专题主要讨论以下几个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">多线程读多写少怎么优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-Java-%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">在 Java 中定义一个不做事且没有参数的构造方法的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.7.</span> <span class="toc-text">如何跳出多层循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%88%B0%E7%BC%93%E5%AD%98%E6%B1%A0%E9%82%A3%E9%87%8C"><span class="toc-number">2.2.</span> <span class="toc-text">可能会到缓存池那里</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">为什么只有值传递？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">重载和重写的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99"><span class="toc-number">4.3.</span> <span class="toc-text">静态方法为什么不能重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">深拷贝与浅拷贝的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">什么是泛型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%AA%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">为什么是伪泛型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">都有什么泛型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%9Fextend-Object-%E5%92%8C%EF%BC%9FSuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">？extend Object  和？Super的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">Object 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.</span> <span class="toc-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E5%92%8CHashMap%E3%80%81HashSet%E6%9F%A5%E6%89%BE%E6%9C%89%E5%85%B3%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">为什么重写 equals 时必须重写 hashCode 方法？（和HashMap、HashSet查找有关）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">面向对象的三大特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">成员变量和局部变量的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">静态方法和实例方法有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">7.5.</span> <span class="toc-text">接口和抽象类的不同?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">8.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%9A%84subString"><span class="toc-number">8.1.</span> <span class="toc-text">String的subString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer-SringBuilder-String-%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.</span> <span class="toc-text">StringBuffer SringBuilder String 区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">9.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">什么是反射？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E9%81%93%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E9%80%94%E5%BE%84"><span class="toc-number">9.2.</span> <span class="toc-text">知道获取Class对象的几种途径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Class%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%87%BA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%87%BA%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">通过Class对象创建出对象，获取出构造器，成员变量，方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E7%9A%84API%E4%BF%AE%E6%94%B9%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%8C%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">通过反射的API修改成员变量的值，调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">9.5.</span> <span class="toc-text">反射优缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">10.</span> <span class="toc-text">java异常体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">Throwable 类常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BB%A7%E6%89%BF%E8%87%AAException%E8%BF%98%E6%98%AFRuntimeException"><span class="toc-number">10.2.</span> <span class="toc-text">写代码的时候怎么处理异常，继承自Exception还是RuntimeException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Error%E8%83%BD%E8%A2%AB%E6%8D%95%E8%8E%B7%E5%90%97%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">Error能被捕获吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">11.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6grow"><span class="toc-number">11.1.</span> <span class="toc-text">ArrayList扩容机制grow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-Add%E8%BF%87%E7%A8%8B"><span class="toc-number">11.2.</span> <span class="toc-text">ArrayList  Add过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashmap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">Hashmap底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashmap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">11.4.</span> <span class="toc-text">Hashmap底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.5.</span> <span class="toc-text">TreeSet的底层数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">11.6.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E6%9C%BA%E5%88%B6-%E2%80%9Cfail-fast%E2%80%9D%EF%BC%9F"><span class="toc-number">11.7.</span> <span class="toc-text">Java集合的快速失败机制 “fail-fast”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.8.</span> <span class="toc-text">comparable 和 Comparator 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E5%92%8CTreeMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.9.</span> <span class="toc-text">HashMap 和TreeMap的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E5%8C%BA%E5%88%AB"><span class="toc-number">11.10.</span> <span class="toc-text">HashMap和HashTable区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable%E5%92%8CConcurrentHashMap%E5%8C%BA%E5%88%AB"><span class="toc-number">11.11.</span> <span class="toc-text">HashTable和ConcurrentHashMap区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%A8%E7%9A%84CAS%E5%92%8CSynchronized"><span class="toc-number">11.12.</span> <span class="toc-text">ConcurrentHashMap中如何用的CAS和Synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">进程线程的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-number">12.2.</span> <span class="toc-text">线程的基本状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">为什么要多线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%AB%99%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">为什么程序计数器、本地方法站、虚拟机栈是私有的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">多线程可能遇到的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">并发编程三要素？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">12.7.</span> <span class="toc-text">上下文是什么？切换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E4%B8%8D%E7%AD%89%E5%AE%83%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9D%9F"><span class="toc-number">12.8.</span> <span class="toc-text">Java如何安全地停止一个线程(不等它运行结束)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">12.9.</span> <span class="toc-text">创建线程的四种方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">12.10.</span> <span class="toc-text">Callable的创建过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.11.</span> <span class="toc-text">runnable 和 callable 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run-%E5%92%8Cstart-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.12.</span> <span class="toc-text">run()和start()的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FutureTask%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">12.13.</span> <span class="toc-text">FutureTask原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.14.</span> <span class="toc-text">Sleep和wait的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8-wait-%E6%96%B9%E6%B3%95%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8-if-%E5%9D%97%E8%BF%98%E6%98%AF%E5%BE%AA%E7%8E%AF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.15.</span> <span class="toc-text">你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95-wait-notify-%E5%92%8C-notifyAll-%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8-Object-%E7%B1%BB%E9%87%8C%EF%BC%9F"><span class="toc-number">12.16.</span> <span class="toc-text">为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-notify-%E5%92%8C-notifyAll-%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">12.17.</span> <span class="toc-text">为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Thread-%E7%B1%BB%E7%9A%84-sleep-%E5%92%8C-yield-%E6%96%B9%E6%B3%95%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%EF%BC%9F"><span class="toc-number">12.18.</span> <span class="toc-text">为什么 Thread 类的 sleep()和 yield ()方法是静态的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">12.19.</span> <span class="toc-text">为什么要线程池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.20.</span> <span class="toc-text">线程池介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">12.21.</span> <span class="toc-text">创建线程池的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Executor-%E6%A1%86%E6%9E%B6%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Executor-%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-number">12.22.</span> <span class="toc-text">什么是 Executor 框架？为什么使用 Executor 框架？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">12.23.</span> <span class="toc-text">自定义线程池ThreadPoolExecutor线程池的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.24.</span> <span class="toc-text">Executors创建的线程池的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%9B%BA%E5%AE%9A%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fixed-Thread-Pool"><span class="toc-number">12.24.1.</span> <span class="toc-text">线程数固定的线程池 Fixed Thread Pool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-Cached-Thread-Pool"><span class="toc-number">12.24.2.</span> <span class="toc-text">可缓存的线程池 Cached Thread Pool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">12.24.3.</span> <span class="toc-text">单线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E6%97%A0%E9%99%90%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">12.24.4.</span> <span class="toc-text">大小无限线程池</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">12.25.</span> <span class="toc-text">线程池有什么优点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">12.26.</span> <span class="toc-text">线程池的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD-submit-%E5%92%8C-execute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.27.</span> <span class="toc-text">线程池中 submit() 和 execute() 方法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">12.28.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.29.</span> <span class="toc-text">如何定义一个注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">12.30.</span> <span class="toc-text">哪里用到了线程池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield-%E6%96%B9%E6%B3%95"><span class="toc-number">12.31.</span> <span class="toc-text">yield()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-out-println-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">12.32.</span> <span class="toc-text">System.out.println()线程安全？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">13.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">13.1.</span> <span class="toc-text">流的划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">13.2.</span> <span class="toc-text">四个抽象基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JAVA%E4%B8%AD%E7%9A%84NIO"><span class="toc-number">13.3.</span> <span class="toc-text">JAVA中的NIO</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&text=Java基础"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&is_video=false&description=Java基础"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java基础&body=Check out this article: https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&title=Java基础"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&name=Java基础&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/&t=Java基础"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    huajiaohuixiang
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/huajiaohuixiang">Projects</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
