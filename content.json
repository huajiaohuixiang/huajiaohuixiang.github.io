{"meta":{"title":"花椒茴香的个人博客","subtitle":"安得广厦千万间","description":"","author":"huajiaohuixiang","url":"http://huajiaohuixiang.github.io","root":"/"},"pages":[{"title":"search","date":"2021-02-22T03:23:18.000Z","updated":"2021-02-22T03:23:30.326Z","comments":true,"path":"search/index.html","permalink":"http://huajiaohuixiang.github.io/search/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-02-22T03:22:42.000Z","updated":"2021-02-22T03:22:53.407Z","comments":true,"path":"categories/index.html","permalink":"http://huajiaohuixiang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-22T03:16:17.000Z","updated":"2021-02-22T03:19:57.240Z","comments":true,"path":"tags/index.html","permalink":"http://huajiaohuixiang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"StringBuffer和StringBuilder","slug":"StringBuffer","date":"2021-02-21T02:47:49.000Z","updated":"2021-02-21T15:12:53.609Z","comments":true,"path":"2021/02/21/StringBuffer/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/21/StringBuffer/","excerpt":"","text":"首先两者继承的类，实现的接口都是一模一样，所提供的接口也是完全相同，不同的是StringBuffer是线程安全的，StringBuilder是不安全的。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"内部类","slug":"内部类","date":"2021-02-21T02:47:49.000Z","updated":"2021-02-21T15:10:35.584Z","comments":true,"path":"2021/02/21/内部类/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/21/%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"参考：https://www.liaoxuefeng.com/wiki/1252599548343744/1376414781669409 嵌套类分为三种内部类 ,匿名类，静态内部类 InnerClass和匿名类本质上相同，都需要依靠外部类才能实现，静态内部类不需要依赖外部类。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"多态","slug":"多态","date":"2021-02-21T02:47:49.000Z","updated":"2021-02-21T14:33:08.729Z","comments":true,"path":"2021/02/21/多态/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/21/%E5%A4%9A%E6%80%81/","excerpt":"","text":"多态：对于某个类型的方法调用，实际调用的方法取决于运行时实际类型的方法。 12345678910111213141516171819202122public void run(Person p)&#123; p.run();&#125;Class Person&#123; void run()&#123; System.out.println(&quot;Person&quot;); &#125;&#125;Class Teacher extends Person&#123; @override void run()&#123; System.out.println(&quot;Teacher&quot;); &#125;&#125;public static void main(String [] args)&#123; Person p1=new Person(); Person p2=new Teacher(); run(p1); run(p2);&#125; 以上代码分别会打印各自的run ， 因为两者的实际类型不同，通过声明类型传值","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"枚举类","slug":"枚举类","date":"2021-02-21T02:47:49.000Z","updated":"2021-02-21T15:10:28.426Z","comments":true,"path":"2021/02/21/枚举类/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/21/%E6%9E%9A%E4%B8%BE%E7%B1%BB/","excerpt":"","text":"枚举类我们可以使用这种方式来实现枚举类： 12345public class Weekday&#123; public static final int MON=1; public static final int Tu=2; ...&#125; 虽然可以实现，但是在使用的时候会出现问题，编译器不能检测出不在类中的值。 1234int day=0;if(day==Weekday.MON)&#123; ...&#125; 所以我们用enum来实现枚举类:(编译器会将他们编译成final class Weekday extends Enum{…}) 123enum Weekday&#123; MON,Tue,Wed,Thur,Fri,Sat,Sun;&#125; 与enum类似的还有record类 14后才有。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"模块","slug":"模块","date":"2021-02-21T02:47:49.000Z","updated":"2021-02-21T14:33:07.744Z","comments":true,"path":"2021/02/21/模块/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/21/%E6%A8%A1%E5%9D%97/","excerpt":"","text":"java模块 参考资料：https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"修饰符","slug":"4修饰符","date":"2021-02-21T02:31:04.000Z","updated":"2021-02-21T05:45:53.537Z","comments":true,"path":"2021/02/21/4修饰符/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/21/4%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"1.private 只能自己访问，子类extends后也不能访问 protected 子类可以访问 默认的（无） 同一个包内 public 所有都可以访问 继承关系final 该类不能被继承 sealed + permits 指定某些类继承 123public sealed class Shape permits a,b,c&#123; ...&#125; interface接口的default方法因为接口没有字段，所以接口无法定义非抽象的函数，这时候需要default修饰符来实现default方法，可以给予实现。default方法的目的主要是因为如果想往接口中增加一个方法但是又会影响所有实现接口的类都要实现该新增的方法，使用default便可以不影响所有类。 staticstatic fields​ 静态字段 ​ 对于接口来说是不能拥有fields的，但是如果你直接写 int a;是不会报错的，因为编译器自动将其转换为了static final int a; static methods​ 静态方法主要用于工具方法和辅助方法，例如： 123Arrays.sort();public static void main()&#123;...&#125;;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-ArrayList","slug":"ArrayList","date":"2021-02-20T06:13:38.000Z","updated":"2021-02-20T15:43:32.608Z","comments":true,"path":"2021/02/20/ArrayList/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/20/ArrayList/","excerpt":"","text":"12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList 数组列表，分别实现了列表、随机访问、可克隆、序列化，继承了抽象列表,其关系如下所示： 1.几个参数12345678910111213141516private static final long serialVersionUID = 8683452581122892189L;private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData; // non-private to simplify nested class accessprivate int size; 2.主要方法构造方法123456789101112131415public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 传入另一个集合，先将collection转为数组，然后copy到elementData中 123456789101112public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 3.trimToSize()修剪大小到size12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 4. 增加容量123456789public void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; elementData.length &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123; modCount++; grow(minCapacity); &#125;&#125;用到了grow() ,newCapacity(minCapacity) ,hugeCapacity(int minCapacity)方法 5.得到O地址1234567891011121314151617int indexOfRange(Object o, int start, int end) &#123; Object[] es = elementData; if (o == null) &#123; for (int i = start; i &lt; end; i++) &#123; if (es[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; end; i++) &#123; if (o.equals(es[i])) &#123; return i; &#125; &#125; &#125; return -1;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-LinkedList","slug":"LinkedList","date":"2021-02-20T06:13:38.000Z","updated":"2021-02-20T15:43:54.898Z","comments":true,"path":"2021/02/20/LinkedList/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/20/LinkedList/","excerpt":"","text":"123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 比ArrayList多实现了Queue和Deque 即实现了双向队列，ArrayList直接继承AbstractList，LinkedList继承于AbstractSequentialList,即顺序访问，AbstractList适合随机访问。 LinkedList底层就是链表实现，有内部类Node ，然后又first节点、last节点。 1234567891011transient int size = 0;/** * Pointer to first node. */transient Node&lt;E&gt; first;/** * Pointer to last node. */transient Node&lt;E&gt; last; Node类，item内容，前指针和后指针，双向链表 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 剩下的就是对链表的一些操作以及toArray等等。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-List","slug":"List","date":"2021-02-20T06:13:38.000Z","updated":"2021-02-20T14:31:21.203Z","comments":true,"path":"2021/02/20/List/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/20/List/","excerpt":"","text":"List接口实现了Collection接口，主要有以下函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195//返回大小int size();//判空boolean isEmpty();//判断是否包含boolean contains(Object o);Iterator&lt;E&gt; iterator();Object[] toArray();&lt;T&gt; T[] toArray(T[] a);boolean add(E e);boolean remove(Object o);boolean containsAll(Collection&lt;?&gt; c);boolean addAll(Collection&lt;? extends E&gt; c);boolean addAll(int index, Collection&lt;? extends E&gt; c);boolean removeAll(Collection&lt;?&gt; c);//删除掉不在c中的元素boolean retainAll(Collection&lt;?&gt; c);default void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final ListIterator&lt;E&gt; li = this.listIterator(); while (li.hasNext()) &#123; li.set(operator.apply(li.next())); &#125;&#125;@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125;void clear();boolean equals(Object o);int hashCode();//下面是比Collection多的方法E get(int index);E set(int index, E element);void add(int index, E element);E remove(int index);int indexOf(Object o);int lastIndexOf(Object o);// List IteratorsListIterator&lt;E&gt; listIterator();ListIterator&lt;E&gt; listIterator(int index);// ViewList&lt;E&gt; subList(int fromIndex, int toIndex);//重写了Collection的可分割迭代器@Overridedefault Spliterator&lt;E&gt; spliterator() &#123; if (this instanceof RandomAccess) &#123; return new AbstractList.RandomAccessSpliterator&lt;&gt;(this); &#125; else &#123; return Spliterators.spliterator(this, Spliterator.ORDERED); &#125;&#125;//下面的暂时还没看static &lt;E&gt; List&lt;E&gt; of() &#123; return ImmutableCollections.emptyList();&#125;static &lt;E&gt; List&lt;E&gt; of(E e1) &#123; return new ImmutableCollections.List12&lt;&gt;(e1);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2) &#123; return new ImmutableCollections.List12&lt;&gt;(e1, e2);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);&#125;@SafeVarargs@SuppressWarnings(&quot;varargs&quot;)static &lt;E&gt; List&lt;E&gt; of(E... elements) &#123; switch (elements.length) &#123; // implicit null check of elements case 0: return ImmutableCollections.emptyList(); case 1: return new ImmutableCollections.List12&lt;&gt;(elements[0]); case 2: return new ImmutableCollections.List12&lt;&gt;(elements[0], elements[1]); default: return new ImmutableCollections.ListN&lt;&gt;(elements); &#125;&#125;static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) &#123; return ImmutableCollections.listCopy(coll);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-transient","slug":"transient","date":"2021-02-20T06:13:38.000Z","updated":"2021-02-21T02:02:38.090Z","comments":true,"path":"2021/02/20/transient/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/20/transient/","excerpt":"","text":"参考资料https://www.cnblogs.com/lanxuezaipiao/p/3369962.html https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698 在java中，只要实现了java.io.Serializable接口，该类就可以序列化。 transient关键字用来标明不想序列化的某个属性，例如在ArrayList源码中，elementData就不想被序列化，则使用了transient。 12345678910public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; // non-private to simplify nested class access ...&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-Collection","slug":"Collection","date":"2021-02-20T02:45:38.000Z","updated":"2021-02-20T11:50:04.804Z","comments":true,"path":"2021/02/20/Collection/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/20/Collection/","excerpt":"","text":"interface Collection集合层次结构中的根接口。集合代表一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。有些是有序的，而另一些则是无序的。JDK不提供 此接口的任何直接实现：它提供了更多特定子接口的实现，例如{@code Set}和{@code List}。该接口通常用于传递集合并在需要最大通用性的地方操纵它们。 Bags或multisets（可能包含重复元素的无序集合）应直接实现此接口。 所有通用的{@code Collection}实现类（通常通过其子接口之一间接实现{@code Collection}）应提供两个“标准”构造函数：void（无自变量）构造函数，该构造函数创建一个空的集合，以及一个带有单个实参类型为{@code Collection}的构造函数，该构造函数创建一个新集合，其元素与实参相同。实际上，后一个构造函数允许用户复制任何集合，从而产生所需实现类型的等效集合。没有强制执行此约定的方法（因为接口不能包含构造函数），但是Java平台库中的所有通用{@code Collection} 实现都可以遵循。 12345678910@see Set@see List@see SortedSet@see HashSet@see TreeSet@see ArrayList@see LinkedList@see Vector@see AbstractCollection // 以上这些实现了Collection接口 方法解析1.size()返回集合大小 12345678/** * Returns the number of elements in this collection. If this collection * contains more than &#123;@code Integer.MAX_VALUE&#125; elements, returns * &#123;@code Integer.MAX_VALUE&#125;. * * @return the number of elements in this collection */int size(); 2.isEmpty() 123456/** * Returns &#123;@code true&#125; if this collection contains no elements. * * @return &#123;@code true&#125; if this collection contains no elements */boolean isEmpty(); 3.contains(Object o) 123456789101112131415161718/** * Returns &#123;@code true&#125; if this collection contains the specified element. * More formally, returns &#123;@code true&#125; if and only if this collection * contains at least one element &#123;@code e&#125; such that * &#123;@code Objects.equals(o, e)&#125;. * * @param o element whose presence in this collection is to be tested * @return &#123;@code true&#125; if this collection contains the specified * element * @throws ClassCastException if the type of the specified element * is incompatible with this collection * (&lt;a href=&quot;&#123;@docRoot&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified element is null and this * collection does not permit null elements * (&lt;a href=&quot;&#123;@docRoot&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) */boolean contains(Object o); 4.iterator()返回一个迭代器 123456789/** * Returns an iterator over the elements in this collection. There are no * guarantees concerning the order in which the elements are returned * (unless this collection is an instance of some class that provides a * guarantee). * * @return an &#123;@code Iterator&#125; over the elements in this collection */Iterator&lt;E&gt; iterator(); 5.toArray()转换成数组 12345678Object[] toArray();&lt;T&gt; T[] toArray(T[] a);default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) &#123; return toArray(generator.apply(0));&#125; 6.add()添加元素 1boolean add(E e); 7.去除元素 1boolean remove(Object o); 8.containAll()返回是否包含该集合的所有元素 12345678910111213141516171819/** * Returns &#123;@code true&#125; if this collection contains all of the elements * in the specified collection. * * @param c collection to be checked for containment in this collection * @return &#123;@code true&#125; if this collection contains all of the elements * in the specified collection * @throws ClassCastException if the types of one or more elements * in the specified collection are incompatible with this * collection * (&lt;a href=&quot;&#123;@docRoot&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified collection contains one * or more null elements and this collection does not permit null * elements * (&lt;a href=&quot;&#123;@docRoot&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null. * @see #contains(Object) */boolean containsAll(Collection&lt;?&gt; c); 9.addALL() 1boolean addAll(Collection&lt;? extends E&gt; c); 10.removeAll 1boolean removeAll(Collection&lt;?&gt; c); 11.removesif()去除所有符合条件的元素 12345678910111213default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed;&#125; 12.retainAll()去除所有不在c中的元素 12345678910boolean retainAll(Collection&lt;?&gt; c);/** * Removes all of the elements from this collection (optional operation). * The collection will be empty after this method returns. * * @throws UnsupportedOperationException if the &#123;@code clear&#125; operation * is not supported by this collection */ 13.clear()清楚所有 1void clear(); 14.equals和hashcode 15.可分割迭代器 1234@Overridedefault Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, 0);&#125; 16.Stream 获得流 1234//这个是串行流default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。 Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 123+--------------------+ +------+ +------+ +---+ +-------+| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|+--------------------+ +------+ +------+ +---+ +-------+ 以上的流程转换为 Java 代码为： 123456List&lt;Integer&gt; transactionsIds = widgets.stream() .filter(b -&gt; b.getColor() == RED) .sorted((x,y) -&gt; x.getWeight() - y.getWeight()) .mapToInt(Widget::getWeight) .sum(); 参考https://www.runoob.com/java/java8-streams.html 17.获得并行流 1234//并行流default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-Iterable","slug":"Iterable","date":"2021-02-20T02:45:38.000Z","updated":"2021-02-20T11:23:39.393Z","comments":true,"path":"2021/02/20/Iterable/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/20/Iterable/","excerpt":"","text":"interface Iterable介绍1234567* Implementing this interface allows an object to be the target of the enhanced* &#123;@code for&#125; statement (sometimes called the &quot;for-each loop&quot; statement).** @param &lt;T&gt; the type of elements returned by the iterator** @since 1.5* @jls 14.14.2 The enhanced &#123;@code for&#125; statement 实现此接口允许一个对象成为增强for语句的目标,就是下面这样。 123456789a.forEach( new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) &#123; &#125; &#125;); 构造函数123456/** * Returns an iterator over elements of type &#123;@code T&#125;. * * @return an Iterator. */Iterator&lt;T&gt; iterator(); forEach()函数，重点12345678910111213141516171819202122232425262728/** * Performs the given action for each element of the &#123;@code Iterable&#125; * until all elements have been processed or the action throws an * exception. Actions are performed in the order of iteration, if that * order is specified. Exceptions thrown by the action are relayed to the * caller. * &lt;p&gt; * The behavior of this method is unspecified if the action performs * side-effects that modify the underlying source of elements, unless an * overriding class has specified a concurrent modification policy. * * @implSpec * &lt;p&gt;The default implementation behaves as if: * &lt;pre&gt;&#123;@code * for (T t : this) * action.accept(t); * &#125;&lt;/pre&gt; * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; 使用的话可以通过匿名类、lamda表达式、现有方法的名称。 Spliterator spliterator()Spliterator是一个可分割迭代器(splitable iterator)，可以和iterator顺序遍历迭代器一起看。jdk1.8发布后，对于并行处理的能力大大增强，Spliterator就是为了并行遍历元素而设计的一个迭代器。 123456789101112131415161718192021222324/** * Creates a &#123;@link Spliterator&#125; over the elements described by this * &#123;@code Iterable&#125;. * * @implSpec * The default implementation creates an * &lt;em&gt;&lt;a href=&quot;../util/Spliterator.html#binding&quot;&gt;early-binding&lt;/a&gt;&lt;/em&gt; * spliterator from the iterable&#x27;s &#123;@code Iterator&#125;. The spliterator * inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterable&#x27;s iterator. * * @implNote * The default implementation should usually be overridden. The * spliterator returned by the default implementation has poor splitting * capabilities, is unsized, and does not report any spliterator * characteristics. Implementing classes can nearly always provide a * better implementation. * * @return a &#123;@code Spliterator&#125; over the elements described by this * &#123;@code Iterable&#125;. * @since 1.8 */default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-Reference","slug":"四种引用","date":"2021-02-20T02:45:38.000Z","updated":"2021-02-20T02:45:23.608Z","comments":true,"path":"2021/02/20/四种引用/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/20/%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/","excerpt":"","text":"Java四种引用：强引用、软引用、弱引用、虚引用 强引用：new一个对象就是强引用，可以通过赋null来取消引用，被强引用的对象永远都不会被回收即使Out of memory。 软引用：SoftReference，被软引用的对象将会在内存不够用时被GC回收 弱引用：WeakReference，将会在下一轮GC被回收，如果对象有finalize()，将会先执行finalize()，然后再回收，这时可能会延后一个GC 虚引用：用来标记对象是否要回收，如果一个对象只有虚引用，那么将会回收 参考：https://zhanghaoxin.blog.csdn.net/article/details/80991802 ​ https://www.cnblogs.com/skywang12345/p/3154474.html","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Kinect获取 骨骼图骨骼三维坐标","slug":"Kinect获取-骨骼图骨骼三维坐标","date":"2021-02-19T14:14:50.000Z","updated":"2021-02-19T15:21:19.631Z","comments":true,"path":"2021/02/19/Kinect获取-骨骼图骨骼三维坐标/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/19/Kinect%E8%8E%B7%E5%8F%96-%E9%AA%A8%E9%AA%BC%E5%9B%BE%E9%AA%A8%E9%AA%BC%E4%B8%89%E7%BB%B4%E5%9D%90%E6%A0%87/","excerpt":"","text":"Kinect获取 骨骼图骨骼三维坐标该项目需要我们利用KinectV2 获取骨骼图并得到头部坐标，每一秒取一帧，一共五分钟，将坐标输出。 KinectV2 可以获得色彩图、深度图、骨骼图等等，其实一开始我也不知道该从哪里下手，但对骨骼图的代码进行了一下分析找到了突破点。 对KinectV2大体了解：Kinect一共有三个坐标空间，分别是相机空间、深度空间、色彩空间，相机空间对应骨骼图等，深度空间对应深度图，色彩空间对应色彩图，并且KInectSDK中有CoordinateMapper类来实现深度空间到相机空间和深度空间到色彩空间的转换。具体查看官方文档：https://docs.microsoft.com/en-us/previous-versions/windows/kinect/dn785530(v=ieb.10) 重点需要关心获取的帧的数据如何存储的，对于骨骼图，SDK中有两个重要的类分别是IBody 和 Joint 分别代表人和骨骼点。 1234567891011121314151617IBody : public IUnknown &#123; public: virtual HRESULT STDMETHODCALLTYPE GetJoints( /* [annotation] */ _Pre_equal_to_(JointType_Count) UINT capacity, /* [annotation][size_is][out] */ _Out_writes_all_(capacity) Joint *joints) = 0; ... virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsTracked( /* [annotation][out][retval] */ _Out_ BOOLEAN *tracked) = 0; ... &#125;; 分别利用GetJoints函数和get_IsTracked函数可以获得Joints和判断是否被记录到了。 对于Joints 12345678910#ifndef _Joint_#define _Joint_typedef struct _Joint &#123; JointType JointType; CameraSpacePoint Position; TrackingState TrackingState; &#125; Joint;#endif // _Joint_ 一个struct 里面有Joint类型、相机空间位置、追踪状态（是否被观测到），接着往里看CameSpacePoint 12345678910#ifndef _CameraSpacePoint_#define _CameraSpacePoint_typedef struct _CameraSpacePoint &#123; float X; float Y; float Z; &#125; CameraSpacePoint;#endif // _CameraSpacePoint_ 到这里就很清楚了，直接就可以得到相机空间地址了。（本来我以为需要先获得深度图地址，然后自己进行坐标计算的。。。） 然后SDK还定义了一下常量和其他类，在这里贴一下以防看代码的时候不懂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566enum _JointType &#123; JointType_SpineBase = 0, JointType_SpineMid = 1, JointType_Neck = 2, JointType_Head = 3, JointType_ShoulderLeft = 4, JointType_ElbowLeft = 5, JointType_WristLeft = 6, JointType_HandLeft = 7, JointType_ShoulderRight = 8, JointType_ElbowRight = 9, JointType_WristRight = 10, JointType_HandRight = 11, JointType_HipLeft = 12, JointType_KneeLeft = 13, JointType_AnkleLeft = 14, JointType_FootLeft = 15, JointType_HipRight = 16, JointType_KneeRight = 17, JointType_AnkleRight = 18, JointType_FootRight = 19, JointType_SpineShoulder = 20, JointType_HandTipLeft = 21, JointType_ThumbLeft = 22, JointType_HandTipRight = 23, JointType_ThumbRight = 24, JointType_Count = ( JointType_ThumbRight + 1 ) &#125; ;#endif // _JointType_#ifndef _TrackingState_#define _TrackingState_typedef enum _TrackingState TrackingState;enum _TrackingState &#123; TrackingState_NotTracked = 0, TrackingState_Inferred = 1, TrackingState_Tracked = 2 &#125; ;#endif // _TrackingState_ IBodyFrame : public IUnknown &#123; public: virtual HRESULT STDMETHODCALLTYPE GetAndRefreshBodyData( UINT capacity, /* [annotation][size_is][out][in] */ _Inout_updates_all_(capacity) IBody **bodies) = 0; virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FloorClipPlane( /* [annotation][out][retval] */ _Out_ Vector4 *floorClipPlane) = 0; virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RelativeTime( /* [annotation][out][retval] */ _Out_ TIMESPAN *relativeTime) = 0; virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BodyFrameSource( /* [annotation][out][retval] */ _COM_Outptr_ IBodyFrameSource **bodyFrameSource) = 0; &#125;; 下面是项目代码的详细步骤： 第一步需要安装Kinect 的SDK，然后再Visual Studio进行项目配置，具体可以参考一下文章： https://blog.csdn.net/lizhiguo18/article/details/51037672 https://blog.csdn.net/weixin_43850620/article/details/103874847 对项目配置好后就可以写代码啦。 1.这一步应该是获取Kinect，然后打开。 123IKinectSensor * mySensor = nullptr;GetDefaultKinectSensor(&amp;mySensor);mySensor-&gt;Open(); 2.准备读取ColorFrame 1234567891011 IColorFrameSource * myColorSource = nullptr;mySensor-&gt;get_ColorFrameSource(&amp;myColorSource);IColorFrameReader * myColorReader = nullptr;myColorSource-&gt;OpenReader(&amp;myColorReader);int colorHeight = 0, colorWidth = 0;IFrameDescription * myDescription = nullptr;myColorSource-&gt;get_FrameDescription(&amp;myDescription);myDescription-&gt;get_Height(&amp;colorHeight);myDescription-&gt;get_Width(&amp;colorWidth);IColorFrame * myColorFrame = nullptr;Mat original(colorHeight, colorWidth, CV_8UC4); 3.准备读取BodyFrame 123456789 IBodyFrameSource * myBodySource = nullptr;mySensor-&gt;get_BodyFrameSource(&amp;myBodySource);IBodyFrameReader * myBodyReader = nullptr;myBodySource-&gt;OpenReader(&amp;myBodyReader);int myBodyCount = 0;myBodySource-&gt;get_BodyCount(&amp;myBodyCount);IBodyFrame * myBodyFrame = nullptr;ICoordinateMapper * myMapper = nullptr;mySensor-&gt;get_CoordinateMapper(&amp;myMapper); 4.每30帧获取一帧然后输出 123456789101112131415161718192021222324252627282930313233343536373839 int fps = 0;while (1)&#123; while (myColorReader-&gt;AcquireLatestFrame(&amp;myColorFrame) != S_OK); myColorFrame-&gt;CopyConvertedFrameDataToArray(colorHeight * colorWidth * 4, original.data, ColorImageFormat_Bgra); Mat copy = original.clone(); //读取彩色图像并输出到矩阵 while (myBodyReader-&gt;AcquireLatestFrame(&amp;myBodyFrame) != S_OK); //读取身体图像 IBody ** myBodyArr = new IBody *[myBodyCount]; //为存身体数据的数组做准备 if (fps != 0) &#123; fps++; fps = fps % 30; delete[]myBodyArr; myBodyFrame-&gt;Release(); myColorFrame-&gt;Release(); continue; &#125; fps++; for (int i = 0; i &lt; myBodyCount; i++) myBodyArr[i] = nullptr; if (myBodyFrame-&gt;GetAndRefreshBodyData(myBodyCount, myBodyArr) == S_OK) //把身体数据输入数组 for (int i = 0; i &lt; myBodyCount; i++) &#123; BOOLEAN result = false; if (myBodyArr[i]-&gt;get_IsTracked(&amp;result) == S_OK &amp;&amp; result) //先判断是否侦测到 &#123; Joint myJointArr[JointType_Count]; if (myBodyArr[i]-&gt;GetJoints(JointType_Count, myJointArr) == S_OK) &#123; draw(copy, myJointArr[JointType_Head], myJointArr[JointType_Neck], myMapper); &#125; &#125; &#125; delete[]myBodyArr; myBodyFrame-&gt;Release(); myColorFrame-&gt;Release(); if (countFrame == 330) &#123; break; &#125; &#125; 5.关闭Kinect并退出 123456789myMapper-&gt;Release();myDescription-&gt;Release();myColorReader-&gt;Release();myColorSource-&gt;Release();myBodyReader-&gt;Release();myBodySource-&gt;Release();mySensor-&gt;Close();mySensor-&gt;Release();return 0; 6.函数draw() ​ 获取时间然后直接输出坐标。 123456789101112131415161718192021void draw(Mat &amp; img, Joint &amp; r_1, Joint &amp; r_2, ICoordinateMapper * myMapper)&#123; countFrame++; if (r_1.TrackingState &#x3D;&#x3D; TrackingState_Tracked ) &#123; now &#x3D; clock(); ofstream fout(&quot;01.txt&quot;, ios::app); cout &lt;&lt; now; cout &lt;&lt; r_1.Position.X &lt;&lt; r_1.Position.Y &lt;&lt; r_1.Position.Z &lt;&lt; &#39;\\t ,&#39;&lt;&lt;countFrame&lt;&lt;endl; fout &lt;&lt; r_1.Position.X&lt;&lt;&#39;,&#39; &lt;&lt; r_1.Position.Y &lt;&lt; &#39;,&#39; &lt;&lt; r_1.Position.Z &lt;&lt;&#39;,&#39;&lt;&lt;now&lt;&lt; endl; fout.close(); &#125; else &#123; now &#x3D; clock(); ofstream fout(&quot;01.txt&quot;, ios::app); cout &lt;&lt; now; cout &lt;&lt; 0 &lt;&lt; 0 &lt;&lt;0 &lt;&lt; endl; fout &lt;&lt; 0 &lt;&lt; &#39;,&#39; &lt;&lt;0 &lt;&lt; &#39;,&#39; &lt;&lt; 0 &lt;&lt; &#39;,&#39; &lt;&lt; now&lt;&lt;endl; fout.close(); &#125;&#125; 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//完整代码//其实本项目并没有用到opencv 我这是copy的别人的代码然后修改了一下。代码有很多和本项目无关的东西，等有时间删除精炼一下#include &lt;iostream&gt;#include &lt;opencv2\\imgproc.hpp&gt; //opencv头文件#include &lt;opencv2\\calib3d.hpp&gt;#include &lt;opencv2\\highgui.hpp&gt;#include &lt;Kinect.h&gt; //Kinect头文件#include&lt;fstream&gt;#include&lt;ctime&gt;using namespace std;using namespace cv;int countFrame = 0;clock_t pre, now;clock_t begintime, endtime;void draw(Mat &amp; img, Joint &amp; r_1, Joint &amp; r_2, ICoordinateMapper * myMapper);int main(void)&#123; begintime = clock(); IKinectSensor * mySensor = nullptr; GetDefaultKinectSensor(&amp;mySensor); mySensor-&gt;Open(); IColorFrameSource * myColorSource = nullptr; mySensor-&gt;get_ColorFrameSource(&amp;myColorSource); IColorFrameReader * myColorReader = nullptr; myColorSource-&gt;OpenReader(&amp;myColorReader); int colorHeight = 0, colorWidth = 0; IFrameDescription * myDescription = nullptr; myColorSource-&gt;get_FrameDescription(&amp;myDescription); myDescription-&gt;get_Height(&amp;colorHeight); myDescription-&gt;get_Width(&amp;colorWidth); IColorFrame * myColorFrame = nullptr; Mat original(colorHeight, colorWidth, CV_8UC4); //**********************以上为ColorFrame的读取前准备************************** IBodyFrameSource * myBodySource = nullptr; mySensor-&gt;get_BodyFrameSource(&amp;myBodySource); IBodyFrameReader * myBodyReader = nullptr; myBodySource-&gt;OpenReader(&amp;myBodyReader); int myBodyCount = 0; myBodySource-&gt;get_BodyCount(&amp;myBodyCount); IBodyFrame * myBodyFrame = nullptr; ICoordinateMapper * myMapper = nullptr; mySensor-&gt;get_CoordinateMapper(&amp;myMapper); int fps = 0; //**********************以上为BodyFrame以及Mapper的准备*********************** while (1) &#123; while (myColorReader-&gt;AcquireLatestFrame(&amp;myColorFrame) != S_OK); myColorFrame-&gt;CopyConvertedFrameDataToArray(colorHeight * colorWidth * 4, original.data, ColorImageFormat_Bgra); Mat copy = original.clone(); //读取彩色图像并输出到矩阵 while (myBodyReader-&gt;AcquireLatestFrame(&amp;myBodyFrame) != S_OK); //读取身体图像 IBody ** myBodyArr = new IBody *[myBodyCount]; //为存身体数据的数组做准备 if (fps != 0) &#123; //cout &lt;&lt; fps &lt;&lt; endl; fps++; fps = fps % 30; delete[]myBodyArr; myBodyFrame-&gt;Release(); myColorFrame-&gt;Release(); continue; &#125; fps++; for (int i = 0; i &lt; myBodyCount; i++) myBodyArr[i] = nullptr; if (myBodyFrame-&gt;GetAndRefreshBodyData(myBodyCount, myBodyArr) == S_OK) //把身体数据输入数组 for (int i = 0; i &lt; myBodyCount; i++) &#123; BOOLEAN result = false; if (myBodyArr[i]-&gt;get_IsTracked(&amp;result) == S_OK &amp;&amp; result) //先判断是否侦测到 &#123; Joint myJointArr[JointType_Count]; if (myBodyArr[i]-&gt;GetJoints(JointType_Count, myJointArr) == S_OK) //如果侦测到就把关节数据输入到数组并画图 &#123; draw(copy, myJointArr[JointType_Head], myJointArr[JointType_Neck], myMapper); &#125; &#125; &#125; delete[]myBodyArr; myBodyFrame-&gt;Release(); myColorFrame-&gt;Release(); if (countFrame == 330) &#123; break; &#125; &#125; myMapper-&gt;Release(); myDescription-&gt;Release(); myColorReader-&gt;Release(); myColorSource-&gt;Release(); myBodyReader-&gt;Release(); myBodySource-&gt;Release(); mySensor-&gt;Close(); mySensor-&gt;Release(); return 0;&#125;void draw(Mat &amp; img, Joint &amp; r_1, Joint &amp; r_2, ICoordinateMapper * myMapper)&#123; countFrame++; if (r_1.TrackingState == TrackingState_Tracked ) &#123; now = clock(); ofstream fout(&quot;01.txt&quot;, ios::app); cout &lt;&lt; now; cout &lt;&lt; r_1.Position.X &lt;&lt; r_1.Position.Y &lt;&lt; r_1.Position.Z &lt;&lt; &#x27;\\t ,&#x27;&lt;&lt;countFrame&lt;&lt;endl; fout &lt;&lt; r_1.Position.X&lt;&lt;&#x27;,&#x27; &lt;&lt; r_1.Position.Y &lt;&lt; &#x27;,&#x27; &lt;&lt; r_1.Position.Z &lt;&lt;&#x27;,&#x27;&lt;&lt;now&lt;&lt; endl; fout.close(); &#125; else &#123; now = clock(); ofstream fout(&quot;01.txt&quot;, ios::app); cout &lt;&lt; now; cout &lt;&lt; 0 &lt;&lt; 0 &lt;&lt;0 &lt;&lt; endl; fout &lt;&lt; 0 &lt;&lt; &#x27;,&#x27; &lt;&lt;0 &lt;&lt; &#x27;,&#x27; &lt;&lt; 0 &lt;&lt; &#x27;,&#x27; &lt;&lt; now&lt;&lt;endl; fout.close(); &#125;&#125;","categories":[],"tags":[{"name":"Kinect","slug":"Kinect","permalink":"http://huajiaohuixiang.github.io/tags/Kinect/"}]},{"title":"hexo使用","slug":"huxo使用","date":"2021-02-19T07:52:56.000Z","updated":"2021-02-19T08:43:36.839Z","comments":true,"path":"2021/02/19/huxo使用/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/19/huxo%E4%BD%BF%E7%94%A8/","excerpt":"","text":"使用Hexo+Github部署参考官方文档：https://hexo.io/docs/ 安装1234cnpm install -g hexo-cli 或者 cnpm install hexo 安装Hexohexo init &lt;foldername&gt; 新建一个Hexo项目cd foldername cnpm install 安装依赖 写博客12hexo new [layout] &lt;title&gt; 新建一个帖子&#x2F;页面&#x2F;草稿 分别对应layout中post&#x2F;page&#x2F;draft title是名字 对于草稿写完后还需要 hexo publish [layout] &lt;title&gt;&#x2F;&#x2F;创建post时可以根据scaffolds中的模板进行创建 命令为 hexo new &lt;模板名字&gt; &lt;post名字&gt; 例如scaffolds中有一个a.md 以它为模板的命令为 hexo new a “hi” 部署在github上首先在github上创建huajiaohuixiang.github.io的Repo然后在本地hexo下 123456git initgit branch -M maingit remote add origin https:&#x2F;&#x2F;github.com&#x2F;huajiaohuixiang&#x2F;huajiaohuixiang.github.io.gitgit add .git commit -m &quot;first commit&quot;git push origin -u origin main 第一次需要-u origin commit 然后安装hexo-deployer 123456cnpm install hexo-deployer-git --save修改 _config.yml 将deploy修改成下面（huajiaohuixiang应该改成你的repo名字）deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;huajiaohuixiang&#x2F;huajiaohuixiang.github.io branch: main 然后 12hexo clean hexo deploy 打开https://huajioahuixiang.github.io即可本人第一次hexo deploy的时候报错 1234567FATAL &#123; err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (Y:\\个人博客\\hexo\\node_modules\\_hexo-util@2.4.0@hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (events.js:315:20) at ChildProcess.cp.emit (Y:\\个人博客\\hexo\\node_modules\\_cross-spawn@7.0.3@cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123; &#125; 在deploy一次就好了 可能有用的文章：https://1187100546.github.io/2019/11/24/spawn-failed/https://perry96.com/archives/882898e3.html 这个是回退本地git版本 回退了就好了，很奇怪","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://huajiaohuixiang.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Java-@HotSpotIntrinsicCandidate","slug":"@HotSpotIntrinsicCandidate","date":"2021-02-19T06:13:38.000Z","updated":"2021-02-19T14:11:57.124Z","comments":true,"path":"2021/02/19/@HotSpotIntrinsicCandidate/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/19/@HotSpotIntrinsicCandidate/","excerpt":"","text":"@HotSpotIntrinsicCandidate看源码的时候看到了很多这种注释 ， JDK的Object类源码中，被@HotSpotIntrinsicCandidate标注的方法，在HotSpot中都有一套高效的实现，该高效实现基于CPU指令，运行时，HotSpot维护的高效实现会替代JDK的源码实现，从而获得更高的效率。参考https://blog.csdn.net/javaer_lee/article/details/87161952 下面的源码对其的解释 The {@code @HotSpotIntrinsicCandidate} annotation is specific to the HotSpot Virtual Machine. It indicates that an annotated method may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method is intrinsified if the HotSpot VM replaces the annotated method with hand-written assembly and/or hand-written compiler IR – a compiler intrinsic – to improve performance. The {@code @HotSpotIntrinsicCandidate} annotation is internal to the Java libraries and is therefore not supposed to have any relevance for application code. Maintainers of the Java libraries must consider the following when modifying methods annotated with {@code @HotSpotIntrinsicCandidate}. When modifying a method annotated with {@code @HotSpotIntrinsicCandidate}, the corresponding intrinsic code in the HotSpot VM implementation must be updated to match the semantics of the annotated method. For some annotated methods, the corresponding intrinsic may omit some low-level * checks that would be performed as a matter of course if the intrinsic is implemented * using Java bytecodes. This is because individual Java bytecodes implicitly check * for exceptions like {@code NullPointerException} and {@code ArrayStoreException}. * If such a method is replaced by an intrinsic coded in assembly language, any * checks performed as a matter of normal bytecode operation must be performed * before entry into the assembly code. These checks must be performed, as * appropriate, on all arguments to the intrinsic, and on other values (if any) obtained * by the intrinsic through those arguments. The checks may be deduced by inspecting * the non-intrinsic Java code for the method, and determining exactly which exceptions * may be thrown by the code, including undeclared implicit {@code RuntimeException}s. * Therefore, depending on the data accesses performed by the intrinsic, * the checks may include: null checks on references range checks on primitive values used as array indexes other validity checks on primitive values (e.g., for divide-by-zero conditions) store checks on reference values stored into arrays array length checks on arrays indexed from within the intrinsic reference casts (when formal parameters are {@code Object} or some other weak type) Note that the receiver value ({@code this}) is passed as a extra argument * to all non-static methods. If a non-static method is an intrinsic, the receiver * value does not need a null check, but (as stated above) any values loaded by the * intrinsic from object fields must also be checked. As a matter of clarity, it is * better to make intrinisics be static methods, to make the dependency on {@code this} * clear. Also, it is better to explicitly load all required values from object * fields before entering the intrinsic code, and pass those values as explicit arguments. * First, this may be necessary for null checks (or other checks). Second, if the * intrinsic reloads the values from fields and operates on those without checks, * race conditions may be able to introduce unchecked invalid values into the intrinsic. * If the intrinsic needs to store a value back to an object field, that value should be * returned explicitly from the intrinsic; if there are multiple return values, coders * should consider buffering them in an array. Removing field access from intrinsics * not only clarifies the interface with between the JVM and JDK; it also helps decouple * the HotSpot and JDK implementations, since if JDK code before and after the intrinsic * manages all field accesses, then intrinsics can be coded to be agnostic of object * layouts. * * Maintainers of the HotSpot VM must consider the following when modifying intrinsics. * * When adding a new intrinsic, make sure that the corresponding method * in the Java libraries is annotated with {@code @HotSpotIntrinsicCandidate} * and that all possible call sequences that result in calling the intrinsic contain * the checks omitted by the intrinsic (if any). When modifying an existing intrinsic, the Java libraries must be updated * to match the semantics of the intrinsic and to execute all checks omitted * by the intrinsic (if any). Persons not directly involved with maintaining the Java libraries or the * HotSpot VM can safely ignore the fact that a method is annotated with * {@code @HotSpotIntrinsicCandidate}. * * The HotSpot VM defines (internally) a list of intrinsics. Not all intrinsic * are available on all platforms supported by the HotSpot VM. Furthermore, * the availability of an intrinsic on a given platform depends on the * configuration of the HotSpot VM (e.g., the set of VM flags enabled). * Therefore, annotating a method with {@code @HotSpotIntrinsicCandidate} does * not guarantee that the marked method is intrinsified by the HotSpot VM. * * If the {@code CheckIntrinsics} VM flag is enabled, the HotSpot VM checks * (when loading a class) that (1) all methods of that class that are also on * the VM’s list of intrinsics are annotated with {@code @HotSpotIntrinsicCandidate} * and that (2) for all methods of that class annotated with * {@code @HotSpotIntrinsicCandidate} there is an intrinsic in the list.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-Object","slug":"Object","date":"2021-02-19T06:13:38.000Z","updated":"2021-02-19T14:07:19.982Z","comments":true,"path":"2021/02/19/Object/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/19/Object/","excerpt":"","text":"12Class &#123;@code Object&#125; is the root of the class hierarchy. Every class has &#123;@code Object&#125; as a superclass. All objects, including arrays, implement the methods of this class.类Object是类层次结构的根。 每个类都把Object作为父类。 所有对象，包括数组，实现该类的方法。 源码介绍如上。 1.hashcode()12@HotSpotIntrinsicCandidatepublic native int hashCode(); native修饰的方法，不由java实现，hashcode()方法就是将该对象再内存中的位置转换为整数然后返回，所有的对象由JVM管理。 2.equals()123public boolean equals(Object obj) &#123; return (this == obj);&#125; ==即判断两者的内存地址是否相同。 对于String来说，其重写了equals()函数，先判断内存地址然后再判断内容。 需要注意的是必须保证如果两者的hashcode()相同那么equals()为true。即重写的话也要先判断内存地址是否相同，然后对于不同的情况再判断其他的。 建议但不强制对于不相等的对象的hashCode一定要不同。 3.clone()方法12345678910111213141516/* * The method &#123;@code clone&#125; for class &#123;@code Object&#125; performs a * specific cloning operation. First, if the class of this object does * not implement the interface &#123;@code Cloneable&#125;, then a * &#123;@code CloneNotSupportedException&#125; is thrown. Note that all arrays * are considered to implement the interface &#123;@code Cloneable&#125; and that * the return type of the &#123;@code clone&#125; method of an array type &#123;@code T[]&#125; * is &#123;@code T[]&#125; where T is any reference or primitive type. * Otherwise, this method creates a new instance of the class of this * object and initializes all its fields with exactly the contents of * the corresponding fields of this object, as if by assignment; the * contents of the fields are not themselves cloned. Thus, this method * performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation. */@HotSpotIntrinsicCandidateprotected native Object clone() throws CloneNotSupportedException; 只包含了部分注释，这一部分注释解释了该函数的内容： 如果该类没有实现Cloneable接口，会抛出CloneNotSupportedException异常。 如果实现了Cloneable接口，那么该方法将会创建该类的新实例，并且初始化所有字段，字段的内容本身不是克隆的。 从而，这种方法执行此对象的“浅拷贝”，而不是“深拷贝”操作 4.toString()1234//It is recommended that all subclasses override this method.public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 返回类名+@+哈希值（内存地址转换而成） 5.wait(), notify(), notifyAll()java的线程同步函数 12345678910111213141516171819202122232425@HotSpotIntrinsicCandidatepublic final native void notify();@HotSpotIntrinsicCandidatepublic final native void notifyAll();public final void wait() throws InterruptedException &#123; wait(0L);&#125;public final native void wait(long timeoutMillis) throws InterruptedException;public final void wait(long timeoutMillis, int nanos) throws InterruptedException &#123; if (timeoutMillis &lt; 0) &#123; throw new IllegalArgumentException(&quot;timeoutMillis value is negative&quot;); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( &quot;nanosecond timeout value out of range&quot;); &#125; if (nanos &gt; 0) &#123; timeoutMillis++; &#125; wait(timeoutMillis);&#125; 6.finalize()函数12@Deprecated(since&#x3D;&quot;9&quot;)protected void finalize() throws Throwable &#123; &#125; finalize()方法就是再JVM确定已经没有任何线程可以访问该对象，那么将会清空该内存区域，如果其他类又使用了该类将会报异常。抛出的是Throwable，说明除了常规的异常Exceprion外，还有可能是JVM错误。当一个对象在回收前想要执行一些操作，就要覆写Object类中的finalize( )方法。 @Deprecated(since=”9”)表示自从JDK9已废除该方法","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-String","slug":"String","date":"2021-02-19T06:13:38.000Z","updated":"2021-02-19T11:50:36.287Z","comments":true,"path":"2021/02/19/String/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/19/String/","excerpt":"","text":"关于字符串 推荐阅读源码，或者https://blog.csdn.net/zhxdick/article/details/80803507 以下是几个String的问题，总结一下。 String 被final修饰 不能被继承final的作用： ​ 修饰变量 表示变量只能一次赋值以后值不能被修改 ​ 如果是修饰了一个基本类型数据，就表示一个常量 ​ 如果是引用类型数据，则引用初始化后将永远指向一个内存地址（就相当于一个不能变的指针） ​ 但是该引用对象中的内容是可以变的 ​ 修饰方法 该方法不能被重写，但可以继承 ​ 修饰类 该类不能被继承 final修饰变量的本质: final修饰的变量会指向一块固定的内存, 这块内存中的值不能改变. 参考https://blog.csdn.net/qq_24309787/article/details/100942044 那为何String要被修饰成final？ 为了实现字符串常量池：字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量池中的同一个对象。这样一方面能够节约内存，另一方面也提升了性能。 但是仅有一个final不能保证字符串常量，原因在上面final作用第一条已说明。我们看String源码 123456789101112131415public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; //String类被final修饰了，表明其不可被继承。 //实现了 Serializable接口---&gt;使其可以序列化，方便数据的传输 //实现了Comparable接口，可以调用Collections.sort() 和 Arrays.sort() 方法排序，并且String类实现 compareTo() 方法。 //实现了CharSequence接口，该接口能表示char值的一个可读序列。几个String兄弟类都实现了此接口。 @Stable private final byte[] value; private final byte coder; private int hash; // Default to 0 ...&#125; 其中的final修饰的byte数组用来存储String内容，然后再加上private修饰，本身也没有提供修改自己value数组的方法，所以value数组不可变，即字符串不可变，生成了字符串常量池。 还有因为其不可变所以String是线程安全的，同一个字符串实例可以被多个线程共享。 因为字符串是不可变的，所以在它创建的时候HashCode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。 ​ 参考https://blog.csdn.net/zhxdick/article/details/80803507 ​ https://www.jianshu.com/p/9c7f5daac283 JDK8 和JDK9 String的变化​ 再JDK8中 String中是用char数组来存储 char是由UTF16编码咱用两个字节，但是很多都只用了一个字节（ASICII），所有再9中对其进行了优化，将char[] 更改为了 byte [] 以及一个coder来存储。 ​ coder一般只有两个值：分别用来表示8位表示还剩16位表示 12static final byte LATIN1 &#x3D; 0; static final byte UTF16 &#x3D; 1; 关于== 和equal()“==”判断的是两个对象的内存地址是否一样，适用于原始数据类型和枚举类型（它们的变量存储的是值本身，而引用类型变量存储的是引用）；equals是Object类的方法，Object对它的实现是比较内存地址，我们可以重写这个方法来自定义“相等”这个概念。比如类库中的String、Date等类就对这个方法进行了重写。综上，对于枚举类型和原始数据类型的相等性比较，应该使用”==”；对于引用类型的相等性比较，应该使用equals方法。 下面是String的equal函数,equal()函数的object的一个函数，String对其进行了重写，首先它判断了两者内存地址是否一样，然后将anObject转换为String比较内容。 12345678910111213public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String aString = (String)anObject; if (coder() == aString.coder()) &#123; return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); &#125; &#125; return false;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-@Native","slug":"native","date":"2021-02-19T06:13:38.000Z","updated":"2021-02-20T03:03:13.065Z","comments":true,"path":"2021/02/19/native/","link":"","permalink":"http://huajiaohuixiang.github.io/2021/02/19/native/","excerpt":"","text":"看Object的源码的时候发现了从未见过的修饰符native，雨伞学习一下。 就是这几个： 123456789101112131415161718192021private static native void registerNatives();public final native Class&lt;?&gt; getClass(); public native int hashCode();@HotSpotIntrinsicCandidatepublic final native void notify();@HotSpotIntrinsicCandidatepublic final native void notifyAll();public final void wait() throws InterruptedException &#123; wait(0L);&#125;public final native void wait(long timeoutMillis) throws InterruptedException;public final void wait(long timeoutMillis, int nanos) throws InterruptedException &#123; ...&#125; 参考博客https://www.cnblogs.com/KingIceMou/p/7239668.html 被native修饰的方法就是不是由java实现的，而是由C或者C++实现，并且编译成了dll，然后由java调用，调用过程如下： 实现步骤 １、在Java中声明native()方法，然后编译； ２、用javah产生一个.h文件； ３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）； ４、将第三步的.cpp文件编译成动态链接库文件； ５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"悲惨世界","slug":"悲惨世界","date":"2020-12-03T16:00:00.000Z","updated":"2021-02-19T06:25:31.753Z","comments":true,"path":"2020/12/04/悲惨世界/","link":"","permalink":"http://huajiaohuixiang.github.io/2020/12/04/%E6%82%B2%E6%83%A8%E4%B8%96%E7%95%8C/","excerpt":"","text":"人有肉体，这对人来说，既是负担优势诱惑。人拖着肉体，又屈从于肉体。 有罪的人并不是犯罪的人，而是制造黑暗的人。 最好看的祭坛，是不幸者因得到了安慰而感谢上帝的一颗心灵 我在这世上不是守护自己的生命，而是守护灵魂。 p34-44","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://huajiaohuixiang.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"SpringBoot 学习","slug":"SpringBoot","date":"2020-11-19T16:00:00.000Z","updated":"2021-02-19T06:25:06.371Z","comments":true,"path":"2020/11/20/SpringBoot/","link":"","permalink":"http://huajiaohuixiang.github.io/2020/11/20/SpringBoot/","excerpt":"","text":"依赖：spring-boot-plugin 可以将应用打包成一个jar包 @SpringBootApplication 注解可以用来标注主程序 其实是一个组合注解 @SpringBootConfiguration、@EnableAutoConfiguration等等 @Reponse Body 返回主体 @Controller 控制器 ​ 这俩合成一个@RestController 4.跨域的话+@CrossOrigin 5.YAML新的配置文件类型。k： v格式 冒号后面要有空格 6.@ConfigurationProperties(prefix=” “)来标识一个配置类，松散绑定 @Value() 也可以只不过是标识一个变量，不支持松散绑定","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://huajiaohuixiang.github.io/tags/SpringBoot/"}]},{"title":"Linux/Windows系统命令","slug":"Linux Window命令","date":"2020-11-15T16:00:00.000Z","updated":"2021-02-19T14:15:08.475Z","comments":true,"path":"2020/11/16/Linux Window命令/","link":"","permalink":"http://huajiaohuixiang.github.io/2020/11/16/Linux%20Window%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1.Putty 传送文件到服务器：​ 打开putty目录：命令行运行 psftp​ put -r foldername 上传文件夹 2.Linux获取应用程序位置1dpkg -S softwarename 显示包含此软件包的所有位置， 1dpkg -L softwarename 显示安装路径。 3.开启关闭HypeV 管理员打开命令行 123bcdedit &#x2F;set hypervisorlaunchtype off bcdedit &#x2F;set hypervisorlaunchtype Auto 4.Linux 命令1234567netstat -ntlp 查看端口使用情况ps ux 查看nohup进程jobs 未退出过终端 查看nohup进程kill -9 id","categories":[],"tags":[{"name":"杂类","slug":"杂类","permalink":"http://huajiaohuixiang.github.io/tags/%E6%9D%82%E7%B1%BB/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huajiaohuixiang.github.io/tags/Java/"},{"name":"Kinect","slug":"Kinect","permalink":"http://huajiaohuixiang.github.io/tags/Kinect/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://huajiaohuixiang.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://huajiaohuixiang.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://huajiaohuixiang.github.io/tags/SpringBoot/"},{"name":"杂类","slug":"杂类","permalink":"http://huajiaohuixiang.github.io/tags/%E6%9D%82%E7%B1%BB/"}]}