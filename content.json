{"meta":{"title":"花椒茴香的个人博客","subtitle":"安得广厦千万间","description":"","author":"huajiaohuixiang","url":"https://huajiaohuixiang.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-02-22T03:22:42.000Z","updated":"2021-02-26T03:09:47.409Z","comments":false,"path":"categories/index.html","permalink":"https://huajiaohuixiang.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2021-02-22T03:23:18.000Z","updated":"2021-02-22T03:23:30.326Z","comments":true,"path":"search/index.html","permalink":"https://huajiaohuixiang.github.io/search/index.html","excerpt":"","text":""},{"title":"links","date":"2021-02-26T05:46:39.000Z","updated":"2021-02-26T05:46:39.842Z","comments":true,"path":"links/index-1.html","permalink":"https://huajiaohuixiang.github.io/links/index-1.html","excerpt":"","text":""},{"title":"links","date":"2021-02-26T05:39:03.000Z","updated":"2021-02-26T05:39:42.128Z","comments":true,"path":"links/index.html","permalink":"https://huajiaohuixiang.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-22T03:16:17.000Z","updated":"2021-02-26T05:56:57.421Z","comments":false,"path":"tags/index.html","permalink":"https://huajiaohuixiang.github.io/tags/index.html","excerpt":"","text":""},{"title":"timeline","date":"2021-02-26T06:00:56.000Z","updated":"2021-02-26T06:00:56.865Z","comments":true,"path":"timeline/index-1.html","permalink":"https://huajiaohuixiang.github.io/timeline/index-1.html","excerpt":"","text":""},{"title":"timeline","date":"2021-02-26T05:57:40.000Z","updated":"2021-02-26T05:57:58.474Z","comments":true,"path":"timeline/index.html","permalink":"https://huajiaohuixiang.github.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2021-05-12T17:07:18.000Z","updated":"2021-05-12T17:07:54.427Z","comments":true,"path":"2021/05/13/test/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/05/13/test/","excerpt":"","text":"111 222 333 444 555 666 777","categories":[],"tags":[]},{"title":"使用frp进行内网穿透","slug":"使用frp进行内网穿透","date":"2021-05-12T16:19:39.000Z","updated":"2021-05-12T17:04:53.302Z","comments":true,"path":"2021/05/13/使用frp进行内网穿透/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/05/13/%E4%BD%BF%E7%94%A8frp%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"之前使用花生壳来进行内网穿透，只能穿透一个，相当于没有，然后发现了frp这个神仙项目。 frp可以通过一个有公网IP的服务器来进行转发，服务器启动frps，内网机器启动frps，然后就可以访问内网机器啦。 搭建过程 硬件条件 Jetson Nano B01 ，阿里云服务器一台，域名一个。 下载frp 首先下载frp项目，https://github.com/fatedier/frp/releases，阿里云服务器应该是要下载frp_0.36.2_linux_amd64.tar.gz，然后解压。Jetson nano需要下载frp_0.36.2_linux_arm.tar.gz，然后解压。 观察frp配置文件 里面一共有一个systemd文件夹和frpc、frpc.ini、frpc_full.ini、frps、frps.ini、frps_full.ini。systemd先不用管，后面才会用到。 其中frpc和frps是两个启动程序。其余四个ini分别是启动程序的简单配置例子和详细配置例子。 实现ssh 如果要实现ssh ，服务器和内网机器分别要进行以下配置。 服务器需要配置frps.ini文件，其实不用变哈哈，本来就是这样。 12[common]bind_port = 7000 然后内网机器需要进行一哈配置frpc.ini 12345678910111213141516171819[common]#这个是服务器的公网IP地址server_addr = 127.0.0.1#这个是服务器的监听端口，需要和服务器配置文件中的bind_port相同server_port = 7000#下面的ssh配置[ssh]#类型是tcptype = tcp#本地ip地址，可以是192.168.1.xxx这种，如果是127.0.0.1就是本机local_ip = 127.0.0.1、#本地端口local_port = 22#服务器端口，我们连接的时候连接服务器的6000端口就好了remote_port = 6000 实现http 服务器的frps.ini配置 12345[common]bind_port = 7000#表示用10000来监听httpvhost_http_port = 10000 本地的frpc.ini配置 12345678910111213[common]server_addr = x.x.x.x server_port = 7000[web]type = httplocal_port = 10000custom_domains = 你的域名1或者ip地址[web2]type = httplocal_port = 100001custom_domains = 你的域名2或者ip地址 因为每个web中的custom_domains都必须不同，如果直接写服务器的公网ip的话，只能实现一个http的转发，如果你有域名的话，是可以创建很多子域名，因此可以实现很多http转发。只需要在本地机器的frpc.ini中增加local_port和custon_domains即可。 将其注册成服务 我是看着这个教程做的https://blog.csdn.net/fjh1997/article/details/103672631，但是文中应该是有一个错误，“我们把下载好的所有*.ini文件放到/etc/frpc/目录下”，因为frpc@.service中的路径是 /etc/frp 所以应该放在 /etc/frp下。如果放在了frpc下需要改一下service中的路径。 还记得之前的systemd文件夹吗，那个就是注册成服务用的。 cd systemd进入文件夹 ls 一共有四个文件 frpc.service 和 frpc@.service还有frps的，带@和不带@的区别就是带@可以在启动服务的时候指定配置文件，不带@的只能使用文件中固定的配置文件 下面是frpc@.service的内容 1234567891011121314[Unit]Description=Frp Client ServiceAfter=network.target[Service]Type=idleUser=nobodyRestart=on-failureRestartSec=5sExecStart=/usr/bin/frpc -c /etc/frp/%i.ini #重点ExecReload=/usr/bin/frpc reload -c /etc/frp/%i.ini #重点[Install]WantedBy=multi-user.target 比较重要的就是这两个 12ExecStart=/usr/bin/frpc -c /etc/frp/%i.ini #这两个分别是frpc的路径和 frpc.ini的路径，其中frpc.ini通过%i实现了实时替换 所以我们重点就是将 frpc 移动到 /usr/bin/下 ， 将 frpc.ini移动带 /etc/frp/下 ， 将frpc@.service移动到/etc/systemd/system/下。 然后通过 1234systemctl enable frpc@frpc #这步用来注册服务 第一个frpc表示在/etc/systemd/system/下的frpc@.service，第二个frpc表示配置文件的前缀systemctl start frpc@frpc #这步用来启动服务 通过x@x来表示 systemctl restart frpc@test #如果我想更改配置，那么可以在/etc/frp/下创建test.ini，然后通过这个重新启动。 对于frps也一样哦，移动三个文件，然后注册服务、启动，大功告成啦。","categories":[],"tags":[{"name":"frp","slug":"frp","permalink":"https://huajiaohuixiang.github.io/tags/frp/"},{"name":"服务器搭建","slug":"服务器搭建","permalink":"https://huajiaohuixiang.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"}]},{"title":"Java锁和并发","slug":"Java锁和并发","date":"2021-05-12T03:33:35.000Z","updated":"2021-05-12T03:33:59.234Z","comments":true,"path":"2021/05/12/Java锁和并发/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/05/12/Java%E9%94%81%E5%92%8C%E5%B9%B6%E5%8F%91/","excerpt":"","text":"SynchronizedSynchronized实现原理通过加锁来实现同步，在编译之后，通过在代码块前后加monitor enter和exit来实现； 分别修饰代码块、修饰方法、修饰静态方法，加锁的对象。 每个对象都是由对象头、对象实际数据、填充组成的。 对象头中的MarkWord会记录锁的信息，对于不同的锁格式不相同。 如果是重量级锁的话，存储了指向重量级锁的指针。偏向锁就是存储了线程ID等信息。 轻量级锁指向线程中markword副本。 Synchronized如何实现可重入每个锁对象内部维护一个计数器，该计数器初始值为0，表示任何线程都可以获取该锁并执行相应的方法。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。 ReentrantLock如何实现可重入 ReentrantLock在内部使用了内部类Sync来管理锁，所以真正的获取锁是由Sync的实现类控制的。Sync有两个实现，分别为NonfairSync（非公平锁）和FairSync（公平锁）。Sync通过继承AQS实现，在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作带来效率问题。3个状态：没占用是0，占用了是1，大于1是可重入锁 AQShttps://javadoop.com/post/AbstractQueuedSynchronizer synchronized 和 Lock 有什么区别？synchronized 和 ReentrantLock 区别是什么？synchronized锁升级的原理？在无锁状态下markword中偏向标志为0，如果这时有线程请求锁并且设置了可以是偏向锁就将偏向标志设为1 .线程ID设置为当前线程。如果这时候另外一个线程请求锁，锁就会升级为轻量级锁，markword中放着指向线程栈中markword副本的指针，这时候会自旋。如果自旋的线程过多就会升级为重量级锁。 四种引用强引用： 软引用：SoftReference 弱引用：WeakReference 虚引用： 哪里使用了弱引用？ThreadLocal ThreadLocal通过ThreadLocal来存储当前线程需要存储变量的一个副本。但实际上ThreadLocal是把这个（它自己，变量）存在了Thread的ThreadLocaMap中，然后通过该ThreadLocal取取值。 每一个Thread中都有一个ThreadLocalMap，ThreadLocalMap是ThreadLOcal的内部类，ThreadLocalMap里由一个Entry数组实现。 一个Thread,通过ThreadLocal对象来保存一个值，每个ThreadLocal是键，对应着一个值。如果要保存两个变量就需要两个threadlocal。 ThreadLocal为什么会造成内存泄漏?因为ThreadLocalMap是在Thread中，ThreadLocalMap中某个V的K指向了ThreadLocal对象，但这个对象是弱引用WeakReference，如果该对象的没有其他强引用之后该对象将被回收。此时Thread将无法获得该V，但是它永远都在Thread的ThreadLocalMap的Entry数组中。 ThreadLocal正确的使用方法 每次使用完ThreadLocal都调用它的remove()方法清除数据 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。 锁死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现 悲观锁当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。 悲观锁的实现，往往依靠数据库提供的锁机制。Synchronized java；数据库的页锁和行锁。 select…for update 会锁住数据 如果用到了索引是 行锁；没用到索引是表锁。 乐观锁乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。CAS+MVCC Java中AtomicInteger等 CAS操作中包括三个操作数：内存中的值，期望的值，修改后的值。每次提交修改后的值要检查期望值于内存中的值是否相同，不相同会失败；相同则成功。 https://www.cnblogs.com/kyoner/p/11318979.html 锁优化如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行 效率。 自旋锁互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢 复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。所以如果处理器有两个以上的核心九合一让后面请求锁的线程多等一会而不是加入阻塞队列然后挂起。多等一会就是通过自旋（忙循环）来实现。 但是自旋锁会占用处理器时间，所以需要设定一个自旋次数，默认十次，超过后就挂起。 适应性自旋自旋的时间不是固定的，是由前一次在同一个锁上的自选时间以及锁的拥有者的状态来确定的。 锁消除一些代码要求了同步，但是检测不到存在的数据竞争，就可以将这个锁来消除，主要是通过逃逸分析的数据支持来判断。 锁粗化如果一系列的操作对同一个对象进行反复加锁和解锁，甚至在循环体中，那么锁的范围会扩展到整个操作序列的外部。 轻量级锁 MarkWord一共32位，在不同的锁状态下有不同的结构 未锁定和可偏向差不多 标志位都为01 偏向模式不同 可偏向下有一个线程ID指向偏向的线程 轻量级锁下30位用来存储指向调用栈中锁记录的指针。每个线程在竞争锁的时候都会在本地栈帧放一下对象头，然后CAS尝试修改对象的对象头，如果失败就看一下对象的对象头是否指向自己。 持有偏向锁的线程访问这个对象不会存在任何同步操作，如果访问的线程不是该偏向锁ID中的线程，那么偏向锁模式会升级为轻量锁 重量级锁下30 位指向重量级锁的指针。 CAShttps://blog.csdn.net/weixin_42636552/article/details/82383272 JUCAQSAbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制 如果当前请求的资源空闲，将当前请求的线程设置为有效的工作线程，那么将其设置为锁定状态（通过CAS修改状态）。如果请求的线程不空闲，那么通过CLH队列锁实现线程的阻塞以及唤醒。 AQS 定义了两种资源共享方式：1.Exclusive：独占，只有一个线程能执行，如ReentrantLock2.Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier https://blog.csdn.net/TZ845195485/article/details/109210263 https://blog.csdn.net/mulinsen77/article/details/84583716CountDownLatch线程控制 CyclicBarrier可重置的线程控制 Semaphore信号量来模拟资源 Phaser阶段性的控制 BlockingQueue","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"锁","slug":"锁","permalink":"https://huajiaohuixiang.github.io/tags/%E9%94%81/"}]},{"title":"操作系统","slug":"操作系统","date":"2021-05-12T03:32:29.000Z","updated":"2021-05-12T03:33:00.920Z","comments":true,"path":"2021/05/12/操作系统/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"Cmalloc 动态内存分配malloc的全称是memory allocation，中文名为动态内存分配，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址 callocclear allocation，中文名为动态内存分配并清零如果分配成功则返回指向被分配内存的指针**(此空间中的初始值为0)**，否则返回空指针NULL realloc动态内存调整 先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域(原来的指针会自动释放，不需要再使用free)，同时返回新分配的内存区域的首地址。重新分配成功返回指向被分配内存的指针，否则返回空指针NULL。 free使用malloc,calloc,realloc函数进行内存分配后要使用free(起始地址的指针) 对内存进行释放 在C++中是new delete 进程管理进程切换 进程切换 上图展示了进程切换中几个最重要的步骤： 当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。 操作系统内核负责保存进程 i 在 CPU 中的上下文（程序计数器， 寄存器）到 PCBi （操作系统分配给进程的一个内存块）中。 从 PCBj 取出进程 j 的CPU 上下文， 将 CPU 控制权转移给进程 j ， 开始执行进程 j 的指令。 孤儿进程和僵尸进程的区别？https://www.cnblogs.com/Anker/p/3271773.html 子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。 孤儿进程：父进程执行完或被终止，但是它仍在运行。孤儿进程将会被init进行进程号为1的进程收集。 僵尸进程：是指执行完成后，但是在进程控制块PCB中仍然还有一个表项。一般是由一个进程fork创建子进程，如果子进程退出，但是父进程没有调用wait或waitpid获取子进程的信息，那么子进程的进程描述符仍然在PCB中，这种进程称为姜丝进程。 每个进程再exit()之后都会成为僵尸进程，但是父进程调用wait后便可以删除PCB中的信息。 僵尸进程危害？孤儿进程会被init进程收集，不会产生危害。 僵尸进程：但是如果父进程没有调用wait或者waitpid来获取子进程结束的信息，那么PCB中的信息将不会被释放，进程号一直被占用。 如何解决？（1）通过信号，子进程结束的时候向父进程发送一个信号，在信号处理函数中调用wait进行处理僵尸进程。 （2）fork两次原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。 守护进程守护进程是一个在后台运行并且不受任何终端控制的进程。 如何创建守护进程？(1)创建子进程，终止父进程 由于守护进程是脱离控制终端的，因此首先创建子进程，终止父进程，使得程序在shell终端里造成一个已经运行完毕的假象。之后所有的工作都在子进程中完成，而用户在shell终端里则可以执行其他的命令，从而使得程序以僵尸进程形式运行，在形式上做到了与控制终端的脱离。 (2)在子进程中创建新会话 这个步骤是创建守护进程中最重要的一步，在这里使用的是系统函数setsid。 setsid函数用于创建一个新的会话，并担任该会话组的组长。调用setsid仃三个作用：让进程摆脱原会话的控制、让进程摆脱原进程组的控制和让进程摆脱原控制终端的控制。 在调用fork函数时，子进程全盘拷贝父进程的会话期(session，是一个或多个进程组的集合)、进程组、控制终端等，虽然父进程退出了，但原先的会话期、进程组、控制终端等并没有改变，因此，那还不是真正意义上使两者独立开来。setsid函数能够使进程完全独立出来，从而脱离所有其他进程的控制。 (3)改变工作目录 使用fork创建的子进程也继承了父进程的当前工作目录。由于在进程运行过程中，当前目录所在的文件系统不能卸载，因此，把当前工作目录换成其他的路径，如“/”或“/tmp”等。改变工作目录的常见函数是chdir。 (4)重设文件创建掩码 文件创建掩码是指屏蔽掉文件创建时的对应位。由于使用fork函数新建的子进程继承了父进程的文件创建掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件创建掩码设置为0，可以大大增强该守护进程的灵活性。设置文件创建掩码的函数是umask，通常的使用方法为umask(0)。 (5)关闭[文件描述符] 用fork新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，可能导致所在的文件系统无法卸载 syslogd 进程间通信的7种方式第一类：传统的Unix通信机制 管道/匿名管道(pipe) 管道的实质：管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。 有名管道(FIFO) 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 信号(Signal) ​ 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 消息(Message)队列 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存(share memory) 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 信号量(semaphore) 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 套接字(socket) 可用于不同机器间的进程通信。 linux底层是怎么创建线程的https://blog.csdn.net/melody157398/article/details/104912317 0号进程是什么东西Linux中的0号进程和1号进程 系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。整个linux系统的所有进程也是一个树形结 构。树根是系统自动构造的，即在内核态下执行的0号进程，它是所有进程的祖先。由0号进程创建1号进程（内核态），1号负责执行内核的部分初始化工作及进 行系统配置，并创建若干个用于高速缓存和虚拟主存管理的内核线程。随后，1号进程调用execve（）运行可执行程序init，并演变成用户态1号进程， 即init进程。它按照配置文件/etc/initab的要求，完成系统启动工作，创建编号为1号、2号…的若干终端注册进程getty 进程调度的几种方式 先来先服务 有利于长作业，不利于短作业 ​ 最短作业优先 短作业先行，长作业有可能长时间无法执行 短作业优先 带有优先级的 抢占式和非抢占式， 每个进行都有一个优先级，系统会先给优先级高的分配，对于抢占式的，如果当前进程正在执行，然后来了一个优先级高的，当前进程就阻塞，先给优先级高的执行；非抢占的就是先执行完当前这个在给优先级高的执行 最短作业优先 ​ 时间片轮转 ​ 每个进程都执行一段时间 按FCFS排队，比较重要的是如何确定时间片长度； 优先级队列 多级队列 将上面的算法都结合到了一起 ​ 有很多优先级不同的队列，每个优先级执行的时间片长度也不同，优先级越低，时间片越长。当一个进程到来时，先进入第一队列，如果在当前时间段没有运行完，则进入第二队列，然后依次往下。。。当且仅当高优先级处理完后才处理低优先级的队列。 https://www.cnblogs.com/Blog-day/p/My_Blog_Days1-11.html 操作系统的吧，进程、线程和协程分别是什么以及他们之间的关系（自己整理一下答案，到时候就会说了） 32、64位系统有什么区别32位和64位表示CPU一次能处理的最大位数 32位系统的最大寻址空间是2的32次方=4294967296（bit）= 4（GB）左右； 64位系统的最大寻址空间为2的64次方=4294967296（bit）的32次方，数值大于1亿GB 内存管理什么是虚拟内存？虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。 内存分配方式页式、段式、段页式 段页式系统访存次数3次 段表-&gt;页地址-&gt;页表-&gt;地址 -&gt;访问 为了访存的次数不这么多，在地址变换机构中增设一个高速缓冲寄存器，从中得到相应页的物理块号。 页面置换算法OPT最佳，因为不可能向后预知，无法实现 LRU 最近最少未使用 FIFO先进先出 LFU最不长使用算法 死锁死锁，发生的条件以及如何避免？1**）互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 2**）请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 3**）不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 4**）环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 如何避免？通过哲学家就餐问题分析 杀掉一个进程 -9 代表什么（强制） 还有什么其他参数 、 使用kill命令后，操作系统是如何通知进程的虚拟内存，虚地址实地址磁盘调度磁盘调度算法FIFO 最短寻道时间优先 电梯算法 其余系统调用是什么系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。 操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。 危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。 两个进程如何访问临界区？1.一个turn 标志哪一个进入 （问题：只能ABABABAB的形式） 2.设置flag[2] flag[0]表示A flag[1]表示B能否进入{ 这时候有两种情况 先设置true还是先判断 ​ 先判断有可能两个一起进入 ​ 先设置有可能两个都进不去 ​ } 3.flag[2]+turn ​ 设置flag 设置turn=另外一个 判断 flag&amp;&amp;turn==另外一个 ​ 结束后设置flag 123456//flag[2] turndo&#123; &#125;while(true); BIO同步阻塞IO ：从系统调用开始一直到系统调用结束一直在阻塞。 阻塞时间太久，基本上会为每一个连接IO分配一个线程，不能处理高并发的情况。 NIO同步非阻塞IO： 系统调用开始后一直轮询数据是否准备好，如果准备好了就拷贝数据。 需要大量的轮询操作，占用大量的CPU时间 IO多路复用同步IO多路复用：线程发起select调用后，询问内核数据是否就绪，等内核准备好了以后用户线程在发起read调用。 需要不断select轮询，但是它可以通过一个线程处理成千上万个连接。 使用select的优势在于可以等待多个描述符就绪 信号驱动IO调用后会立即返回，然后再数据准备好的时候会返回一个信号 AIO异步IO： 通过通知回调机制完全不阻塞.对于异步来说，内核是调用的发起方 epoll(基于事件的轮询) 也是Reactor设计模式效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。 Select poll 和epoll的区别？select使用数组 ，有1024的最大连接限制 poll使用链表没有最大连接限制 传统select/poll的另一个致命弱点就是当你拥有一个很大的socket集合，由于网络得延时，使得任一时间只有部分的socket是”活跃” 的，而select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。 epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd。 Select、Poll、Epoll详解https://www.jianshu.com/p/722819425dbd","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://huajiaohuixiang.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"面试","slug":"面试","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"网络","slug":"网络","date":"2021-05-12T03:29:15.000Z","updated":"2021-05-12T03:29:15.452Z","comments":true,"path":"2021/05/12/网络/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/05/12/%E7%BD%91%E7%BB%9C/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"redis","slug":"redis","date":"2021-05-12T03:28:03.000Z","updated":"2021-05-12T03:28:39.480Z","comments":true,"path":"2021/05/12/redis/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/05/12/redis/","excerpt":"","text":"官方文档也针布错http://redis.cn/documentation.html 这个博客针布错https://blog.csdn.net/qq_38261137/article/details/106949963https://thinkwon.blog.csdn.net/article/details/103522351 不能用的命令keys、flushdb、flushall Redis的应用场景总结一 计数器 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 缓存 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 会话缓存 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 全页缓存（FPC） 除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 查找表 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 消息队列(发布/订阅功能) List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。 分布式锁实现 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 其它 Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。 总结二 Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。 数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set 其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。 string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。 hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。 list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。 set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。 Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。 如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。 过期数据的删除策略定时 使用定时器，时间到了就删除过期的key 惰性+定期 每隔一段时间抽取一些key进行检查，然后删除；惰性的话就是用到该key时发现数据过期了就删除该key返回空。 这样的话还是有很多没有删除，这就需要内存淘汰策略。 内存淘汰策略*6 内存不够用时，会删除没有过期的设置过期时间的key*3 最近最少未使用、最快要过期的、随机 所有key*2 随机、最近最少未使用 不淘汰，内存不足新写入的时候报错。 0 引入volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。 手写一下LRU算法实现？继承于LinkedHashMap 通过HashMap实现LinkedHashMap 两种持久化方案RDB AOF RDB 每隔一段时间将数据存储到硬盘上，宕机可能会丢失部分数据；如果数据量很大保存时间过长。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期 AOF 将命令追加到日志记录中，可以选择逐条追加/每秒追加/让操作系统选择 redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。 AOF安全，但是占的空间大，恢复也会比较慢。 redis默认使用RDB，性能最大化，fork子进程来完成写操作，让主进程继续处理命令，IO最大化，保证了Redis的高性能，数据集大的时候AOF启动效率更高。缺点是数据安全性比较低。 AOF数据安全，但是占用空间更大，恢复的时候启动效率低。 什么是事务？事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 Redis事务multi 命令入队 exec Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。 Redis和Memchace的区别redis 支持复杂的数据结构 redis 相比 memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， redis 会是不错的选择。 redis 原生支持集群模式。在 redis3.x 版本中，便能支持 cluster 模式，而 memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。 性能对比。由于 redis 只使用单核，而 memcached 可以使用多核，所以平均每一个核上 redis 在存储小数据时比 memcached 性能更高。而在 100k 以上的数据中，memcached 性能要高于 redis。虽然 redis 最近也在存储大数据的性能上进行优化，但是比起 memcached，还是稍有逊色。 redis 的线程模型redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。 文件事件处理器的结构包含 4 个部分： 多个 socketIO 多路复用程序文件事件分派器事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。 哪里使用了缓存？快递网点的一些统计信息，总包裹数量等；取件消息进入缓存，通常一个人看到取件消息后至少还要再看一次取件； 当前仓库和快递柜的包裹信息。 在抢购优惠券功能上将优惠券剩余量放到了redis中，防止超卖。 缓存和数据库双写一致性问题只能实现最终一致性不能实现强一致性。 首先是通过设置过期时间，在过期时间内缓存的值都可能不是干净的。然后是不设置过期时间的三种更新策略： 先写数据库，在更新缓存（最不好的） 因为是更新缓存，存在并发问题，两个线程写数据库的顺序和删除缓存的顺序不一致会导致错误的缓存一直使用 先删除缓存在更新数据库，B的查询在A的删除缓存之后A的写入数据库之前，同样会出现很久的错误缓存 可以采用延迟双删的策略，写入数据库1s后再次删除缓存 先更新数据库，在删缓存 有很小的几率会产生问题，A读取缓存失效，然后读取数据库，之后卡住了，知道B写入数据库之后，写入缓存之后A再写入缓存导致旧的缓存。 每种方法都有删除缓存失败的情况使用失败重试机制，使用消息队列，将需要删除的key放入MQ中。 就有了通过订阅mysql的binlog来删缓存的操作。只更缓存，不更MySQL，MySQL由缓存异步的更新 使用canal解析binlog Mysql通过binlog同步redis 基于zookeeper临时有序节点可以实现的分布式锁 Redis为什么快 纯内存操作。 核心是基于非阻塞的 IO 多路复用机制。 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题 讲一下IO多路复用 有一个线程监听socket，每来一个事件将其放入到事件队列，然后事件分派器将事件分派到不同的处理器进行处理。 https://blog.csdn.net/mashaokang1314/article/details/88636371 https://www.cnblogs.com/zwt1990/p/8821185.html redis如何保证高可用的哨兵模式 和主从模式 redis主从模式一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点，同时每个从节点也可以是别的从节点的父节点，即主从节点连接形成树结构。 redis主从模式如何复制的？http://kaito-kidd.com/2020/06/30/redis-replication/ 主从结构中数据的复制是单向的，只能由主节点到从节点，所有的内存变更，即数据的增删改都只能在主节点上进行，从节点通过同步的方式完成修改。默认情况下，从节点对非Master节点客户端是只读的。 主从复制分为全量复制和增量复制+命令传播 全量复制就是将主节点生成RDB文件发给从节点，从节点清除内存中的数据并删除之前RDB，然后将接受到的RDB放入内存。（第一次复制） 增量复制：master复制的时候可能会有新的数据产生，master会把数据放入缓冲区，等slave加载RDB完成后再将这些增量数据发送给slave。 命令传播就是每处理完一个命令都会把命令广播给所有的子节点，每个子结点收到广播后会继续广播给子节点，然后各个子结点会执行这个命令 如果主从断开连接，可能会发生全量复制，也可能只是增量复制。在slave第一次全量同步的时候记录了master的runid，然后slave知道自己的offset，这时候只需要把offset发送给master，master会先检查runid是否相同，然后检查offset中的命令是否再缓冲区中，因为缓冲区是有大小的，时间就的就会被删除，如果找得到offset之后的数据就可以只发送这些命令，否则就要进行全量复制。 心跳机制redis哨兵模式单点模式就是一个单机 主从 1个主N个从 主机挂了之后 不能提供服务 哨兵模式 单哨兵和多哨兵 单哨兵是一个哨兵线程不断向redis服务器发送命令等待响应，没有响应表示挂掉，然后从其余的服务器选出一个主服务器；多哨兵是要所有的哨兵都认为该服务器挂掉，然后投票选举。 使用哨兵是，客户端直接连哨兵服务器 【集群模式】多个主从节点，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的内容 并发竞争的问题五个类型 的底层数据结构字符串https://www.cnblogs.com/reecelin/p/13352694.html char数组+len长度+free长度 Simple Dynamic String SDS来存储 123456struct sdsshr&lt;T&gt;&#123; T len;//数组长度 T alloc;//数组容量 unsigned flags;//sdshdr类型 char buf[];//数组内容&#125; int：当存储的字符串全是数字时，此时使用int方式来存储； embstr：当存储的字符串长度小于44个字符时，此时使用embstr方式来存储； raw：当存储的字符串长度大于44个字符时，此时使用raw方式来存储； 链表https://www.cnblogs.com/reecelin/p/13358432.html 通过linkedList、zipList和quickList三种方式实现 分别是双向链表（与Java中的一样）、压缩列表、快表 zipList通过Entry数组实现，每个Entry中存着前一个Entry的长度，编码，内容，节省了linkedList的前后指针。 quickListqucikList是由zipList和双向链表linkedList组成的混合体。 哈希Maphttps://www.cnblogs.com/reecelin/p/13362104.html ziplisthash数组+链表 dictEntry **table 每一个dictentry有key，val ​ rehash hashmap中有两个table 一次使用一个，rehash的时候将一个rehash到另一个上；如果数据量特别大会渐进式哈希，一次弄不完。 压缩列表： 集合https://www.cnblogs.com/reecelin/p/13364089.html intsethashmap有序集合https://www.cnblogs.com/reecelin/p/13368374.html 压缩列表zipList跳表跳表实现，解决了有序链表查询慢的问题，将查询时间降低到logN 将一些点提出来做索引，然后在从这些点中提出来做二级索引。 插入的时候采用随机的方式决定他最多要插到几层。 12while (random(0,1)) K++; hash底层结构https://www.jianshu.com/p/7f53f5e683cf 12345678910111213141516171819202122232425262728293031323334353637//哈希表的table指向的数组存放这dictEntry类型的地址。定义在dict.h/dictEntryt中typedef struct dictEntry &#123;//字典的节点 void *key; union &#123;//使用的联合体 void *val; uint64_t u64;//这两个参数很有用 int64_t s64; &#125; v; struct dictEntry *next;//指向下一个hash节点，用来解决hash键冲突（collision）&#125; dictEntry;//dictType类型保存着 操作字典不同类型key和value的方法 的指针typedef struct dictType &#123; unsigned int (*hashFunction)(const void *key); //计算hash值的函数 void *(*keyDup)(void *privdata, const void *key); //复制key的函数 void *(*valDup)(void *privdata, const void *obj); //复制value的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); //比较key的函数 void (*keyDestructor)(void *privdata, void *key); //销毁key的析构函数 void (*valDestructor)(void *privdata, void *obj); //销毁val的析构函数&#125; dictType;//redis中哈希表定义dict.h/dicthttypedef struct dictht &#123; //哈希表 dictEntry **table; //存放一个数组的地址，数组存放着哈希表节点dictEntry的地址。 unsigned long size; //哈希表table的大小，初始化大小为4 unsigned long sizemask; //用于将哈希值映射到table的位置索引。它的值总是等于(size-1)。 unsigned long used; //记录哈希表已有的节点（键值对）数量。&#125; dictht; //字典结构定义在dict.h/dicttypedef struct dict &#123; dictType *type; //指向dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据。 void *privdata; //私有数据，保存着dictType结构中函数的参数。 dictht ht[2]; //两张哈希表。 long rehashidx; //rehash的标记，rehashidx==-1，表示没在进行rehash int iterators; //正在迭代的迭代器数量&#125; dict; dict内部有两个dicthashtable 平常只有一个有内容，另一个的table为null，在扩容的时候，将一个重新映射到另一个上。 拉链法解决哈希冲突 ，数组中存储的是第二维链表的第一个指针 扩容时机是数组元素个数等于数组大小的时候就会扩容，但如果正在bgsave不会扩容，当entry个数为数组大小的五倍的时候就会强制扩容。而且它的扩容并不是一次完成的，可以渐进式的扩容rehash。 Redis中的Rehash机制https://blog.csdn.net/cqk0100/article/details/80400811 你是如何查询","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"数据库","slug":"数据库","permalink":"https://huajiaohuixiang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"https://huajiaohuixiang.github.io/tags/redis/"}]},{"title":"mysql","slug":"mysql","date":"2021-05-12T03:27:01.000Z","updated":"2021-05-12T03:27:45.718Z","comments":true,"path":"2021/05/12/mysql/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/05/12/mysql/","excerpt":"","text":"阅读这个https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html 事务事务是数据库访问并可能操作数据项的一个操作序列，该序列的操作要么执行要么全部不执行。 mysql中的事务特性[四大特性ACID]: A 原子性一次操作是不可分割的，要么全部成功，要么全部失败。比如我们的转账操作，不允许出款方成功，收款方失败这种情况，要么都成功，要么多失败，不可能出现中间状态。**InnoDB 引擎使用 undo log（归滚日志）来保证原子性操作**，你对数据库的每一条数据的改动（INSERT、DELETE、UPDATE）都会被记录到 undo log 中，执行失败的时候就会回滚。 C一致性 使数据在执行前后处于合法的状态。（通过原子性、隔离性、持久性来实现一致性） I 隔离性 多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离性可能会引入脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）等问题，为了解决这些问题就引入了“隔离级别”的概念。 ​ InnoDB 引擎是如何保证隔离性的？利用锁和 MVCC 机制。这里简单的介绍一下 MVCC 机制，也叫多版本并发控制，在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务下，每条记录在更新的时候都会同时记录一条回滚操作，就会形成一个版本链，在执行普通的 SELECT 操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。 D 持久性 事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。当数据库宕机重启的时候，会将 redo log 中的内容恢复到数据库中，再根据 undo log和 binlog 内容决定回滚数据还是提交数据。 https://yq.aliyun.com/articles/531757 隔离等级以及脏读幻读不可重复读脏读：还没提交就读了，对应读未提交，未提交读 不可重复读：A事务在提交之前，两次读取得到的值不一样，可能是B事务对数据进行了修改（侧重编辑或删除）-对应读已提交 ​ 隔离等级为读已提交的时候会出现不可重复读的问题 幻读：A事务在提交之前，两次读取得到的值不一样，可能是B事务对数据进行了修改（侧重于插入）- ​ 隔离等级为可重复读时会出现幻读问题 该sql第一次读取到数据后。就将这些数据加锁，其他事务无法改动这些数据。就能够实现可反复读了。但这样的方法却无法锁住insert的数据。所以当事务A先前读取了数据，或者改动了所有数据，事务B还是能够insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据。这就是幻读。不能通过行锁来避免。 须要Serializable隔离级别 。读用读锁，写用写锁，读锁和写锁相互排斥，这么做能够有效的避免幻读、不可反复读、脏读等问题，但会极大的减少数据库的并发能力。 MVCC在MySQL的InnoDB中的实现在InnoDB中，会在每行数据后加入两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中。存储的并非时间，而是事务的版本，每开启一个新事务，事务的版本就会递增。 在可重读Repeatable reads事务隔离级别下： SELECT时。读取创建版本&lt;=当前事务版本。删除版本为空或&gt;当前事务版本。 INSERT时，保存当前事务版本为行的创建版本 DELETE时，保存当前事务版本为行的删除版本 UPDATE时，插入一条新纪录。保存当前事务版本为行创建版本，同一时候保存当前事务版本到原来删除的行 通过MVCC，尽管每行记录都须要额外的存储空间，很多其它的行检查工作以及一些额外的维护工作。但能够降低锁的使用，大多数读操作都不用加锁，读数据操作非常easy，性能非常好，而且也能保证仅仅会读取到符合标准的行。也仅仅锁住必要行。 MVCChttps://blog.csdn.net/weixin_34341117/article/details/91425439乐观锁悲观锁的实现https://www.cnblogs.com/kyoner/p/11318979.html 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁。 可重复读的时候，如果Ainsert 但B提前Insert并且提交，则A会报错。 悲观锁是读取的时候为后面的更新加锁，之后再来的读操作都会等待。这种是数据库锁乐观锁优点程序实现，不会存在死锁等问题。他的适用场景也相对乐观。阻止不了除了程序之外的数据库操作。 悲观锁是数据库实现，他阻止一切数据库操作。 序列化的实现方式 间隙锁https://blog.csdn.net/qq_42214953/article/details/106148054当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)” ，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key 锁）。举例来说， 假如 user 表中只有 101 条记录， 其 userid 的值分别是 1,2,…,100,101， 下面的 SQL： Select * from user where userid &gt; 100 for update; 是一个范围条件的检索，InnoDB 不仅会对符合条件的 userid 值为 101 的记录加锁，也会对userid 大于 101（但是这些记录并不存在）的“间隙”加锁，防止其它事务在表的末尾增加数据。 InnoDB 使用间隙锁的目的，为了防止幻读，以满足串行化隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 userid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读。 但是只能解决部分幻读问题 共享锁、排他锁共享锁 select in share mode 是一个行级读锁 并发读，写要加锁 排他锁 select for update 行级写锁 加完锁之后其余事务不能加锁 缓存穿透 空结果缓存 布隆过滤器https://www.cnblogs.com/lazyegg/p/12857374.html BloomFilter 是由一个固定大小的二进制向量或者位图（bitmap）和一系列映射函数组成的。 在初始状态时，对于长度为 m 的位数组，它的所有位都被置为0，如下图所示： 缓存击穿0.热点数据设置为永远不过期 1.后台刷新 后台定义一个job(定时任务)专门主动更新缓存数据. 2.分级缓存 采用 L1 (一级缓存)和 L2(二级缓存) 缓存方式，L1 缓存失效时间短，L2 缓存失效时间长。 请求优先从 L1 缓存获取数据，如果 L1缓存未命中则加锁，只有 1 个线程获取到锁,这个线程再从数据库中读取数据并将数据再更新到到 L1 缓存和 L2 缓存中，而其他线程依旧从 L2 缓存获取数据并返回。 3.多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。 缓存雪崩 大量缓存相同的过期时间4.2.1 事前： 使用集群缓存，保证缓存服务的高可用 这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。 4.2.2 事中： ehcache本地缓存 + Hystrix限流&amp;降级,避免MySQL被打死 使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。 使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。 然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。 4.2.3 事后： 开启Redis持久化机制，尽快恢复缓存集群 一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。 什么时候建立索引？主键 外键需要建立索引 经常join的需要建立索引 数据量比较大的表应该创建索引； 经常在where中的列 聚簇索引和非聚簇的区别聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置 在innodb中，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找。 为什么B+不用B一般来说索引非常大，所以为了减少内存的占用，索引也会被存储在磁盘上。 那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。 另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。(数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）) MySQL的自增ID用完了，会出现什么问题？不会在增加，报错 mysql主从复制原理做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。 1–在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压） 2–在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全） 3–当主服务器出现问题时，可以切换到从服务器。（提升性能） 1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：2.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。 3.从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。 binlog日志的格式？row格式的优点undo log的主要作用是用作事务的回滚和实现mvcc功能，因为mvcc的问题，需要对undolog随机读 redolog用来保证事务的原子性和持久性数据库运行阶段不需要读redolog进行读取。 所有线程公用一份redolog buffer。 在事务执行期间，redolog是记录在redolog buffer中的 binlog 其实是数据库server层的日志，一般用作主从同步和数据恢复，数据格式有statement、row、还有mixed.statement是sql格式的，row记录了行的变更（从什么到什么），mixed是这两种的混合形式.binlog是在两阶段提交 preparre 和 commit之间，也是要先write到page cache（文件系统缓冲区），然后调用fsync进行刷盘 索引分类BTree索引，哈希索引，全文索引 索引的本质：索引是数据结构。 mysql索引的底层实现https://www.cnblogs.com/boothsun/p/8970952.html#autoid-6-1-0这个比较好http://blog.codinglabs.org/articles/theory-of-mysql-index.html 基本上都有 在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。 聚簇索引的优缺点聚簇索引的优点 1、聚簇索引将索引和数据行保存在同一个B-Tree中，查询如果是通过聚簇索引查询的，可以直接获取数据，而非聚簇索引查到的是数据所在的指针，还需要进行一次I/O获取数据，因此聚簇索引通常比非聚簇索引查找更快。 2、对主键进行范围查询的效率很高，因为其数据是按照主键排列的 3、减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新二级索引的行指针 聚簇索引的缺点 1、聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据都存放在内存中，则访问顺序就不那么重要了，非聚簇索引也能很快在内存中查到数据，那聚簇索引也没什么优势。 2、插入速度严重依赖于插入顺序。按照主键顺序往InnoDB中进行数据导入是最快的。如果不是按照主键插入，最好在导入完成后使用OPTIMIZE TABLE命令重新组织一下表。事实上，如果不是按照顺序插入，可能会引起大量的页面分裂和数据移动 3、聚簇索引在插入新行和更新主键时，可能导致“页分裂”问题：当插入到某个已满的叶子结点时，B+树会分裂成两个页来容纳新插入的行数据。页分裂会导致表占用更多的磁盘空间（不要用UUID或随机数做主键，而应该使用单调递增的值做主键）。 4、聚簇索引可能导致全表扫描速度变慢，因为可能需要加载物理上相隔较远的页到内存中（需要耗时的磁盘寻道操作）。 5、二级索引访问数据行需要两次索引查找，解决办法是实现索引覆盖，直接在二级索引就能获取要所有需要的字段了，这样就不用再去主键索引搜索。 6、由于二级索引保存了主键列，二级索引会占更大的空间(所以选用一个短主键是有利的)。 mysql联合索引的结构 联合索引失效的场景https://www.zhihu.com/question/304037770/answer/541460420 比如有一个表的索引是（年龄、姓名）的联合索引。 它也是一颗B+树，和其他非聚簇索引不同的是，它是按多个列从左往右进行排序的，叶子节点还是存储主键的值。所以如果没有使用最左边的那一列来筛选索引就会失效。最左匹配原则 什么是覆盖索引？如果一个索引包含了所有需要select的信息，那么就不用回表了。 MySQL的引擎有哪几种，它们有什么区别（常规题） innoDB 支持事务、外键 聚集索引 支持表、行级锁 MyISAM 非聚集索引 可以压缩数据 仅支持表级锁 当前读(current read)select … lock in share mode select … for update insert update delete 快照读RR级别下的select 如何快速插入百万级数据java可以使用 预编译PreparedStatement 批次执行 建立了哪些索引，联合索引哪个放在了前面哪些情况下数据库索引会失效？https://www.cnblogs.com/itsharehome/p/4972948.html 最左匹配复合索引的时候 使用Like 且%在 最前面的时候 查询条件中含有函数或者表达式 条件带or IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。 如果它认为全表扫描比走索引快 BinLog是服务层的Server Layer Redo Log 持久化是引擎层的 重做日志是在崩溃恢复期间使用的基于磁盘的数据结构，以纠正由不完整事务编写的数据。 因为mysql一开始只是对内存中的数据进行操作，然后将命令写入RedoLog Undo Log 回滚撤消日志是与单个读写事务关联的撤消日志记录的集合。 undo log记录包含有关如何撤消事务到群集索引记录的最新更改的信息。如果另一个事务需要将原始数据视为一致读取操作的一部分，则从撤消日志记录中检索未修改的数据。 undo日志存在于undo日志段中，这些段包含在回滚段内。回滚段驻留在系统表空间中，在撤消表空间中以及临时表空间中。 什么是DCL？数据库控制语言 grant user REVOKE user commit DDL？craete table/view/index/ DML？insert/update/delete DQL？select 分库分表在项目中我将包裹表分表，因为包裹表列数太多，而有刚好可以通过寄件人信息、收件人信息、包裹信息来拆分为三个表，然后通过主键关联；联合查询性能不好 id 、select_type、table、type、possible keys、key、keylen、ref、rows、extra SQL在是如何在mysql运行的？ 分析器 优化器 执行器（引擎提供） 一条SQL语句执行得很慢的原因有哪些https://zhuanlan.zhihu.com/p/62941196 MYSQL的调优http://blog.codinglabs.org/articles/theory-of-mysql-index.html sql语句的优化，like or in 慎用 避免* 对where中经常判断的建立索引，并分析可能失效的时候 Explain命令Id：代表执行select子句或操作表的顺序Select_type：查询的类型,主要用于区别普通查询,联合查询,子查询等复杂查询 simple:简单的select查询,查询中不包含子查询或union查询primary:查询中若包含任何复杂的子部分,最外层查询则被标记为primarySubquery： 在select 或where 列表中包含了子查询Derived： 在from列表中包含的子查询被标记为derived,mysql会递归这些子查询,把结 果在临时表里Union： 做第二个select出现在union之后,则被标记为union,若union包含在from子句的子查询中,外层select将被标记为derivedunion result： 从union表获取结果的selectTable：显示一行的数据时关于哪张表的 Type：查询类型从最好到最差依次是:system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;All,一般情况下,得至少保证达到range级别,最好能达到ref system:表只有一行记录,这是const类型的特例,平时不会出现const:表示通过索引一次就找到了,const即常量,它用于比较primary key或unique 索引,因为只匹配一行数据,所以效率很快,如将主键置于where条件中,mysql就能将该 查询转换为一个常量eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配,常见于主键或唯 一索引扫描ref:非唯一性索引扫描,返回匹配某个单独值的行,它可能会找到多个符合条件的行,所以 他应该属于查找和扫描的混合体range:只检索给定范围的行,使用一个索引来选择行,如where语句中出现了 between,&lt;,&gt;,in等查询,这种范围扫描索引比全表扫描要好，因为它只需要开始于索引 的某一点，而结束于另一点，不用扫描全部索引。index:只遍历索引树,这通常比All快,因为索引文件通常比数据文件小,index是从索引 中读取,all从硬盘中读取all:全表扫描,是最差的一种查询类型Possible_keys：显示可能应用在这张表中的索引,一个或多个,查询到的索引不一定是真正被用到的 Key：实际使用的索引,如果为null,则没有使用索引,因此会出现possible_keys列有可能被用到的索引,但是key列为null,表示实际没用索引。 Key_len：表示索引中使用的字节数,而通过该列计算查询中使用的 索引长度,在不损失精确性的情况下,长度越短越好,key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即,key_len是根据表定义计算而得么不是通过表内检索出的 Ref：显示索引的哪一列被使用了,如果可能的话是一个常数,哪些列或常量被用于查找索引列上的值 Rows：根据表统计信息及索引选用情况,大只估算出找到所需的记录所需要读取的行数 Extra：包含不适合在其他列中显式但十分重要的额外信息 SQL慢查询主要的原因：全表扫描、全索引扫描、索引过滤性不好。 超过 long_query_time 参数设定的时间阈值（默认10s），就被认为是慢查询。 通过set global slow_query_log=1开启慢查询日志。 通过set log_queries_not_using_indexes=1设置是否记录未使用索引的sql。 即使使用到了索引也有可能会导致慢查询，比如有id为主键的一个表，id全部&gt;0，但是你如果使用where id &gt;0那就其实还是走了全表扫描，主键只使用在了第一个地方。 数据库设计三大范式 第一范式(确保每列保持原子性) 地址拆分为省市区 第二范式(确保表中的每列都和主键相关) 第三范式(确保每列都和主键列直接相关,而不是间接相关) 去除冗余 a-&gt;b -&gt; c 拆为ab和bc SQL写横标纵表的转换？纵表变横表 聚合函数[max或sum]配合case语句 123456select 姓名,sum (case 课程 when &#x27;语文&#x27; then 成绩 else 0 end) as 语文,sum (case 课程 when &#x27;数学&#x27; then 成绩 else 0 end) as 数学,sum (case 课程 when &#x27;英语&#x27; then 成绩 else 0 end) as 英语from Table_Agroup by 姓名 横表变纵表 1234select 姓名,&#x27;语文&#x27; as 课程,语文 as 成绩 from Table_B union allselect 姓名,&#x27;数学&#x27; as 课程,数学 as 成绩 from Table_B union allselect 姓名,&#x27;英语&#x27; as 课程,英语 as 成绩 from Table_Border by 姓名,课程 desc 查看建表语句SHOW CREATE TABLE package","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"mysql","slug":"mysql","permalink":"https://huajiaohuixiang.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://huajiaohuixiang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"JVM","slug":"JVM","date":"2021-05-12T03:24:40.000Z","updated":"2021-05-12T03:26:22.394Z","comments":true,"path":"2021/05/12/JVM/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/05/12/JVM/","excerpt":"","text":"1.JVM内存区域OOM了解吗？什么情况下会出现OOM？​ 对栈来说，如果没有空间来为新的栈帧开辟空间就会产生OOM ​ 对永久代如果空间不够会抛出OOM ​ 对堆：如果空间不够也GC没用的情况下也会抛出OOM ​ 一般可能是内存泄漏或者是内存溢出照成的。 StackOverflow出现的场景？​ 对栈来说，如果线程请求的栈深度大于虚拟机所能接受的栈深度会抛出SOF 1.JVM内存区域分为五大部分：虚拟机栈 java线程的栈帧，线程的每一个方法会生成一个栈帧，用于存放该线程的局部变量表、操作数栈、动态连接、方法出口等信息。随着方法的调用与结束，对应着入栈与出栈；局部变量表中存放着方法参数和内部定义的局部变量，基本存储单位是方法槽。 动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用是为了支持方法调用过程中的动态连接(DynamicLinking) 这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析 另外一部分符号引用将在每一次运行期间都转化为直接引用，这部分就称为动态连接 操作数栈：java虚拟机栈中的一个用于计算的临时数据存储区 本地方法栈 Native方法的栈帧 和虚拟机栈差不多，只不过是调用ni方法的栈帧堆 几乎所有的对象都在这里分配内存​ 堆分为老年代、新生代、永久代； ​ 新生代分为Eden FromSurvivors To Survivors 8：1：1 ​ 这两个Survivors有什么用呢？ ​ 在分配内存时，每次只使用一块Eden和 Survivor然后使用标记复制算法将其复制到另一块Survivor上。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）。 方法区 ：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 程序计数器：当前线程字节码文件的行号指示器，通过改变该计数器的值来获得下一步执行的字节码指令；程序控制流的指示器，程序当中的分支、循环、线程恢复、跳转、异常处理都要由它指示。由于Java虚拟机通过时间片轮转实现多线程，所以每一个线程都需要一个程序计数器记录当前执行的位置。 3.对象访问定位的方式：​ 句柄池：每一个句柄 数据结构中包括对象数据的指针以及类的指针 ​ 直接指针 在对象数据中存放类指针 5堆内存中对象分配的基本策略：2种​ 碰撞指针、空闲表 并发问题如何解决 CAS乐观锁+失败重试 先创建失败了就重试 TLAB 为每个线程在Eden初设一点内存，现在TLAB分配 当TLAB用完后，用CAS+失败重试 2.垃圾回收一个长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，就会造成内存泄漏。 ThreadLocalMap中存在内存泄漏。 如何判断对象是否死亡：​ 如果没有任何一个对象引用该对象则判断为死亡（可达性方法） ​ （引用计数法）没引用一次加一取消引用减一；不好解决互相引用的问题； GCRoots有哪些？​ 虚拟机栈中引用的对象，本地方法栈中引用的对象 ​ 方法区中常量引用的对象，方法区中类静态属性引用的对象 7.如何判断常量是否无用，类是否无用？​ 常量无用：没有引用即可 ​ 类无用：该Class类没有被引用、没有该类的对象还在存活、该类的ClassLoader已经销毁 分代收集理论如今的垃圾回收器大都是遵循分代收集。建立在两个分代假说：弱分代假说，强分代假说。垃圾回收器应该将Java堆分为不同的存储区域，根据其年龄进行收集。 跨代引用假说，跨代引用相对于同代引用仅占用极少数。 如何解决跨代引用的问题？在新生代维护一个记忆集，将老年代分为若干块，标识出哪一块会存在跨代引用，在mingc的时候将它加入到GCroot中。 MinorGC MajorGC FullGC 新生代、老年代、整堆收集正是因为垃圾回收器每次只回收某一个或者某些部分的区域，才有了这三个回收类型的划分。然后根据不同的区域采取不同的回收算法 什么时候会FullGC？ System.gc()方法的调用 老年代空间不足（新生代转入、创建大对象） CMS无法处理浮动垃圾、有可能出现并发清理失败进而导致另一次完全“Stop The World”的Full GC的产生 垃圾回收算法？各有什么优缺点​ 引用计数算法和追踪式算法（引用式算法实现比较简单但是不好解决循环引用的问题） 追踪式算法基于分代假说理论，分别在各自的内存区域回收各自的无用对象，关于如何解决跨代引用，需在新生代上建立一个全局的数据结构（该结构被称 为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会 存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。 ​ 标志清除 产生内存碎片 /执行效率不稳定：可能需要回收的对象占大部分 ​ 标记复制 解决了内存碎片 可用空间减为一半，改进后在新生代使用。 ​ 标记整理 慢，适合老年代 什么是STW？必须全部暂停用户线程 什么是安全点？可达性分析算法中通过根节点枚举来查找引用链，然后通过OopMap来得到对象的引用地址，因为Oopmap变化是实时的不能为每一条指令都生成oopmap，只在安全点生成oopmap，然后让所有的线程跑到最近的安全点 停下来即可完成STW并且进行根节点枚举。 记忆集与卡表—有其他分代区域中对象引用了本区域对象时，其对应的 卡表元素就应该变脏， 通过写屏障（Write Barrier）技术维护卡表状态的 垃圾回收器三个年轻代 Serial ParNew Parrllel Scavenge 三个老年代 CMS SerialOld Parallel Old 然后是G1 SGC ZGC Serial/Serial Old这两个的运行过程一样的 在单核处理器下很好，他说所有收集器占用额外内存最小的。 然后是ParNew，Serial的多线程版本 然后是Parrllel Scavenge 和ParNew擦不多重点关注吞吐量 然后是ParallelOldPS的老年代版本 ，标记整理算法/ 老年代的CMS 2次stop the world 详细看一下一种以获取最短回收停顿时间为目标的收集器，并发收集、低停顿。到这里就不一样了，运行过程变成了四个。 四个阶段 初始标记（STW）、并发标记、重新标记(STW)、并发清除 单线程 、单线程与用户并发、多线程、单线程并发 缺点：1.在核数小于四个的情况下咱用核心数多，吞吐量降低 2.无法处理浮动垃圾、有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。是CMS运行期间预留的内存无法满 足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不 得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 3.标记清除会产生碎片，在无法为新对象分配时会FullGC或者进行整理。但是是单线程的 G1 3次 stop the world开创了收集 器面向局部收集的设计思路和基于Region的内存布局形式。 且其内存区域是按Region来划分，每一个Region都可以作为Eden From To 或者是老年代，它可以面向堆内存任 何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理。 可以建立起停顿时间模型的收集器，每次收集停顿时间都少于某个时间。 四个阶段（三次STW） 初始标记（STW）、并发标记、最终标记(STW)、筛选回收（STW） 单线程 、单线程与用户并发、多线程、 多线程 Region引用对象如何解决？解决的思 路我们已经知道（见3.3.1节和3.4.4节）：使用记忆集避免全堆作为GC Roots扫描， ·初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。 ·并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。 ·最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。 ·筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。 两个低延迟的垃圾回收器 ​ ZGC 染色指针 Region大小可变 ​ shenandoahGC 对G1的增强 内存分配与回收策略对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起 一次Minor GC。 大对象直接进入老年代 长期存活的对象将进入老年代，每经过一次minorGC年龄增加一岁，增加到一定程度就会晋升至老年代 动态对象年龄判定：当Survivor空间中相同年龄所有对象占用的空间大于Survivor空间的一半，大于等于该年龄的对象就会直接进入老年代。 空间分配担保：每次MinorGC之前都要检查老年代的连续可用空间是否能够容纳当前新生代所有对象的大小，如果不能容纳就需要FullGC，如果设定了允许担保失败可以不进行FullGC 会不会发生内存泄漏？https://www.cnblogs.com/gaopeng527/p/5258413.html 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露 静态集合，容器中的对象在程序结束前不能释放（但是还是可能有用，如果没用了就是泄漏） HashMap中对象的hash值被改变 各种连接，比如数据库的连接，如果没有close会泄漏 内部类持有外部类，外部类无法GC ThreadLocalMap中会发生内存泄漏 3.类加载何时加载类 使用new ，获取类的static， 子类加载的时候发现父类还没有加载 JVM启动的时候main类 使用反射 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。 .类加载过程/Java对象的创建过程：（每一步详细实现）https://www.cnblogs.com/xiaoxian1369/p/5498817.html#:~:text=%E5%85%B6%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%8C%85,%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5%E3%80%82 加载（加载进内存、转换成Class实例对象）、 连接（验证、准备：分配空间设置0值、解析） 验证：是确保Class文件的字节流中包含的信息符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。 准备：准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初 始值的阶段。 解析：：符号引用-&gt;直接引用 ​ 直接引用就是直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。 初始化：（执行静态变量复制、静态代码块） ​ 执行类构造器·clinit()方法 创建对象的过程​ 检查类是否加载 ​ 分配内存，在堆中分配内存 ​ 初始化 为变量赋默认值 ​ 设置对象头 ​ 执行() ()是指收集类中的所有实例变量的赋值动作、实例代码块和构造函数 类加载器启动类加载器 由C++实现是虚拟机自身的一部分 加载/lib下的 扩展类加载器加载/lib/ext/下的 应用程序加载器自定义加载器双亲委派模型当一个类加载器接收到一个类加载的任务时，不会立即展开加载，而是将加载任务委托给它的父类加载器去执行，每一层的类都采用相同的方式，直至委托给最顶层的启动类加载器为止。如果父类加载器无法加载委托给它的类，便将类的加载任务退回给下一级类加载器去执行加载。 双亲委托模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载。 为什么要使用双亲委托模型？使用双亲委托机制的好处是：能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。使用双亲委托模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委托给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种加载器环境中都是同一个类。相反，如果没有使用双亲委托模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果自己去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行。 双亲委托模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委托的代码都集中在java.lang.ClassLoader的loadClass()方法中，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass方法进行加载。 破坏双亲委派模型自定义一个类加载器，不让他委托给父类 JDK9的模块4.Java 内存模型 JMM工作内存与主内存所有变量都存在主内存，每个线程都还有自己的工作内存，工作内存通过load和store将变量取出或放入。 什么是内存屏障？大多数现代计算机为了提高性能而采取乱序执行，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。 java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。 LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障； DCL为何需要加volatile使用了它的禁止重排序，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便 是赋值操作）多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个内存屏障 （Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置 volatile如何实现的内存可见性？addl$0x0，(%esp)”的空操作可以将本地处理器的缓存写入内存，该写入动作也会引起处理器或者别的内核缓存无效化，实现了可见性。 volatile如何实现的禁止重排序？关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便 是赋值操作）多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个内存屏障 （Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置 volatile 关键字​ volatile 变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反映到其他线程之中。从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看 不到不一致的情况，因此可以认为不存在一致性问题。但是由于java中的操作不是原子性的，所以多线程是不安全的。 指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。Volatile修饰的变量可以禁止指令重排序。 在操作前后加一个内存屏障 线程的状态转换·新建（New）：创建后尚未启动的线程处于这种状态。 ·运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可 能正在执行，也有可能正在等待着操作系统为它分配执行时间。 ·无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线 程显式唤醒。以下方法会让线程陷入无限期的等待状态： ■没有设置Timeout参数的Object::wait()方法； ■没有设置Timeout参数的Thread::join()方法； ■LockSupport::park()方法。 ·限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待 被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状 态： ■Thread::sleep()方法； ■设置了Timeout参数的Object::wait()方法； ■设置了Timeout参数的Thread::join()方法； ■LockSupport::parkNanos()方法； ■LockSupport::parkUntil()方法。 ·阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到 一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时 间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 ·结束（Terminated）：已终止线程的线程状态，线程已经结束执行。 5.JVM调优设置堆大小Xms初始堆大小 Xmx最大堆大小 PermSize 初始分配的非堆内存 MaxPermSize 最大非堆内存","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://huajiaohuixiang.github.io/tags/JVM/"},{"name":"面试","slug":"面试","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Jetson Nano 搭建Mysql","slug":"Jetson-Nano-搭建Mysql","date":"2021-05-12T02:07:08.000Z","updated":"2021-05-12T16:25:06.478Z","comments":true,"path":"2021/05/12/Jetson-Nano-搭建Mysql/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/05/12/Jetson-Nano-%E6%90%AD%E5%BB%BAMysql/","excerpt":"","text":"如何使用JetsonNano或者树莓派搭建自己的服务器？ nano介绍 Jetson Nano和树莓派的区别 Jetson Nano 是一款功能强大的小型计算机，专为支持入门级边缘 AI 应用程序和设备而设计，拥有完善的 NVIDIA JetPack™ SDK 包含用于深度学习、计算机视觉、图形、多媒体等方面的加速库。 相比于树莓派多了显卡，也就是你可以通过图形化界面去操作，不只是命令行，在图像处理方面很强。 系统 Jetson nano 官方系统是ubuntu，是在ubuntu上修改的NVIDIA系统 ubuntu18.04 LTS，好像是是aarch架构，系统界面如下 安装配置mysql 安装 和直接在ubuntu上安装没有什么区别，直接使用apt-get install mysql-server 得到的是5.x版本，不是最新的8.x版本 使用 apt-get 安装完后 会生成一些默认的账户在 /etc/mysql/debian.cnf中 可以通过sudo cat /etc/mysql/debian.cnf查看 配置用户 登录应该是需要安装mysqsl-client,也是使用apt-get install mysql-client安装 然后登录 1mysql -u username -p 然后输入密码 新建用户，赋予权限 123456create user &#39;username&#39;@&#39;localhost&#39; identified by &#39;password&#39;;#username是你想创建的用户名#localhost是表示它可以通过那个ip来访问，localhost表示本地 其余ip表示其他地址 %表示所有#password是密码grant all privileges on 数据库.* to username@ip地址 ;#好像mysql的用户是通过 username+ip来区别，可以有连个username相同的用户，只要ip不一样。 修改配置文件，实现远程访问 12345678910cd /etc/mysql//然后ls一下 我的有下面这些东西，配置文件在mysql.conf.d中//conf.d debian-start my.cnf.fallback mysql.conf.d//debian.cnf my.cnf mysql.cnfcd mysql.conf.dvim mysqld.cnf //将地址127.0.0.1 改成0.0.0.0service mysql restart mysql其他常用命令： 123sudo service mysql restartsudo netstat -tap | grep mysql #查看是否允许 配置内网穿透 我选择使用花生壳进行内网穿透，花生壳还是比较方便的。 应该是可以直接参考树莓派的官方教程https://service.oray.com/question/11639.html 1dpkg -i phtunnel_5_0_rapi_aarch64.deb #安装 可以通过以下命令来操作： 123phddns #查看命令phddns start #打开phddns status #可以查看SN码 打开http://b.oray.com ，在登录页面中输入SN码与默认密码（admin）登录。 剩下的就看官方教程就好了https://service.oray.com/question/11639.html 建立的映射应该是tcp类型，绑定到3306端口 注意，需要先给你的Nano 配置IP与MAC绑定，因为你的路由器应该是使用动态分配IP，打开192.168.1.1即可进行绑定，不然每次都要重新 在管理界面绑定一次。 测试 可以先在内网测试一下能否脸上nano的mysql，使用ifconfig获得内网地址类似与192.168.1.101，然后在自己电脑上用workbench测试一下。 测试成功后绑定外网然后在外网试一下。","categories":[],"tags":[{"name":"jetson","slug":"jetson","permalink":"https://huajiaohuixiang.github.io/tags/jetson/"},{"name":"nano","slug":"nano","permalink":"https://huajiaohuixiang.github.io/tags/nano/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://huajiaohuixiang.github.io/tags/ubuntu/"},{"name":"mysql","slug":"mysql","permalink":"https://huajiaohuixiang.github.io/tags/mysql/"}]},{"title":"读书笔记","slug":"读书笔记","date":"2021-04-19T03:14:05.000Z","updated":"2021-04-19T03:20:49.335Z","comments":true,"path":"2021/04/19/读书笔记/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"n 那些80年代的红砖还能叫红色吗，大概只能算是煤球渣子的近亲。正如唱歌的最终会沉默，昨日奔跑着的青年和鸵鸟，一转眼就是今天的腐肉、秃鹫。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://huajiaohuixiang.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"3.14字节面经","slug":"字节一面二面","date":"2021-03-14T13:18:29.000Z","updated":"2021-03-14T13:47:59.970Z","comments":true,"path":"2021/03/14/字节一面二面/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/14/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2/","excerpt":"","text":"项目 token如何解密的 session和cookie的区别 登陆的逻辑 两个栈实现一个队列 巴什博奕（Bash Game）：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 hashMap的扩容原理，为什么扩容二倍； 写一个select语句 两个表 组合查询 我用嵌套实现的，他想考我join查询 四大事务特性 TCP的可靠性是怎么实现的 TIME_WAIT 算法 有一个二维数组，里面的数字要么是0，要么是1，求出 全由1组成的正方形的面积最大是多少？ 二面：问项目和数据库。。。因为他们用的go 所以java一点没问 给一个正数 &gt;0 ，求这个数的平方根，结果精切到小数点后5位。（我是傻逼，本来很简单的题） 项目写了用的Oracle数据库，为什么用Oracle，Oracle与mysql数据库的区别？ Redis五大数据类型底层数据结构 如何使用Redis和MQ实现的抢购优惠券 Mysql表锁和行锁之间间隙锁是如何实现的。 四大事务特性的一致性是怎么实现的 讲一下可重复读 聚簇索引 undolog和redolog HTTP状态码 HTTPS和HTTP的区别","categories":[],"tags":[{"name":"面经","slug":"面经","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"3.9蚂蚁面经","slug":"3-9蚂蚁面经","date":"2021-03-09T15:18:29.000Z","updated":"2021-03-14T13:47:19.730Z","comments":true,"path":"2021/03/09/3-9蚂蚁面经/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/09/3-9%E8%9A%82%E8%9A%81%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"1.项目2.你是如何设计数据库的3.HashMap ConcurrentHashMap的区别4.Array List LinkedList 扩容机制5.JVM 堆（）中对象的转移？https://www.cnblogs.com/guanghe/p/10524314.html6.数据库 悲观锁乐观锁 如何实现的？7.排序算法8.算法：1G的文件、1M的内存，每一行一个词、求最高的100个词9.索引 在什么字段上建立索引，索引大概的原理10.Spring Aop？原理？11.进程线程区别","categories":[],"tags":[{"name":"面经","slug":"面经","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"","slug":"反射","date":"2021-03-08T12:27:53.797Z","updated":"2021-03-09T03:17:52.115Z","comments":true,"path":"2021/03/08/反射/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/08/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"什么是反射？ ​ JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。 获取 Class 对象的四种方式如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象: 1.知道具体类的情况下可以使用： 1Class alunbarClass = TargetObject.class;Copy to clipboardErrorCopied 但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取Class对象不会进行初始化 2.通过 Class.forName()传入类的路径获取： 1Class alunbarClass1 = Class.forName(&quot;cn.javaguide.TargetObject&quot;);Copy to clipboardErrorCopied Class.forName(className)方法，内部实际调用的是一个native方法 forName0(className, true, ClassLoader.getClassLoader(caller), caller); 第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。 一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。 3.通过对象实例instance.getClass()获取： 12Employee e = new Employee();Class alunbarClass2 = e.getClass();Copy to clipboardErrorCopied 4.通过类加载器xxxClassLoader.loadClass()传入类路径获取 1class clazz = ClassLoader.LoadClass(&quot;cn.javaguide.TargetObject&quot;);Copy to clipboardErrorCopied 通过类加载器获取Class对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行 我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序； Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系； 动态配置实例的属性；","categories":[],"tags":[]},{"title":"","slug":"阿里3.6笔试题2","date":"2021-03-08T02:33:15.038Z","updated":"2021-03-08T02:54:14.303Z","comments":true,"path":"2021/03/08/阿里3.6笔试题2/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/08/%E9%98%BF%E9%87%8C3.6%E7%AC%94%E8%AF%95%E9%A2%982/","excerpt":"","text":"给定N条线路 每条线路经过一些站点，判断能否从一个点到达另一个点； floyd算法，但不需要求最短路径 输入： 2 3 6 两条线路 3起始站 6终点站 3 第i个线路经过几个站 1 6 7 4 2 3 4 7 返回true","categories":[],"tags":[]},{"title":"集合","slug":"集合-1","date":"2021-03-08T01:21:56.000Z","updated":"2021-03-08T01:21:56.948Z","comments":true,"path":"2021/03/08/集合-1/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/08/%E9%9B%86%E5%90%88-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java基础","slug":"Java基础","date":"2021-03-07T13:41:59.000Z","updated":"2021-05-12T03:35:43.695Z","comments":true,"path":"2021/03/07/Java基础/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"temp说说final,finally,finalizefinal 分别修饰类 方法 变量的时候 finalize使用的场合是什么被废弃了已经，不建议使用。GC在回收对象是先将其加入一个队列，然后执行finalize方法在该方法可以实现自救，但finalize只能自己调用一次 finally什么情况下不会执行1 try语句没有执行 2 在try中有System.exit(0)这种语句，会是JVM退出 3 在守护线程中Daemond JDK1.8新增了非常多的特性，本专题主要讨论以下几个 Lambda表达式：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法：默认方法就是一个在接口里面有了一个实现的方法。 新工具：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API：加强对日期与时间的处理。 Optional类：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn，JavaScript引擎：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 多线程读多写少怎么优化多读少写的场景 如何提高性能https://blog.csdn.net/u013452337/article/details/90238052 ReentrantedLock（读读、读写、写写都是互斥）-&gt;ReentrantReadWriteLock（改进了读读，读写、写写还是互斥）-&gt;StampeddLock（允许在读的时候获得写锁，然后读锁阻塞）读写锁 但是会造成饥饿问题 https://blog.csdn.net/qq_33220089/article/details/105173632 Mysql悲观锁乐观锁https://blog.csdn.net/qq_33220089/article/details/103920324 使用读写锁在CopyOnWriteArrayList中，写是往拷贝的数组中写，读是读原来的，写完后在赋值给原来的。通过volatile可见性实现。 在 Java 中定义一个不做事且没有参数的构造方法的作用如果子类有一个无参构造函数，而父类没有无参构造函数、只有有参构造函数，则会编译不通过，子类的无参需要先调用父类的无参，而父类有了有参后，默认的无参就不生效了 自己整理的题目以及答案 如何跳出多层循环使用带有标号的break 1break a; 基本数据类型讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？java有八大基本类型，short、int、long、float、double、boolean、byte、char 对于这个八个基本类型都有对应的包装类型，比如int Integer、Short与short、char与Character。基本类型到包装类型就是装箱、包装类型到基本类型就是拆箱。 对于Integer 来说， Integer i=1 调用了Intteger.valueOf()方法； int n=i 调用了Integer.intValue()方法； 可能会到缓存池那里Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。 为了性能和资源之间平衡的最好结果。 修饰符访问修饰符默认是同一个包内可见 protect是同一个包内+所有包的子类 函数为什么只有值传递？程序设计语言来说，有值传递和引用传递； 在Java中，函数得到的都是对对象引用的一个拷贝；对于其他设计语言来讲，比如C++ 如果传递的是&amp; 则函数收到的就是这个对象。 重载和重写的区别？重载是指对象中可以有很多相同方法名相同的函数，根据不同的输入参数，可以做不同的事。方法签名包括方法名与参数。重载函数可以返回类型和访问修饰符可以不同。不能有两个方法签名相同但是返回类型不同的方法。就是不能依靠返回类型来判别。 重写是指子类对父类继承函数的重新编写，方法名、参数都必须相同。返回值必须比父类的更小或相等，抛出异常的范围要小于父类，访问修饰符的权限要大于等于父类。如果父类方法被final private static 修饰，不能被重写，对于static的函数可以重新声明，代表子类的静态函数。 返回值必须更小（子类）或者相等是指比如父类返回List 子类可以返回ArrayList （对于Void 和基本数据类型不可更改，只能和父类相同） 抛出异常： 也是指抛出的要是父类异常的子类 静态方法为什么不能重写静态属性和静态方法只是可以继承没有表现出多态性。根据《java编程思想》中的描述这是因为静态方法和静态属性没有采用动态绑定。即使你定义了相同的静态方法名，他也只是子类和父类的两个方法，并没有继承的关系，并且也会默认隐藏父类的静态方法。具体表现就是，将子类实例向上转型则会调用到基类中的静态方法和属性，不转型就调用子类自身的静态方法和属性。编译器不推荐通过实例去调用静态方法和属性，因为这种调用方式容易造成混淆。 可以通过子类去调用父类的静态方法，但是子类如果有相同名称的静态方法，会默认隐藏父类的静态方法 深拷贝与浅拷贝的区别？对于基本属于类型来讲，这两个拷贝是一样的都是拷贝的值。 对于引用数据类型来讲，浅拷贝是指只拷贝当前对象对于对象中的各个属性对象不在继续拷贝。对于深拷贝来讲不仅拷贝当前对象，对于对象中的各个属性也会递归拷贝。 例如：有一个Student 中有teacher属性，对student 进行浅拷贝后，这两个student是不同的对象但是其中的teacher却指向了相同的对象。如果是深拷贝则会指向不同的对象。 泛型什么是泛型？泛型就是编写模板代码来适应任意类型 为什么是伪泛型？Java泛型是伪泛型，对于List和List经过JVM编译后都会变成List 里面是通过Object来存储，所以对于List我们可以通过反射来向里面添加String而不报错。 都有什么泛型？类的泛型，对接口的泛型，对方法的泛型； ？extend Object 和？Super的区别？？代表所有 ?extend C是指继承于C的都可以，确定了上限 ？Super C是指是C的父类都可以，确定了下限 Object 方法equals hashcode wait notify ==和equals的区别为什么重写 equals 时必须重写 hashCode 方法？（和HashMap、HashSet查找有关）其实简单的说就是为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。 因为Object的Hashcode方法是native方法有JVMC或C++实现的，如果重写了equals方法而没有重写hashxcode 有可能出翔equals相等而hashcode不同。 面向对象面向对象的三大特性？继承、子类拥有父类的所有属性和方法，但是被private修饰的不能访问 封装、 多态 程序中定义的引用类型调用的方法在编译时并不能确定，需要在运行时确定，具体表现就是通过父类来指向子类实现多态 或者通过接口来实现多态 面向对象和面向过程的区别面向对象是一种 对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。 面向过程 (Procedure Oriented) 是一种 以过程为中心 的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。 成员变量和局部变量的区别？语法上 成员变量属于类 局部变量属于方法 成员变量可以用访问修饰符修饰 局部变量不能 内存分配上 成员变量在堆中 局部变量在栈中 如果局部变量是对象的话，也是在堆中分配，栈帧中存放一个引用 （可以分一下引用类型和基本类型） 生存时间：成员变量随着类 局部变量随着方法 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。 静态方法和实例方法有什么不同？静态方法属于类。对于静态方法其不能访问非静态属性，因为调用该静态方法的时候，该类可能没有对象，成员变量还没有初始化。可以通过类名和对象名来调用。 实例方法属于对象。只能通过对象名来调用实例方法 接口和抽象类的不同?含义上：而抽象类是对类的抽象,用于捕捉子类共同的特征。 抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。 从抽象来看 接口定义了一组行为规范，实现该接口的必须都要实现接口定义的方法 abstract class 表示的是is a关系，interface表示的是like a关系。 可以实现多个接口但只能继承一个抽象类。 语法上： 抽象类必修要有一个abstract方法，且抽象类不能被实例化，其余和普通方法一样，可以实现静态方法与普通方法、普通变量、静态变量、常量； 接口不能拥有普通方法与普通变量，但可以有默认方法实现，静态变量静态方法； 接口的默认访问权限是public，且不能有其他访问权限进行修饰； StringString的subString先判断类型lantin1还是utf16 然后分别调用StringLantin1.newString(byte数组，起始位置，长度)或者StringUtf16.newString() StringBuffer SringBuilder String 区别String类是被final修饰表示不可继承，其成员变量byte数组被private final修饰被final修饰指向数组不变，private并且没有提供修改数组的方法则整个 字符串是不i可变的。因为String的不可变性，我们每次对字符串操作其实都要生成一个新的字符串，然后指向新的字符串。会产生大量临时对象，然后GC会便麻烦。 builder和buffer中都是没有final修饰char数组，StringBuilder、StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer 反射什么是反射？对于任意一个类我们都能知道这个类的属性和方法，对于任意一个对象我们都能调用它的任意一个属性和方法。这种动态获取信息以及动态调用方法的功能称为反射； 知道获取Class对象的几种途径（类名.class、Class.forname()、对象.getClass() 通过Class对象创建出对象，获取出构造器，成员变量，方法.getPackage()、getModifiers()、getName()、getSimpleName()、getSuperclass() 获取类属性 getFields() //获取所有的公共(public)字段包括父类 返回Field[]数组 getDeclaredFields() // 获取所有声明的字段(不包括父类) 返回Field[] getField(String name) // 获取指定的公共字段包括父类 返回Field getDeclaredField(String name) // 获取指定的声明的字段(不包括父类) 返回Field 通过反射的API修改成员变量的值，调用方法操作类属性** 操作静态属性 类属性对象.get(null) //返回静态属性的值 类属性对象.set(null,”值”) //赋值** 操作非静态属性 类属性对象.get(Object obj); 类属性对象.set(Object obj,”值”); 反射优缺点：比较灵活，反射是框架设计的灵魂， 速度会变慢 java异常体系​ java异常都是继承于Throwable，分为Exception和Error。错误一般都是很严重的故障，通常不用捕获Error，比如OOM StackOverFlow ​ Exception分为runtime exception和IO Exception，比如Index OurofBound NullPointer。 Exception还可以按可检查与不可检查来分类，可检查的Exception，如果对其没有做try 或者throws不能通过编译。class not found filenot found 。 RuntimeException 及其子类都统称为非受检查异常 IO异常和SQL异常是受检查异常。除了runtime其余的都是受检查的异常。 Throwable 类常用方法 public string getMessage():返回异常发生时的简要描述 public string toString():返回异常发生时的详细信息 public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同 public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息 写代码的时候怎么处理异常，继承自Exception还是RuntimeException通常业务类异常如果希望它是Throwable的，或者带有业务语义的异常，就定义checked；系统类异常就unchecked。 如果我们的服务是很稳定的，可以继承自RuntimeException，不需要try catch去处理。如果不是稳定的，需要调用它的人对逻辑进行补充，那么可以继承自Exception。 Error能被捕获吗？Error跟Exception一样都继承自Throwable，是指不应该被捕获的严重错误。实际上在代码中是可以被catch的。但是没用 集合ArrayList扩容机制grow12345678private Object[] grow(int minCapacity) &#123; return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity));&#125;private Object[] grow() &#123; return grow(size + 1);&#125; grow函数调用grow(size+1)在另一个里面会调用newCapacity(size+1)，然后返回新的数组长度（原来的+原来的右移一位），然后调用Arrayss.copyOf() ArrayList Add过程123modCount++;add(e, elementData, size);return true; 一个普通的add 会调用私有的add 先判断当前数组的容量是否和长度相同,相同则表示已经满了需要扩容调用grow 然后elementData[size]=e； size++; Hashmap底层实现原理 底层结构 内部是Entry数组，Entry包含四个字段，hash值，val，key，next； 数组中每一个位置都当成一个桶，在桶内使用拉链法解决哈希冲突的问题。 数组的大小为2的幂，默认16，寻址可以通过取余，但是太慢，当size为2的幂的时候，通过与size-1 &amp; 按位与会和取余得到相同的结果还很快；扩容的时候一个拆两个也会更容易。在分库的时候一般也是按2的幂来分库，更容易扩展。 put调用putval，1.8链表并不是头插法，是尾插入，要先比较有无key相同的情况。 扩容 当map中的Entry数量大于阈值，就表明可能存在很多哈希冲突，导致性能下降，会进行扩容。 先获取原数组+原容量+原阈值 获得新大小（对容量为0等情况进行了考虑）普通情况下得到2倍容量，然后将原数组映射到新数组，再指向新数组，映射是将hash与size与，因为size的后面全是0 的得到的都是0，第一位是1，通过这样可以快速将其分为高位和低位。 树化 每putVal之后会检查当前桶的大小是否大于8 大于8并且总的数组大小大于64会将该桶树化，数组大小小于64的话会扩容，因为扩容也会将该桶内的节点稀释到高位桶中。 加载因子用于控制HashMap的疏密程度，如果Entry数量/数组大小&gt;加载因子，表明将有很多哈希冲突，需要扩容 计算哈希值 null返回0 否则和hashcode的高16位异或。 1(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); get方法，先判断数组是否为空 数组的长度是否大于0，在数组的那个节点是否为null ，然后检查第一个节点是不是，然后判断结构，分别调用tree的方法和链表遍历判断equals capacity+阈值+扩容 Hashmap底层实现原理 size方法 size不仅要得到当前的大小，还需要得到当前CAS失败的数量。 TreeSet的底层数据结构使用TreeMap实现，和HashSet一样 CopyOnWriteArrayList1private transient volatile Object[] array; 写/删时加锁，并且写的时候写道副本里，然后往副本写，写完后将原指针指向副本。 读直接读。 实现了读写分离。 Java集合的快速失败机制 “fail-fast”？是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。 例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。 原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 解决办法： 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。 使用CopyOnWriteArrayList来替换ArrayList comparable 和 Comparator 的区别 comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序 comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序 HashMap 和TreeMap的区别实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。 实现SortMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下： HashMap和HashTable区别HashTable是线程安全的，为每个方法加了Synchronized。HashTable继承于字典类。 Hash Table 中不能存在null 。HashMap中的key和value都可以是null 计算Hash的方式不同，hashtable是使用对象的hashcode，hashmap重新计算了hash值，通过和前面16位异或 计算索引的方法不同：hashtable是取余，hashmap是与length按位与&amp; 扩容hashtable 长度必须是奇数，减少hash碰撞；hashmap的2的幂 HashTable和ConcurrentHashMap区别HashTable粗暴的为每个方法加了Synchronized，为整个数组加了锁，效率很低。 ConHashMap在1.7中，将整个数组分为很多Segment，每个Segment中有几个Node，每次只对一个Segment加锁。在1.8中，取消了segment的使用，为每个节点使用CAS和Synchronized保证并发。 ConcurrentHashMap中如何用的CAS和Synchronizedput方法中，先判断key地方位置是否为空，如果是空就cas写入，如果不为空则需要加锁来对这个链表写入。 多线程进程线程的区别？进程是程序的一次执行，是系统运行程序的基本单位，相对于程序来讲他是动态的。进程是系统进行资源分配的基本单位，系统会为 线程是进程的一个执行单元，是进程内的调度实体，是系统进行资源调度的基本单位。 进程之间是互相独立的地址空间、独立的资源、同一个进程的多个线程之间共享本进程的地址空间，线程共享本进程的资源如内存、I/O、cpu等。在Java中，多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈 进程切换时，消耗的资源大，线程切换时消耗的资源小。 线程之间通信更加方便，同一个进程下，线程共享全局变量，静态变量等数据，但是需要处理多线程并发的问题。 线程的基本状态新建NEW 还没有调用start方法 可运行-运行RUNNABLE 阻塞 等待锁的时候进入阻塞状态 join 等待 wait() 通过notify()唤醒 超时等待 sleep(1000) wait（1000） 通过notify()唤醒 终止 线程结束 为什么要多线程？为什么程序计数器、本地方法站、虚拟机栈是私有的？多线程可能遇到的问题？死锁、内存泄漏、不安全 并发编程三要素？原子 可见 有序 上下文是什么？切换？多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 Java如何安全地停止一个线程(不等它运行结束)共享变量或者 interrupt（） 然后再run中不断判断isInterrupt() 创建线程的四种方式？thread runnable callable 线程池 Callable的创建过程？ 创建实现Callable接口的类myCallable 以myCallable为参数创建FutureTask对象 将FutureTask作为参数创建Thread对象 调用线程对象的start()方法 runnable 和 callable 有什么区别？ 返回值callable 通过futuretask.get()获取，且会阻塞当前主进程 runnable只能抛出运行时异常且无法捕获处理 callable的call方法允许抛出异常，可以获得异常信息。 run()和start()的区别？start()方法用于启动线程，run()方法是线程体。run可以重复调用，而start只能调用一次。我们如果单独的调用run方法就相当于调用了普通的函数。 new一个线程进入到新建状态，start后进入可运行状态，在时间片到了之后就可以执行run方法了 FutureTask原理？FutureTask用来表示一个异步执行任务的结果，可以通过get方法获得该结果，如果还没有完成会 阻塞。 FutureTask本身也实现了callable， 可以用它本身来构建futuretask Sleep和wait的区别wait是Object的方法，sleep是线程的方法 wait 释放锁sleep不释放锁 wait后需要notify来唤醒 wait(long time)会自动唤醒但是会争夺锁如果没有获得锁无法继续向下执行 sleep自动唤醒 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。 wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码： 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。 wait(), notify()和 notifyAll()这些方法在同步代码块中调用 有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。 综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。 为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。 为什么 Thread 类的 sleep()和 yield ()方法是静态的？Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。 为什么要线程池？因为对象的创建和销毁是很花费时间的，因为创建一个对象需要获取内存和其它资源。对于线程对象也是如此，所以我们将若干线程放入到线程池中，然后如果有任务来就把任务给线程去执行，减少线程创建和销毁的时间。 线程池介绍线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。 创建线程池的方式new ThreadPoolExcutor() 使用Excutors工具类创建 什么是 Executor 框架？为什么使用 Executor 框架？使用Executors工具类可以很方便的创建线程池。 自定义线程池ThreadPoolExecutor线程池的参数https://juejin.cn/post/6844903475197788168 1234567int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler corePoolSize=&gt; 线程池里的核心线程数量 maximumPoolSize=&gt; 线程池里允许有的最大线程数量 keepAliveTime=&gt; 空闲线程存活时间 unit=&gt; keepAliveTime的时间单位,比如分钟,小时等 workQueue=&gt; 缓冲队列 threadFactory=&gt; 线程工厂用来创建新的线程放入线程池 handler=&gt; 线程池拒绝任务的处理策略,比如抛出异常等策略 如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务； 如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中； 如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务； 如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。 Executors创建的线程池的类型java.util.concurrent.Executors 提供了一系列静态方法来创建各种线程池。下面例举出了主要的一些线程池及特性，其它未例举线程池的特性可由下面这些推导出来。 线程数固定的线程池 Fixed Thread Pool顾名思义，这种类型线程池线程数量是固定的。如果线程数量设置为n，则任何时刻该线程池最多只有n个线程处于运行状态。当线程池中处于饱和运行状态时，再往线程池中提交的任务会被放到执行队列中。如果线程池处于不饱和状态，线程池也会一直存在，直到ExecuteService 的shutdown方法被调用，线程池才会被清除。 1&#x2F;&#x2F; 创建线程数量为5的线程池。&#96;&#96;ExecutorService executorService &#x3D; Executors.newFixedThreadPool(&#96;&#96;5&#96;&#96;); 它使用的阻塞队列是Linked 无限大，所以可能会堆积大量任务 然后OOM 可缓存的线程池 Cached Thread Pool这种类型的线程池初始大小为0个线程，随着往池里不断提交任务，如果线程池里面没有闲置线程（0个线程也表示没有闲置线程），则会创建新的线程，保证没有任务在等待；如果有闲置线程，则复用闲置状态线程执行任务。处于闲置状态的线程只会在线程池中缓存60秒，闲置时间达到60s的线程会被关闭并移出线程池。在处理大量短暂的（官方说法：short-lived）异步任务时可以显著得提供程序性能。 1&#x2F;&#x2F;创建一个可缓存的线程池 &#96;&#96;ExecutorService executorService &#x3D; Executors.newCachedThreadPool(); 他会构建一个 最大线程为无限大的线程池 单线程池这或许不能叫线程池了，由于它里面的线程永远只有1个，而且自始至终都只有1个（为什么说这句话，因为要和 Executors.newFixedThreadPool(1) 区别开来），所以还是叫它“单线程池把”。你尽可以往单线程池中添加任务，但是每次只执行1个，且任务是按顺序执行的。如果前面的任务出现了异常，当前线程会被销毁，但1个新的线程会被创建用来执行后面的任务。以上这些和线程数只有1个的线程Fixed Thread Pool一样。两者唯一不同的是， Executors.newFixedThreadPool(1) 可以在运行时修改它里面的线程数，而 Executors.newSingleThreadExecutor() 永远只能有1个线程。 1&#x2F;&#x2F;创建一个单线程池&#96;&#96;ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor(); 它使用的阻塞队列是Linked 无限大，所以可能会堆积大量任务 然后OOM 大小无限线程池1ExecutorService executorService &#x3D; Executors.newScheduledThreadPool(); 核心线程自定义 可以是Integer.MAX_VALUE 线程池有什么优点？ 降低资源消耗：重用存在的线程，减少对象创建销毁的开销。 提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。 综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。 线程池的状态 RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。 SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。 STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。 TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。 TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。 线程池中 submit() 和 execute() 方法有什么区别？接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。 返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有 异常处理：submit()方便Exception处理 submit()执行Runnable的任务时，run()方法没显式抛出异常。execute()执行Callable的任务时，call()方法有显式的抛出异常。 如何定义一个注解123public @interface Hahaha&#123; String key() default &quot;&quot;;&#125; 通过四种元注解修饰注解：@Target，@Retention，@Documented，@Inherited, 哪里用到了线程池？连接数据库的时候Druid jion()方法：线程实例的join()方法可以使得一个线程在另一个线程结束后再执行，即也就是说使得当前线程可以阻塞其他线程执行； thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。 比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。 yield()方法理论上，yield意味着放手，放弃，投降。一个调用yield()方法的线程告诉虚拟机它乐意让其他线程占用自己的位置。这表明该线程没有在做一些紧急的事情。注意，这仅是一个暗示，并不能保证不会产生任何影响。 System.out.println()线程安全？是安全的，通过synchronized实现 https://blog.csdn.net/ft305977550/article/details/78769573 IO流流的划分 按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 四个抽象基类 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 select poll epoll是linux中实现io多路复用的方法， JAVA中的NIOJava的NIO模式的Selector网络通讯，其实就是一个简单的Reactor模型。可以说是Reactor模型的朴素原型。 http://www.cyc2018.xyz/Java/Java%20IO.html#%E4%B8%83%E3%80%81nio 通道 Channel **缓冲区 ** **选择器 ** NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JVM内存区域","slug":"JVM内存区域","date":"2021-03-07T02:37:27.000Z","updated":"2021-03-10T05:19:32.276Z","comments":true,"path":"2021/03/07/JVM内存区域/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/07/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"###看了好多面经，感觉还是要看书，然后自己整理一下,于是决定看深入理解java虚拟机这本书#######Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里 面的人却想出来。####1.JVM内存区域分为五大部分：虚拟机栈 java线程的栈帧，线程的每一个方法会生成一个栈帧，用于存放该线程的局部变量表、操作数栈、动态连接、方法出口等信息。随着方法的调用与结束，对应着入栈与出栈；局部变量表中存放着方法参数和内部定义的局部变量，基本存储单位是方法槽。 动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用是为了支持方法调用过程中的动态连接(DynamicLinking) 这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析 另外一部分符号引用将在每一次运行期间都转化为直接引用，这部分就称为动态连接 操作数栈：java虚拟机栈中的一个用于计算的临时数据存储区 本地方法栈 Native方法的栈帧 和虚拟机栈差不多，只不过是调用ni方法的栈帧堆 几乎所有的对象都在这里分配内存​ 堆分为老年代、新生代、永久代； ​ 新生代分为Eden FromSurvivors To Survivors 8：1：1 ​ 这两个Survivors有什么用呢？ ​ 在分配内存时，每次只使用一块Eden和 Survivor然后使用标记复制算法将其复制到另一块Survivor上。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）。 方法区 ：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 程序计数器： 当前线程字节码文件的行号指示器，通过改变该计数器的值来获得下一步执行的字节码指令；程序控制流的指示器，程序当中的分支、循环、线程恢复、跳转、异常处理都要由它指示。由于Java虚拟机通过时间片轮转实现多线程，所以每一个线程都需要一个程序计数器记录当前执行的位置。 2.Java对象的创建过程：（每一步详细实现）​ 检查类是否加载 ​ 分配内存，在堆中分配内存 ​ 初始化 为变量赋默认值 ​ 设置对象头 ​ 执行init 3.对象访问定位的方式：​ 句柄池：每一个句柄 数据结构中包括对象数据的指针以及类的指针 ​ 直接指针 在对象数据中存放类指针 4.JVM内存分配与回收：​ 大对象直接放在老年代 ​ 对象有限在eden分配 ​ 长期存活的对象进入老年代 5堆内存中对象分配的基本策略：2种​ 碰撞指针、空闲表 并发问题如何解决 CAS乐观锁+失败重试 先创建失败了就重试 TLAB 为每个线程在Eden初设一点内存，现在TLAB分配 当TLAB用完后，用CAS+失败重试 6.如何判断对象是否死亡：​ 如果没有任何一个对象引用该对象则判断为死亡（可达性方法） ​ （引用计数法）没引用一次加一取消引用减一；不好解决互相引用的问题； GCRoots有哪些？​ 虚拟机栈中引用的对象，本地方法栈中引用的对象 ​ 方法区中常量引用的对象，方法区中类静态属性引用的对象 7.如何判断常量是否无用，类是否无用？​ 常量无用：没有引用即可 ​ 类无用：该Class类没有被引用、没有该类的对象还在存活、该类的ClassLoader已经销毁 8.GC的算法有哪些？3种​ 标记-清除 （可以标记被清除的，也可以标记不被清除的）造成空间破碎 ​ 标记 复制 （可利用空间减半） ​ 标记 整理 老年代专用 9.常见的垃圾回收器​ 七个收集器（三个新生代 三个老年代 G1通吃） G1跳出了这个樊笼，它可以面向堆内存任 何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式 G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理 论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的 分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的 旧对象都能获取很好的收集效果。 两个支持低延迟垃圾收集器（ZGC 、 Sh。。。）以把垃圾收集的停顿时间限制在十毫秒以内的低延迟 10.HotSpot虚拟机实现：根节点枚举、安全点、写屏障","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://huajiaohuixiang.github.io/tags/JVM/"},{"name":"面试","slug":"面试","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"目标模块","slug":"目标模块","date":"2021-03-05T00:21:17.000Z","updated":"2021-03-07T02:36:32.530Z","comments":true,"path":"2021/03/05/目标模块/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/05/%E7%9B%AE%E6%A0%87%E6%A8%A1%E5%9D%97/","excerpt":"","text":"1.Lambda表达式2.Stream流计算3.函数式接口 4.多线程部分 5.JVM虚拟机","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"习概笔记","slug":"习概","date":"2021-03-04T01:13:38.000Z","updated":"2021-03-04T01:02:59.612Z","comments":true,"path":"2021/03/04/习概/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/04/%E4%B9%A0%E6%A6%82/","excerpt":"","text":"天下为私 大道之行也，天下为公； 今大道既隐，天下为家；","categories":[],"tags":[{"name":"习概","slug":"习概","permalink":"https://huajiaohuixiang.github.io/tags/%E4%B9%A0%E6%A6%82/"},{"name":"毛概","slug":"毛概","permalink":"https://huajiaohuixiang.github.io/tags/%E6%AF%9B%E6%A6%82/"}]},{"title":"单例模式的实现","slug":"单例模式的实现","date":"2021-03-02T08:45:02.000Z","updated":"2021-03-02T09:02:23.116Z","comments":true,"path":"2021/03/02/单例模式的实现/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"单例模式实现的六种方法1懒汉模式 获取时判断是否为null，然后创建 可能会出现线程安全问题，所以对他加上Synchronize 2.Synchronize修饰的get方法 速度会很慢，通过双重校验锁法来实现 3.双重校验锁法在get方法中，先判断是否为null，为空则加一个Synchronize代码块，里面还需要再判断一次，因为可能有多个线程同时阻塞在了这里，当第一个创建好后，没有判断的话还会创建其他的。 实例需要添加volatile修饰符 禁止指令重排序保证线程安全 4.饿汉模式直接在定义的时候就实现 5.静态内部类定义一个静态内部类 通过一个方法返回该内部类 实现了懒加载 6.枚举类实现https://cloud.tencent.com/developer/article/1497592","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"HashMap","slug":"HashMap","date":"2021-03-01T15:02:58.000Z","updated":"2021-03-02T07:02:01.617Z","comments":true,"path":"2021/03/01/HashMap/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/01/HashMap/","excerpt":"","text":"1.介绍1234567//Hash table based implementation of the &#123;@code Map&#125; interface. This//implementation provides all of the optional map operations, and permits//&#123;@code null&#125; values and the &#123;@code null&#125; key. public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; /* 实现*/&#125; HashMap继承于抽象Map类，抽象Map类为Map接口实现了一些操作 12//This implementation provides constant-time performance for the basic//operations (&#123;@code get&#125; and &#123;@code put&#125;), HasmMap实现了常量级的get和put操作实现。 12//An instance of &#123;@code HashMap&#125; has two parameters that affect its//performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;. HashMap是不同步的，可以在外面套一个 Collections.synchronizedMap来实现： 1Map m = Collections.synchronizedMap(new HashMap(...)); HashMap通常使用数组+链表的实现方式，当bins变得很大时，链表会变成红黑树，每一个bin都相当于TreeMap 123456789101112/** This map usually acts as a binned (bucketed) hash table, but* when bins get too large, they are transformed into bins of* TreeNodes, each structured similarly to those in* java.util.TreeMap. Most methods try to use normal bins, but* relay to TreeNode methods when applicable (simply by checking* instanceof a node). Bins of TreeNodes may be traversed and* used like any others, but additionally support faster lookup* when overpopulated. However, since the vast majority of bins in* normal use are not overpopulated, checking for existence of* tree bins may be delayed in the course of table methods. */ 2.一些参数fieldsDEFAULT_INITIAL_CAPACITY初始化容量，默认16，且必须是2的幂。（为何要2的幂，因为哈希函数为hash(key)&amp; capacity-1 这样就可以很快的确定位置（如果使用hash%数组大小的话也可以，但是会很慢）。https://www.iteye.com/topic/539465） MAXIMUM_CAPACITY 最大容量小于2^30。 DEFAULT_LOAD_FACTOR默认加载因子 0.75. TREEIFY_THRESHOLD 当bins中的节点大于其是会转化为红黑树 UNTREEIFY_THRESHOLD 小于其时会变成链表 MIN_TREEIFY_CAPACITY 最小表容量应大于4*TREEIFY_THRESHOLD 1234567891011121314151617181920212223242526272829303132333435363738394041/** * The default initial capacity - MUST be a power of two. */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64; 3.Node类 普通Node和TreNode123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 1234567891011static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; ...&#125; 4.类的静态方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static final int hash(Object key) &#123;//获得类的哈希值 右移16位 int h; //https://blog.csdn.net/qq_42034205/article/details/90384772 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;/** * Returns x&#x27;s Class if it is of the form &quot;class C implements * Comparable&lt;C&gt;&quot;, else null. */static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) &#123; for (Type t : ts) &#123; if ((t instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType) t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null;&#125;/** * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable * class), else 0. */@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // for cast to Comparablestatic int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x));&#125;/** * Returns a power of two size for the given target capacity. 检查所传的参数是否为2的幂次方，且不能为负数（负数变为1），且不能超过常量MAXIMUM_CAPACITY（超过变为MAXIMUM_CAPACITY），如果不为2的幂次方，将其变为，比cap大的最小的2的幂次方的值 */static final int tableSizeFor(int cap) &#123; int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1); return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 5.fieldsNode表transienthttps://www.cnblogs.com/lanxuezaipiao/p/3369962.html entrySet键值对集合当前数量size结构性修改的次数modcount123456789101112131415161718192021222324252627/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */transient Node&lt;K,V&gt;[] table;/** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/** * The number of key-value mappings contained in this map. */transient int size;/** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). */transient int modCount; threshold 当size&gt;threhold时变成红黑树。 加载因子，默认0.751234567891011121314151617/** * The next size value at which to resize (capacity * load factor). * * @serial */// (The javadoc description is true upon serialization.// Additionally, if the table array has not been allocated, this// field holds the initial array capacity, or zero signifying// DEFAULT_INITIAL_CAPACITY.)int threshold;/** * The load factor for the hash table. * * @serial */final float loadFactor; 6.构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Constructs an empty &#123;@code HashMap&#125; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;/** * Constructs an empty &#123;@code HashMap&#125; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/** * Constructs an empty &#123;@code HashMap&#125; with the default initial capacity * (16) and the default load factor (0.75). */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;/** * Constructs a new &#123;@code HashMap&#125; with the same mappings as the * specified &#123;@code Map&#125;. The &#123;@code HashMap&#125; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &#123;@code Map&#125;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125;/** * Implements Map.putAll and Map constructor. * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; 7.get方法123456789101112131415161718192021222324252627282930313233343536/**get()方法调用getNode方法，传入hash值和key值 */public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;/** * @param hash hash for key * @param key the key * @return the node, or null if none 如果 table不为空 table[(n - 1) &amp; hash]不为空，说明该点有值 判断第一个是不是，然后往下判断 如果是TreeNode类型，直接getTreeNode(); 否则链表往下判断； */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node &lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 8.put方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** 调用putVal方法，设置值或更新值 * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &#123;@code key&#125;, or * &#123;@code null&#125; if there was no mapping for &#123;@code key&#125;. * (A &#123;@code null&#125; return can also indicate that the map * previously associated &#123;@code null&#125; with &#123;@code key&#125;.) */public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;/** * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#x27;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0)//如果table为空，resize一下 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) //如果当前table中(n - 1) &amp; hash位置为空，则直接插入 tab[i] = newNode(hash, key, value, null); else &#123; //如果不为空，找到key的那个entry Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))//先判断第一个 e = p; //然后往下判断 else if (p instanceof TreeNode) //如果是Tree实现的，调用树的putTreeVal()方法 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//说明是链表实现的 循环判断 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; //查找后存在该点，更新值返回oldValue existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //走到这里说明原来table中没有带key的entry ，插入了一个新的，判断是否需要resize() ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 9.resize方法分为三步：获取原表、创建新表、为新表添加元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() &#123; //第一部分 Node&lt;K,V&gt;[] oldTab = table; //复制旧表 int oldCap = (oldTab == null) ? 0 : oldTab.length; //获得旧容量 int oldThr = threshold; //旧阈值 int newCap, newThr = 0; //新容量和新阈值 //第二部分 if (oldCap &gt; 0) &#123; //分支1 //说明原来表中有东西zMAX_VALUE //可能是添加的时候或者其他时调用了resize方法，然后将xin容量设置为原来的两倍且小于MAXIMUM_CAPACITY //对于阈值：如果本来的oldcap已经是MAXIMUM_CAPACITY，那么将阈值调为整数最大值，其实就是MAXIMUM_CAPACITY，这样不会再扩大容量，如果newcap还是小于MAXIMUM_CAPACITY，则也将新阈值*2 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold //分支2 //说明原来表里没有元素，但是还调用了resize，说明调用了带初始容量的构造方法 //只需要将新容量设置为旧的阈值，然后一会判断一下新阈值是否是0；如果是0，则将新阈值设置为容量*加载因子 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults //分支3 //到这里就是一开始是调用了无参构造方法，只需将容量阈值设置成默认的即可。 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //下面的对分支2没有设置新阈值的情况在判断一下，设置一下新阈值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; //第三部分 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//创建新Node数组 table = newTab; if (oldTab != null) &#123; //如果旧数组为空，则不需要复制；不为空就需要执行下面的赋值 for (int j = 0; j &lt; oldCap; ++j) &#123;//循环遍历数组 //判断下当前位置是否有值，没有则跳过，有就将旧的复制到新的里面 Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //HashMap使用数组+链表或者数组+红黑树，需要分三种情况讨论 if (e.next == null) //说明当前桶内只有一个节点，直接复制 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) //说明是TreeNode的情况 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order //链表的情况，而且由于新表是原表的两倍大。对于新表的哈希地址其实有两种情况，低位和高位，分别对应c1，c2 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; //c1 如果等于0 说明e.hash的第i位是0,因为oldcap的第i位是1，当我们把newcap=oldcap&lt;&lt;1时，e.hash&amp;newCap-1不会发生变化 //说明是要放在低位 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; //c2 //说明要放在高位 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; //将低位链表放在低位 loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; //将低位链表放在高位 hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 下面是TreeNode类的静态方法split，将某个树枝拆分为高位树枝和低位树枝 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125;&#125; 2021/3/2未完","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"HashTable","slug":"HashTable","date":"2021-03-01T14:59:01.000Z","updated":"2021-03-01T15:03:30.054Z","comments":true,"path":"2021/03/01/HashTable/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/03/01/HashTable/","excerpt":"","text":"12345public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; &#125; HashTable继承于Dictionary类，字典类是一个抽象类，而且已经被废弃了 12//NOTE: This class is obsolete. New implementations should//implement the Map interface, rather than extending this class. 对于Hashtable使用场景也很少，因为JDK中有一个和他类似的类，HashMap。 Hashtable和Hashmap的区别： 1(The &#123;@code HashMap&#125;class is roughly equivalent to &#123;@code Hashtable&#125;, except that it is unsynchronized and permits nulls.) HashTable比HashMap多了同步，少了对null的支持，，所以我们可以直接移步到HashMap。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Synchronize","slug":"Synchronize","date":"2021-02-25T08:53:35.000Z","updated":"2021-03-08T12:27:50.497Z","comments":true,"path":"2021/02/25/Synchronize/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/25/Synchronize/","excerpt":"","text":"Synchronized的用法https://blog.csdn.net/luoweifu/article/details/46613015 额外：同步与互斥的区别：https://www.cnblogs.com/baizhanshi/p/6844356.html 进程线程基础https://blog.csdn.net/luoweifu/article/details/46595285java中的 多线程https://blog.csdn.net/luoweifu/article/details/46673975 3/2更新 Synchronized的原理： 详细https://blog.csdn.net/javazejian/article/details/72828483 简单https://blog.csdn.net/u011212394/article/details/82228321 偏向锁、轻量锁、重量锁的升级 https://www.cnblogs.com/mcjhcnblogs/p/14226505.html","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"},{"name":"操作系统","slug":"操作系统","permalink":"https://huajiaohuixiang.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Ubuntu安装Redis、Mysql","slug":"安装Redis，Mysql","date":"2021-02-23T09:06:01.000Z","updated":"2021-02-23T14:40:35.719Z","comments":true,"path":"2021/02/23/安装Redis，Mysql/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/23/%E5%AE%89%E8%A3%85Redis%EF%BC%8CMysql/","excerpt":"","text":"Linux Ubuntu18.01安装redis和Mysql1.安装redis​ 12sudo apt-get updatesudo apt-get install redis-server 2.启动redis1redis-server 3.让其他电脑可以访问1dpkg -S redis_server 显示包含此软件包的所有位置， 有一个/etc/redis/redis.conf 文件 1sudo vim /etc/redis/redis.conf //打开 关闭保护模式并将127.0.0.1换成0.0.0.0 12bind 127.0.0.1 ::1 换成 bind 0.0.0.0 ::1protected-mode yes 换成 protected-mode no 保存退出重启 1sudo systemctl restart redis-server 1.安装Mysql12sudo apt install mysql-serversudo systemctl status mysql //安装完成后输入这个看看状态 2.然后可以根据阿里云的这个增加一下数据库安全https://yq.aliyun.com/articles/758177 3.配置外网访问12345678910cd /etc/mysql//然后ls一下 我的有下面这些东西，配置文件在mysql.conf.d中//conf.d debian-start my.cnf.fallback mysql.conf.d//debian.cnf my.cnf mysql.cnfcd mysql.conf.dvim mysqld.cnf //将地址127.0.0.1 改成0.0.0.0service mysql restart","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://huajiaohuixiang.github.io/tags/Ubuntu/"},{"name":"Redis","slug":"Redis","permalink":"https://huajiaohuixiang.github.io/tags/Redis/"},{"name":"Mysql","slug":"Mysql","permalink":"https://huajiaohuixiang.github.io/tags/Mysql/"}]},{"title":"拦截器","slug":"拦截器","date":"2021-02-23T09:06:01.000Z","updated":"2021-02-23T14:40:41.641Z","comments":true,"path":"2021/02/23/拦截器/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/23/%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"SpringBoot配置拦截器1.实现一个拦截器12345678910111213141516171819202122实现HandlerInterceptor重写preHandle方法，postHandler，afterCompletion方法public class testInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //这里就可以根据request判断token session等等。 System.out.println(&quot;进入拦截器啦！&quot;); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;Bye!&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(&quot;执行了TestInterceptor的afterCompletion方法&quot;); &#125;&#125; 2.将拦截器配置到SpringBoot程序中，在Spring中，使用XML的方式，而在Boot中只需要定义一个带有@Configuration的配置类即可，需要实现WebMvcConfigure接口 123456789101112@Configurationpublic class testMvcConfigure implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; InterceptorRegistration registration = registry.addInterceptor(new testInterceptor()); registration.addPathPatterns(&quot;/**&quot;); //所有路径都被拦截 registration.excludePathPatterns( //添加不拦截路径 &quot;/vip/wang&quot; ); &#125;&#125;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://huajiaohuixiang.github.io/tags/SpringBoot/"}]},{"title":"剑指offer38","slug":"剑指offer38","date":"2021-02-23T02:40:18.000Z","updated":"2021-02-23T05:37:18.152Z","comments":true,"path":"2021/02/23/剑指offer38/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/23/%E5%89%91%E6%8C%87offer38/","excerpt":"","text":"输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例: 输入：s = “abc”输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”] 一开始的做法，回溯法模拟了一遍全排列； 123456789101112131415161718192021222324252627282930class Solution &#123; vector&lt;bool&gt; used;public: vector&lt;string&gt; permutation(string s) &#123; vector&lt;string&gt; result; unordered_set&lt;string&gt; tempResult;//因为字符串中可能有重复的元素，所以用了它去重 string temp=&quot;&quot;; for(auto c:s)&#123;used.push_back(false);&#125; huiSu(tempResult,s,temp); for(auto c:tempResult)&#123; result.push_back(c); &#125; return result; &#125; void huiSu(unordered_set&lt;string&gt;&amp; result,string&amp; s,string&amp; temp)&#123; if(temp.length()==s.length())&#123; result.insert(temp); &#125; for(int j=0;j&lt;s.length();j++)&#123; if(used[j])&#123; continue; &#125; temp.push_back(s[j]); used[j]=true; huiSu(result,s,temp); used[j]=false; temp.pop_back(); &#125; &#125;&#125;; 对于有重复元素的情况，我使用了set集合先把所有的结果加进去，然后再返回到vector中 还可以先将字符串排序，排序后相同的元素在一起，然后把他们看成一个即可。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;string&gt;res; void backtrack(string s,string&amp; temp,vector&lt;bool&gt;&amp; used) &#123; if(temp.size()==s.size()) &#123; res.push_back(temp); return; &#125; for(int i=0;i&lt;s.size();i++) &#123; if(!used[i]) &#123; if(i&gt;=1&amp;&amp;s[i-1]==s[i]&amp;&amp;!used[i-1]) continue; temp.push_back(s[i]); used[i]=true; backtrack(s,temp,used); used[i]=false; temp.pop_back(); &#125; &#125; &#125; vector&lt;string&gt; permutation(string s) &#123; if(s.size()==0) return&#123;&#125;; string temp=&quot;&quot;; sort(s.begin(),s.end()); vector&lt;bool&gt;used(s.size()); backtrack(s,temp,used); return res; &#125;&#125;; 进行通过字符交换来实现全排列,然后使用unordered_set去重（这个去重与上面的作用完全不一样），如果某个已经交换过了，就不用在交换了 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; permutation(string s) &#123; vector&lt;string&gt; res; dfs(s, res, 0); return res; &#125; void dfs(string &amp;s, vector&lt;string&gt; &amp;res, int depth) &#123; if(depth &gt;= s.size()-1) &#123; res.push_back(s); return ; &#125; unordered_set&lt;char&gt; used; //局部set去重 for(int i = depth; i &lt; s.size(); ++i) &#123; if(used.find(s[i]) != used.end()) continue; //去重 used.insert(s[i]); swap(s[depth],s[i]); dfs(s, res, depth+1); swap(s[depth],s[i]); //回溯撤销操作 &#125; &#125;&#125;;作者：zrita链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/chui-su-z-by-zrita-gvc0/","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://huajiaohuixiang.github.io/tags/leetcode/"}]},{"title":"Lambda","slug":"Lambda","date":"2021-02-22T09:07:05.000Z","updated":"2021-02-22T09:07:05.357Z","comments":true,"path":"2021/02/22/Lambda/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/22/Lambda/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"maven","slug":"maven","date":"2021-02-22T09:06:43.000Z","updated":"2021-02-22T09:06:43.134Z","comments":true,"path":"2021/02/22/maven/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/22/maven/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"单元测试","slug":"单元测试","date":"2021-02-22T09:06:17.000Z","updated":"2021-02-22T09:06:17.250Z","comments":true,"path":"2021/02/22/单元测试/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/22/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"集合","slug":"集合","date":"2021-02-22T09:06:01.000Z","updated":"2021-02-22T09:06:01.078Z","comments":true,"path":"2021/02/22/集合/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/22/%E9%9B%86%E5%90%88/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"异常错误","slug":"异常","date":"2021-02-22T06:09:06.000Z","updated":"2021-03-11T06:39:20.888Z","comments":true,"path":"2021/02/22/异常/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/22/%E5%BC%82%E5%B8%B8/","excerpt":"","text":"1.异常和错误都是类，基类Throwable 只实现了序列化接口。123public class Throwable implements Serializable &#123; ...&#125; 2.printStackTrace() 1234567891011121314151617181920212223242526272829303132public void printStackTrace() &#123; printStackTrace(System.err);&#125;public void printStackTrace(PrintStream s) &#123; printStackTrace(new WrappedPrintStream(s));&#125;private void printStackTrace(PrintStreamOrWriter s) &#123; // Guard against malicious overrides of Throwable.equals by // using a Set with identity equality semantics. Set&lt;Throwable&gt; dejaVu = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;()); dejaVu.add(this); synchronized (s.lock()) &#123; // Print our stack trace s.println(this); StackTraceElement[] trace = getOurStackTrace(); for (StackTraceElement traceElement : trace) s.println(&quot;\\tat &quot; + traceElement); // Print suppressed exceptions, if any for (Throwable se : getSuppressed()) se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, &quot;\\t&quot;, dejaVu); // Print cause, if any Throwable ourCause = getCause(); if (ourCause != null) ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, &quot;&quot;, dejaVu); &#125;&#125; 3.捕获异常 (都很熟悉)12345678try&#123;&#125;catch(IOException e1)&#123; e1.printStackTrace();&#125;catch(Exception e2)&#123; e2.printStackTrace();&#125;finally&#123; //&#125; 4.抛出异常12345//使用throw + 异常对象Exception exception2=new Exception();throw exception2;或者throw new Exception(); 5.Java异常体系Java标准库定义的常用异常包括： 1234567891011121314151617181920212223242526272829Exception│├─ RuntimeException│ ││ ├─ NullPointerException│ ││ ├─ IndexOutOfBoundsException│ ││ ├─ SecurityException│ ││ └─ IllegalArgumentException│ ││ └─ NumberFormatException│├─ IOException│ ││ ├─ UnsupportedCharsetException│ ││ ├─ FileNotFoundException│ ││ └─ SocketException│├─ ParseException│├─ GeneralSecurityException│├─ SQLException│└─ TimeoutException 6.assert关键字assert用来开发的时候使用，如果断言失败会抛出异常 12assert x&gt;0; assert x&gt;=0 : &quot;x must &gt;= 0&quot;; JVM默认关闭断言，开启断言需要编译时额外参数，实际上一般不用断言，都是使用JUnit。 7.使用Logger日志系统代替System.out.println()12345Logger logger = Logger.getGlobal();logger.info(&quot;start process...&quot;);logger.warning(&quot;memory is running out...&quot;);logger.fine(&quot;ignored.&quot;);logger.severe(&quot;process will be terminated...&quot;); logger一共有七个等级 SEVERE WARNING INFO CONFIG FINE FINER FINEST Config和下面的都不会打印出来。 实际上一般也不用，也需要额外的参数。 8.日志库Commons LoggingCommons Logging定义了6个日志级别： FATAL ERROR WARNING INFO DEBUG TRACE 使用的话Log log = LogFactory.getLog(Class名); 9.广泛使用的Log4j日志系统，xml配置麻烦，搭配SpringBoot应该会简单吧10.和89对应的分别是SLF4J和Logback","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"StringBuffer和StringBuilder","slug":"StringBuffer","date":"2021-02-21T02:47:49.000Z","updated":"2021-02-21T15:12:53.609Z","comments":true,"path":"2021/02/21/StringBuffer/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/21/StringBuffer/","excerpt":"","text":"首先两者继承的类，实现的接口都是一模一样，所提供的接口也是完全相同，不同的是StringBuffer是线程安全的，StringBuilder是不安全的。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"内部类","slug":"内部类","date":"2021-02-21T02:47:49.000Z","updated":"2021-02-21T15:10:35.584Z","comments":true,"path":"2021/02/21/内部类/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/21/%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"参考：https://www.liaoxuefeng.com/wiki/1252599548343744/1376414781669409 嵌套类分为三种内部类 ,匿名类，静态内部类 InnerClass和匿名类本质上相同，都需要依靠外部类才能实现，静态内部类不需要依赖外部类。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"多态","slug":"多态","date":"2021-02-21T02:47:49.000Z","updated":"2021-02-21T14:33:08.729Z","comments":true,"path":"2021/02/21/多态/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/21/%E5%A4%9A%E6%80%81/","excerpt":"","text":"多态：对于某个类型的方法调用，实际调用的方法取决于运行时实际类型的方法。 12345678910111213141516171819202122public void run(Person p)&#123; p.run();&#125;Class Person&#123; void run()&#123; System.out.println(&quot;Person&quot;); &#125;&#125;Class Teacher extends Person&#123; @override void run()&#123; System.out.println(&quot;Teacher&quot;); &#125;&#125;public static void main(String [] args)&#123; Person p1=new Person(); Person p2=new Teacher(); run(p1); run(p2);&#125; 以上代码分别会打印各自的run ， 因为两者的实际类型不同，通过声明类型传值","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"枚举类","slug":"枚举类","date":"2021-02-21T02:47:49.000Z","updated":"2021-03-02T08:43:06.412Z","comments":true,"path":"2021/02/21/枚举类/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/21/%E6%9E%9A%E4%B8%BE%E7%B1%BB/","excerpt":"","text":"枚举类我们可以使用这种方式来实现枚举类： 12345public class Weekday&#123; public static final int MON=1; public static final int Tu=2; ...&#125; 虽然可以实现，但是在使用的时候会出现问题，编译器不能检测出不在类中的值。 1234int day=0;if(day==Weekday.MON)&#123; ...&#125; 所以我们用enum来实现枚举类:(编译器会将他们编译成final class Weekday extends Enum{…}) 123enum Weekday&#123; MON,Tue,Wed,Thur,Fri,Sat,Sun;&#125; 与enum类似的还有record类 14后才有。 用enum实现单例模式","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"模块","slug":"模块","date":"2021-02-21T02:47:49.000Z","updated":"2021-02-21T14:33:07.744Z","comments":true,"path":"2021/02/21/模块/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/21/%E6%A8%A1%E5%9D%97/","excerpt":"","text":"java模块 参考资料：https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"修饰符","slug":"4修饰符","date":"2021-02-21T02:31:04.000Z","updated":"2021-02-21T05:45:53.537Z","comments":true,"path":"2021/02/21/4修饰符/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/21/4%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"1.private 只能自己访问，子类extends后也不能访问 protected 子类可以访问 默认的（无） 同一个包内 public 所有都可以访问 继承关系final 该类不能被继承 sealed + permits 指定某些类继承 123public sealed class Shape permits a,b,c&#123; ...&#125; interface接口的default方法因为接口没有字段，所以接口无法定义非抽象的函数，这时候需要default修饰符来实现default方法，可以给予实现。default方法的目的主要是因为如果想往接口中增加一个方法但是又会影响所有实现接口的类都要实现该新增的方法，使用default便可以不影响所有类。 staticstatic fields​ 静态字段 ​ 对于接口来说是不能拥有fields的，但是如果你直接写 int a;是不会报错的，因为编译器自动将其转换为了static final int a; static methods​ 静态方法主要用于工具方法和辅助方法，例如： 123Arrays.sort();public static void main()&#123;...&#125;;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-ArrayList","slug":"ArrayList","date":"2021-02-20T06:13:38.000Z","updated":"2021-03-08T01:24:53.143Z","comments":true,"path":"2021/02/20/ArrayList/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/20/ArrayList/","excerpt":"","text":"JDK8版本 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList 数组列表，分别实现了列表、随机访问、可克隆、序列化，继承了抽象列表,其关系如下所示： 1.几个参数12345678910111213141516private static final long serialVersionUID = 8683452581122892189L;private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData; // non-private to simplify nested class accessprivate int size; 2.主要方法构造方法如果是ArrayList arrayList=new ArrayList(20);只初始化了一次，算没扩容吧。 123456789101112131415public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 传入另一个集合，先将collection转为数组，然后copy到elementData中 123456789101112public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 3.trimToSize()修剪大小到size12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 4. 增加容量（这个是给用户调用的，ArrayList内部没有调用）如果要大批量插入数据，那么调用该函数主动增加容量 123456789public void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; elementData.length &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123; modCount++; grow(minCapacity); &#125;&#125;用到了grow() ,newCapacity(minCapacity) ,hugeCapacity(int minCapacity)方法 5.得到O地址1234567891011121314151617int indexOfRange(Object o, int start, int end) &#123; Object[] es = elementData; if (o == null) &#123; for (int i = start; i &lt; end; i++) &#123; if (es[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; end; i++) &#123; if (o.equals(es[i])) &#123; return i; &#125; &#125; &#125; return -1;&#125; 6.扩容​ JDK11去掉了 add方法 1234567891011/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; modCount++; add(e, elementData, size); return true;&#125; 1234567891011/** * This helper method split out from add(E) to keep method * bytecode size under 35 (the -XX:MaxInlineSize default value), * which helps when add(E) is called in a C1-compiled loop. */private void add(E e, Object[] elementData, int s) &#123; if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1;&#125; 推荐阅读https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90?id=_1-arraylist-%e7%ae%80%e4%bb%8b","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-LinkedList","slug":"LinkedList","date":"2021-02-20T06:13:38.000Z","updated":"2021-02-20T15:43:54.898Z","comments":true,"path":"2021/02/20/LinkedList/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/20/LinkedList/","excerpt":"","text":"123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 比ArrayList多实现了Queue和Deque 即实现了双向队列，ArrayList直接继承AbstractList，LinkedList继承于AbstractSequentialList,即顺序访问，AbstractList适合随机访问。 LinkedList底层就是链表实现，有内部类Node ，然后又first节点、last节点。 1234567891011transient int size = 0;/** * Pointer to first node. */transient Node&lt;E&gt; first;/** * Pointer to last node. */transient Node&lt;E&gt; last; Node类，item内容，前指针和后指针，双向链表 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 剩下的就是对链表的一些操作以及toArray等等。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-List","slug":"List","date":"2021-02-20T06:13:38.000Z","updated":"2021-02-20T14:31:21.203Z","comments":true,"path":"2021/02/20/List/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/20/List/","excerpt":"","text":"List接口实现了Collection接口，主要有以下函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195//返回大小int size();//判空boolean isEmpty();//判断是否包含boolean contains(Object o);Iterator&lt;E&gt; iterator();Object[] toArray();&lt;T&gt; T[] toArray(T[] a);boolean add(E e);boolean remove(Object o);boolean containsAll(Collection&lt;?&gt; c);boolean addAll(Collection&lt;? extends E&gt; c);boolean addAll(int index, Collection&lt;? extends E&gt; c);boolean removeAll(Collection&lt;?&gt; c);//删除掉不在c中的元素boolean retainAll(Collection&lt;?&gt; c);default void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final ListIterator&lt;E&gt; li = this.listIterator(); while (li.hasNext()) &#123; li.set(operator.apply(li.next())); &#125;&#125;@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125;void clear();boolean equals(Object o);int hashCode();//下面是比Collection多的方法E get(int index);E set(int index, E element);void add(int index, E element);E remove(int index);int indexOf(Object o);int lastIndexOf(Object o);// List IteratorsListIterator&lt;E&gt; listIterator();ListIterator&lt;E&gt; listIterator(int index);// ViewList&lt;E&gt; subList(int fromIndex, int toIndex);//重写了Collection的可分割迭代器@Overridedefault Spliterator&lt;E&gt; spliterator() &#123; if (this instanceof RandomAccess) &#123; return new AbstractList.RandomAccessSpliterator&lt;&gt;(this); &#125; else &#123; return Spliterators.spliterator(this, Spliterator.ORDERED); &#125;&#125;//下面的暂时还没看static &lt;E&gt; List&lt;E&gt; of() &#123; return ImmutableCollections.emptyList();&#125;static &lt;E&gt; List&lt;E&gt; of(E e1) &#123; return new ImmutableCollections.List12&lt;&gt;(e1);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2) &#123; return new ImmutableCollections.List12&lt;&gt;(e1, e2);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9);&#125;static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);&#125;@SafeVarargs@SuppressWarnings(&quot;varargs&quot;)static &lt;E&gt; List&lt;E&gt; of(E... elements) &#123; switch (elements.length) &#123; // implicit null check of elements case 0: return ImmutableCollections.emptyList(); case 1: return new ImmutableCollections.List12&lt;&gt;(elements[0]); case 2: return new ImmutableCollections.List12&lt;&gt;(elements[0], elements[1]); default: return new ImmutableCollections.ListN&lt;&gt;(elements); &#125;&#125;static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) &#123; return ImmutableCollections.listCopy(coll);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-transient","slug":"transient","date":"2021-02-20T06:13:38.000Z","updated":"2021-02-21T02:02:38.090Z","comments":true,"path":"2021/02/20/transient/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/20/transient/","excerpt":"","text":"参考资料https://www.cnblogs.com/lanxuezaipiao/p/3369962.html https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698 在java中，只要实现了java.io.Serializable接口，该类就可以序列化。 transient关键字用来标明不想序列化的某个属性，例如在ArrayList源码中，elementData就不想被序列化，则使用了transient。 12345678910public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; // non-private to simplify nested class access ...&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-Collection","slug":"Collection","date":"2021-02-20T02:45:38.000Z","updated":"2021-02-20T11:50:04.804Z","comments":true,"path":"2021/02/20/Collection/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/20/Collection/","excerpt":"","text":"interface Collection集合层次结构中的根接口。集合代表一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。有些是有序的，而另一些则是无序的。JDK不提供 此接口的任何直接实现：它提供了更多特定子接口的实现，例如{@code Set}和{@code List}。该接口通常用于传递集合并在需要最大通用性的地方操纵它们。 Bags或multisets（可能包含重复元素的无序集合）应直接实现此接口。 所有通用的{@code Collection}实现类（通常通过其子接口之一间接实现{@code Collection}）应提供两个“标准”构造函数：void（无自变量）构造函数，该构造函数创建一个空的集合，以及一个带有单个实参类型为{@code Collection}的构造函数，该构造函数创建一个新集合，其元素与实参相同。实际上，后一个构造函数允许用户复制任何集合，从而产生所需实现类型的等效集合。没有强制执行此约定的方法（因为接口不能包含构造函数），但是Java平台库中的所有通用{@code Collection} 实现都可以遵循。 12345678910@see Set@see List@see SortedSet@see HashSet@see TreeSet@see ArrayList@see LinkedList@see Vector@see AbstractCollection // 以上这些实现了Collection接口 方法解析1.size()返回集合大小 12345678/** * Returns the number of elements in this collection. If this collection * contains more than &#123;@code Integer.MAX_VALUE&#125; elements, returns * &#123;@code Integer.MAX_VALUE&#125;. * * @return the number of elements in this collection */int size(); 2.isEmpty() 123456/** * Returns &#123;@code true&#125; if this collection contains no elements. * * @return &#123;@code true&#125; if this collection contains no elements */boolean isEmpty(); 3.contains(Object o) 123456789101112131415161718/** * Returns &#123;@code true&#125; if this collection contains the specified element. * More formally, returns &#123;@code true&#125; if and only if this collection * contains at least one element &#123;@code e&#125; such that * &#123;@code Objects.equals(o, e)&#125;. * * @param o element whose presence in this collection is to be tested * @return &#123;@code true&#125; if this collection contains the specified * element * @throws ClassCastException if the type of the specified element * is incompatible with this collection * (&lt;a href=&quot;&#123;@docRoot&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified element is null and this * collection does not permit null elements * (&lt;a href=&quot;&#123;@docRoot&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) */boolean contains(Object o); 4.iterator()返回一个迭代器 123456789/** * Returns an iterator over the elements in this collection. There are no * guarantees concerning the order in which the elements are returned * (unless this collection is an instance of some class that provides a * guarantee). * * @return an &#123;@code Iterator&#125; over the elements in this collection */Iterator&lt;E&gt; iterator(); 5.toArray()转换成数组 12345678Object[] toArray();&lt;T&gt; T[] toArray(T[] a);default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) &#123; return toArray(generator.apply(0));&#125; 6.add()添加元素 1boolean add(E e); 7.去除元素 1boolean remove(Object o); 8.containAll()返回是否包含该集合的所有元素 12345678910111213141516171819/** * Returns &#123;@code true&#125; if this collection contains all of the elements * in the specified collection. * * @param c collection to be checked for containment in this collection * @return &#123;@code true&#125; if this collection contains all of the elements * in the specified collection * @throws ClassCastException if the types of one or more elements * in the specified collection are incompatible with this * collection * (&lt;a href=&quot;&#123;@docRoot&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified collection contains one * or more null elements and this collection does not permit null * elements * (&lt;a href=&quot;&#123;@docRoot&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null. * @see #contains(Object) */boolean containsAll(Collection&lt;?&gt; c); 9.addALL() 1boolean addAll(Collection&lt;? extends E&gt; c); 10.removeAll 1boolean removeAll(Collection&lt;?&gt; c); 11.removesif()去除所有符合条件的元素 12345678910111213default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed;&#125; 12.retainAll()去除所有不在c中的元素 12345678910boolean retainAll(Collection&lt;?&gt; c);/** * Removes all of the elements from this collection (optional operation). * The collection will be empty after this method returns. * * @throws UnsupportedOperationException if the &#123;@code clear&#125; operation * is not supported by this collection */ 13.clear()清楚所有 1void clear(); 14.equals和hashcode 15.可分割迭代器 1234@Overridedefault Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, 0);&#125; 16.Stream 获得流 1234//这个是串行流default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。 Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 123+--------------------+ +------+ +------+ +---+ +-------+| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|+--------------------+ +------+ +------+ +---+ +-------+ 以上的流程转换为 Java 代码为： 123456List&lt;Integer&gt; transactionsIds = widgets.stream() .filter(b -&gt; b.getColor() == RED) .sorted((x,y) -&gt; x.getWeight() - y.getWeight()) .mapToInt(Widget::getWeight) .sum(); 参考https://www.runoob.com/java/java8-streams.html 17.获得并行流 1234//并行流default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-Iterable","slug":"Iterable","date":"2021-02-20T02:45:38.000Z","updated":"2021-02-20T11:23:39.393Z","comments":true,"path":"2021/02/20/Iterable/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/20/Iterable/","excerpt":"","text":"interface Iterable介绍1234567* Implementing this interface allows an object to be the target of the enhanced* &#123;@code for&#125; statement (sometimes called the &quot;for-each loop&quot; statement).** @param &lt;T&gt; the type of elements returned by the iterator** @since 1.5* @jls 14.14.2 The enhanced &#123;@code for&#125; statement 实现此接口允许一个对象成为增强for语句的目标,就是下面这样。 123456789a.forEach( new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) &#123; &#125; &#125;); 构造函数123456/** * Returns an iterator over elements of type &#123;@code T&#125;. * * @return an Iterator. */Iterator&lt;T&gt; iterator(); forEach()函数，重点12345678910111213141516171819202122232425262728/** * Performs the given action for each element of the &#123;@code Iterable&#125; * until all elements have been processed or the action throws an * exception. Actions are performed in the order of iteration, if that * order is specified. Exceptions thrown by the action are relayed to the * caller. * &lt;p&gt; * The behavior of this method is unspecified if the action performs * side-effects that modify the underlying source of elements, unless an * overriding class has specified a concurrent modification policy. * * @implSpec * &lt;p&gt;The default implementation behaves as if: * &lt;pre&gt;&#123;@code * for (T t : this) * action.accept(t); * &#125;&lt;/pre&gt; * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; 使用的话可以通过匿名类、lamda表达式、现有方法的名称。 Spliterator spliterator()Spliterator是一个可分割迭代器(splitable iterator)，可以和iterator顺序遍历迭代器一起看。jdk1.8发布后，对于并行处理的能力大大增强，Spliterator就是为了并行遍历元素而设计的一个迭代器。 123456789101112131415161718192021222324/** * Creates a &#123;@link Spliterator&#125; over the elements described by this * &#123;@code Iterable&#125;. * * @implSpec * The default implementation creates an * &lt;em&gt;&lt;a href=&quot;../util/Spliterator.html#binding&quot;&gt;early-binding&lt;/a&gt;&lt;/em&gt; * spliterator from the iterable&#x27;s &#123;@code Iterator&#125;. The spliterator * inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterable&#x27;s iterator. * * @implNote * The default implementation should usually be overridden. The * spliterator returned by the default implementation has poor splitting * capabilities, is unsized, and does not report any spliterator * characteristics. Implementing classes can nearly always provide a * better implementation. * * @return a &#123;@code Spliterator&#125; over the elements described by this * &#123;@code Iterable&#125;. * @since 1.8 */default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-Reference","slug":"四种引用","date":"2021-02-20T02:45:38.000Z","updated":"2021-02-20T02:45:23.608Z","comments":true,"path":"2021/02/20/四种引用/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/20/%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/","excerpt":"","text":"Java四种引用：强引用、软引用、弱引用、虚引用 强引用：new一个对象就是强引用，可以通过赋null来取消引用，被强引用的对象永远都不会被回收即使Out of memory。 软引用：SoftReference，被软引用的对象将会在内存不够用时被GC回收 弱引用：WeakReference，将会在下一轮GC被回收，如果对象有finalize()，将会先执行finalize()，然后再回收，这时可能会延后一个GC 虚引用：用来标记对象是否要回收，如果一个对象只有虚引用，那么将会回收 参考：https://zhanghaoxin.blog.csdn.net/article/details/80991802 ​ https://www.cnblogs.com/skywang12345/p/3154474.html","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Kinect获取 骨骼图骨骼三维坐标","slug":"Kinect获取-骨骼图骨骼三维坐标","date":"2021-02-19T14:14:50.000Z","updated":"2021-02-19T15:21:19.631Z","comments":true,"path":"2021/02/19/Kinect获取-骨骼图骨骼三维坐标/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/19/Kinect%E8%8E%B7%E5%8F%96-%E9%AA%A8%E9%AA%BC%E5%9B%BE%E9%AA%A8%E9%AA%BC%E4%B8%89%E7%BB%B4%E5%9D%90%E6%A0%87/","excerpt":"","text":"Kinect获取 骨骼图骨骼三维坐标该项目需要我们利用KinectV2 获取骨骼图并得到头部坐标，每一秒取一帧，一共五分钟，将坐标输出。 KinectV2 可以获得色彩图、深度图、骨骼图等等，其实一开始我也不知道该从哪里下手，但对骨骼图的代码进行了一下分析找到了突破点。 对KinectV2大体了解：Kinect一共有三个坐标空间，分别是相机空间、深度空间、色彩空间，相机空间对应骨骼图等，深度空间对应深度图，色彩空间对应色彩图，并且KInectSDK中有CoordinateMapper类来实现深度空间到相机空间和深度空间到色彩空间的转换。具体查看官方文档：https://docs.microsoft.com/en-us/previous-versions/windows/kinect/dn785530(v=ieb.10) 重点需要关心获取的帧的数据如何存储的，对于骨骼图，SDK中有两个重要的类分别是IBody 和 Joint 分别代表人和骨骼点。 1234567891011121314151617IBody : public IUnknown &#123; public: virtual HRESULT STDMETHODCALLTYPE GetJoints( /* [annotation] */ _Pre_equal_to_(JointType_Count) UINT capacity, /* [annotation][size_is][out] */ _Out_writes_all_(capacity) Joint *joints) = 0; ... virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsTracked( /* [annotation][out][retval] */ _Out_ BOOLEAN *tracked) = 0; ... &#125;; 分别利用GetJoints函数和get_IsTracked函数可以获得Joints和判断是否被记录到了。 对于Joints 12345678910#ifndef _Joint_#define _Joint_typedef struct _Joint &#123; JointType JointType; CameraSpacePoint Position; TrackingState TrackingState; &#125; Joint;#endif // _Joint_ 一个struct 里面有Joint类型、相机空间位置、追踪状态（是否被观测到），接着往里看CameSpacePoint 12345678910#ifndef _CameraSpacePoint_#define _CameraSpacePoint_typedef struct _CameraSpacePoint &#123; float X; float Y; float Z; &#125; CameraSpacePoint;#endif // _CameraSpacePoint_ 到这里就很清楚了，直接就可以得到相机空间地址了。（本来我以为需要先获得深度图地址，然后自己进行坐标计算的。。。） 然后SDK还定义了一下常量和其他类，在这里贴一下以防看代码的时候不懂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566enum _JointType &#123; JointType_SpineBase = 0, JointType_SpineMid = 1, JointType_Neck = 2, JointType_Head = 3, JointType_ShoulderLeft = 4, JointType_ElbowLeft = 5, JointType_WristLeft = 6, JointType_HandLeft = 7, JointType_ShoulderRight = 8, JointType_ElbowRight = 9, JointType_WristRight = 10, JointType_HandRight = 11, JointType_HipLeft = 12, JointType_KneeLeft = 13, JointType_AnkleLeft = 14, JointType_FootLeft = 15, JointType_HipRight = 16, JointType_KneeRight = 17, JointType_AnkleRight = 18, JointType_FootRight = 19, JointType_SpineShoulder = 20, JointType_HandTipLeft = 21, JointType_ThumbLeft = 22, JointType_HandTipRight = 23, JointType_ThumbRight = 24, JointType_Count = ( JointType_ThumbRight + 1 ) &#125; ;#endif // _JointType_#ifndef _TrackingState_#define _TrackingState_typedef enum _TrackingState TrackingState;enum _TrackingState &#123; TrackingState_NotTracked = 0, TrackingState_Inferred = 1, TrackingState_Tracked = 2 &#125; ;#endif // _TrackingState_ IBodyFrame : public IUnknown &#123; public: virtual HRESULT STDMETHODCALLTYPE GetAndRefreshBodyData( UINT capacity, /* [annotation][size_is][out][in] */ _Inout_updates_all_(capacity) IBody **bodies) = 0; virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FloorClipPlane( /* [annotation][out][retval] */ _Out_ Vector4 *floorClipPlane) = 0; virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RelativeTime( /* [annotation][out][retval] */ _Out_ TIMESPAN *relativeTime) = 0; virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BodyFrameSource( /* [annotation][out][retval] */ _COM_Outptr_ IBodyFrameSource **bodyFrameSource) = 0; &#125;; 下面是项目代码的详细步骤： 第一步需要安装Kinect 的SDK，然后再Visual Studio进行项目配置，具体可以参考一下文章： https://blog.csdn.net/lizhiguo18/article/details/51037672 https://blog.csdn.net/weixin_43850620/article/details/103874847 对项目配置好后就可以写代码啦。 1.这一步应该是获取Kinect，然后打开。 123IKinectSensor * mySensor = nullptr;GetDefaultKinectSensor(&amp;mySensor);mySensor-&gt;Open(); 2.准备读取ColorFrame 1234567891011 IColorFrameSource * myColorSource = nullptr;mySensor-&gt;get_ColorFrameSource(&amp;myColorSource);IColorFrameReader * myColorReader = nullptr;myColorSource-&gt;OpenReader(&amp;myColorReader);int colorHeight = 0, colorWidth = 0;IFrameDescription * myDescription = nullptr;myColorSource-&gt;get_FrameDescription(&amp;myDescription);myDescription-&gt;get_Height(&amp;colorHeight);myDescription-&gt;get_Width(&amp;colorWidth);IColorFrame * myColorFrame = nullptr;Mat original(colorHeight, colorWidth, CV_8UC4); 3.准备读取BodyFrame 123456789 IBodyFrameSource * myBodySource = nullptr;mySensor-&gt;get_BodyFrameSource(&amp;myBodySource);IBodyFrameReader * myBodyReader = nullptr;myBodySource-&gt;OpenReader(&amp;myBodyReader);int myBodyCount = 0;myBodySource-&gt;get_BodyCount(&amp;myBodyCount);IBodyFrame * myBodyFrame = nullptr;ICoordinateMapper * myMapper = nullptr;mySensor-&gt;get_CoordinateMapper(&amp;myMapper); 4.每30帧获取一帧然后输出 123456789101112131415161718192021222324252627282930313233343536373839 int fps = 0;while (1)&#123; while (myColorReader-&gt;AcquireLatestFrame(&amp;myColorFrame) != S_OK); myColorFrame-&gt;CopyConvertedFrameDataToArray(colorHeight * colorWidth * 4, original.data, ColorImageFormat_Bgra); Mat copy = original.clone(); //读取彩色图像并输出到矩阵 while (myBodyReader-&gt;AcquireLatestFrame(&amp;myBodyFrame) != S_OK); //读取身体图像 IBody ** myBodyArr = new IBody *[myBodyCount]; //为存身体数据的数组做准备 if (fps != 0) &#123; fps++; fps = fps % 30; delete[]myBodyArr; myBodyFrame-&gt;Release(); myColorFrame-&gt;Release(); continue; &#125; fps++; for (int i = 0; i &lt; myBodyCount; i++) myBodyArr[i] = nullptr; if (myBodyFrame-&gt;GetAndRefreshBodyData(myBodyCount, myBodyArr) == S_OK) //把身体数据输入数组 for (int i = 0; i &lt; myBodyCount; i++) &#123; BOOLEAN result = false; if (myBodyArr[i]-&gt;get_IsTracked(&amp;result) == S_OK &amp;&amp; result) //先判断是否侦测到 &#123; Joint myJointArr[JointType_Count]; if (myBodyArr[i]-&gt;GetJoints(JointType_Count, myJointArr) == S_OK) &#123; draw(copy, myJointArr[JointType_Head], myJointArr[JointType_Neck], myMapper); &#125; &#125; &#125; delete[]myBodyArr; myBodyFrame-&gt;Release(); myColorFrame-&gt;Release(); if (countFrame == 330) &#123; break; &#125; &#125; 5.关闭Kinect并退出 123456789myMapper-&gt;Release();myDescription-&gt;Release();myColorReader-&gt;Release();myColorSource-&gt;Release();myBodyReader-&gt;Release();myBodySource-&gt;Release();mySensor-&gt;Close();mySensor-&gt;Release();return 0; 6.函数draw() ​ 获取时间然后直接输出坐标。 123456789101112131415161718192021void draw(Mat &amp; img, Joint &amp; r_1, Joint &amp; r_2, ICoordinateMapper * myMapper)&#123; countFrame++; if (r_1.TrackingState &#x3D;&#x3D; TrackingState_Tracked ) &#123; now &#x3D; clock(); ofstream fout(&quot;01.txt&quot;, ios::app); cout &lt;&lt; now; cout &lt;&lt; r_1.Position.X &lt;&lt; r_1.Position.Y &lt;&lt; r_1.Position.Z &lt;&lt; &#39;\\t ,&#39;&lt;&lt;countFrame&lt;&lt;endl; fout &lt;&lt; r_1.Position.X&lt;&lt;&#39;,&#39; &lt;&lt; r_1.Position.Y &lt;&lt; &#39;,&#39; &lt;&lt; r_1.Position.Z &lt;&lt;&#39;,&#39;&lt;&lt;now&lt;&lt; endl; fout.close(); &#125; else &#123; now &#x3D; clock(); ofstream fout(&quot;01.txt&quot;, ios::app); cout &lt;&lt; now; cout &lt;&lt; 0 &lt;&lt; 0 &lt;&lt;0 &lt;&lt; endl; fout &lt;&lt; 0 &lt;&lt; &#39;,&#39; &lt;&lt;0 &lt;&lt; &#39;,&#39; &lt;&lt; 0 &lt;&lt; &#39;,&#39; &lt;&lt; now&lt;&lt;endl; fout.close(); &#125;&#125; 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//完整代码//其实本项目并没有用到opencv 我这是copy的别人的代码然后修改了一下。代码有很多和本项目无关的东西，等有时间删除精炼一下#include &lt;iostream&gt;#include &lt;opencv2\\imgproc.hpp&gt; //opencv头文件#include &lt;opencv2\\calib3d.hpp&gt;#include &lt;opencv2\\highgui.hpp&gt;#include &lt;Kinect.h&gt; //Kinect头文件#include&lt;fstream&gt;#include&lt;ctime&gt;using namespace std;using namespace cv;int countFrame = 0;clock_t pre, now;clock_t begintime, endtime;void draw(Mat &amp; img, Joint &amp; r_1, Joint &amp; r_2, ICoordinateMapper * myMapper);int main(void)&#123; begintime = clock(); IKinectSensor * mySensor = nullptr; GetDefaultKinectSensor(&amp;mySensor); mySensor-&gt;Open(); IColorFrameSource * myColorSource = nullptr; mySensor-&gt;get_ColorFrameSource(&amp;myColorSource); IColorFrameReader * myColorReader = nullptr; myColorSource-&gt;OpenReader(&amp;myColorReader); int colorHeight = 0, colorWidth = 0; IFrameDescription * myDescription = nullptr; myColorSource-&gt;get_FrameDescription(&amp;myDescription); myDescription-&gt;get_Height(&amp;colorHeight); myDescription-&gt;get_Width(&amp;colorWidth); IColorFrame * myColorFrame = nullptr; Mat original(colorHeight, colorWidth, CV_8UC4); //**********************以上为ColorFrame的读取前准备************************** IBodyFrameSource * myBodySource = nullptr; mySensor-&gt;get_BodyFrameSource(&amp;myBodySource); IBodyFrameReader * myBodyReader = nullptr; myBodySource-&gt;OpenReader(&amp;myBodyReader); int myBodyCount = 0; myBodySource-&gt;get_BodyCount(&amp;myBodyCount); IBodyFrame * myBodyFrame = nullptr; ICoordinateMapper * myMapper = nullptr; mySensor-&gt;get_CoordinateMapper(&amp;myMapper); int fps = 0; //**********************以上为BodyFrame以及Mapper的准备*********************** while (1) &#123; while (myColorReader-&gt;AcquireLatestFrame(&amp;myColorFrame) != S_OK); myColorFrame-&gt;CopyConvertedFrameDataToArray(colorHeight * colorWidth * 4, original.data, ColorImageFormat_Bgra); Mat copy = original.clone(); //读取彩色图像并输出到矩阵 while (myBodyReader-&gt;AcquireLatestFrame(&amp;myBodyFrame) != S_OK); //读取身体图像 IBody ** myBodyArr = new IBody *[myBodyCount]; //为存身体数据的数组做准备 if (fps != 0) &#123; //cout &lt;&lt; fps &lt;&lt; endl; fps++; fps = fps % 30; delete[]myBodyArr; myBodyFrame-&gt;Release(); myColorFrame-&gt;Release(); continue; &#125; fps++; for (int i = 0; i &lt; myBodyCount; i++) myBodyArr[i] = nullptr; if (myBodyFrame-&gt;GetAndRefreshBodyData(myBodyCount, myBodyArr) == S_OK) //把身体数据输入数组 for (int i = 0; i &lt; myBodyCount; i++) &#123; BOOLEAN result = false; if (myBodyArr[i]-&gt;get_IsTracked(&amp;result) == S_OK &amp;&amp; result) //先判断是否侦测到 &#123; Joint myJointArr[JointType_Count]; if (myBodyArr[i]-&gt;GetJoints(JointType_Count, myJointArr) == S_OK) //如果侦测到就把关节数据输入到数组并画图 &#123; draw(copy, myJointArr[JointType_Head], myJointArr[JointType_Neck], myMapper); &#125; &#125; &#125; delete[]myBodyArr; myBodyFrame-&gt;Release(); myColorFrame-&gt;Release(); if (countFrame == 330) &#123; break; &#125; &#125; myMapper-&gt;Release(); myDescription-&gt;Release(); myColorReader-&gt;Release(); myColorSource-&gt;Release(); myBodyReader-&gt;Release(); myBodySource-&gt;Release(); mySensor-&gt;Close(); mySensor-&gt;Release(); return 0;&#125;void draw(Mat &amp; img, Joint &amp; r_1, Joint &amp; r_2, ICoordinateMapper * myMapper)&#123; countFrame++; if (r_1.TrackingState == TrackingState_Tracked ) &#123; now = clock(); ofstream fout(&quot;01.txt&quot;, ios::app); cout &lt;&lt; now; cout &lt;&lt; r_1.Position.X &lt;&lt; r_1.Position.Y &lt;&lt; r_1.Position.Z &lt;&lt; &#x27;\\t ,&#x27;&lt;&lt;countFrame&lt;&lt;endl; fout &lt;&lt; r_1.Position.X&lt;&lt;&#x27;,&#x27; &lt;&lt; r_1.Position.Y &lt;&lt; &#x27;,&#x27; &lt;&lt; r_1.Position.Z &lt;&lt;&#x27;,&#x27;&lt;&lt;now&lt;&lt; endl; fout.close(); &#125; else &#123; now = clock(); ofstream fout(&quot;01.txt&quot;, ios::app); cout &lt;&lt; now; cout &lt;&lt; 0 &lt;&lt; 0 &lt;&lt;0 &lt;&lt; endl; fout &lt;&lt; 0 &lt;&lt; &#x27;,&#x27; &lt;&lt;0 &lt;&lt; &#x27;,&#x27; &lt;&lt; 0 &lt;&lt; &#x27;,&#x27; &lt;&lt; now&lt;&lt;endl; fout.close(); &#125;&#125;","categories":[],"tags":[{"name":"Kinect","slug":"Kinect","permalink":"https://huajiaohuixiang.github.io/tags/Kinect/"}]},{"title":"hexo使用","slug":"huxo使用","date":"2021-02-19T07:52:56.000Z","updated":"2021-02-19T08:43:36.839Z","comments":true,"path":"2021/02/19/huxo使用/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/19/huxo%E4%BD%BF%E7%94%A8/","excerpt":"","text":"使用Hexo+Github部署参考官方文档：https://hexo.io/docs/ 安装1234cnpm install -g hexo-cli 或者 cnpm install hexo 安装Hexohexo init &lt;foldername&gt; 新建一个Hexo项目cd foldername cnpm install 安装依赖 写博客12hexo new [layout] &lt;title&gt; 新建一个帖子&#x2F;页面&#x2F;草稿 分别对应layout中post&#x2F;page&#x2F;draft title是名字 对于草稿写完后还需要 hexo publish [layout] &lt;title&gt;&#x2F;&#x2F;创建post时可以根据scaffolds中的模板进行创建 命令为 hexo new &lt;模板名字&gt; &lt;post名字&gt; 例如scaffolds中有一个a.md 以它为模板的命令为 hexo new a “hi” 部署在github上首先在github上创建huajiaohuixiang.github.io的Repo然后在本地hexo下 123456git initgit branch -M maingit remote add origin https:&#x2F;&#x2F;github.com&#x2F;huajiaohuixiang&#x2F;huajiaohuixiang.github.io.gitgit add .git commit -m &quot;first commit&quot;git push origin -u origin main 第一次需要-u origin commit 然后安装hexo-deployer 123456cnpm install hexo-deployer-git --save修改 _config.yml 将deploy修改成下面（huajiaohuixiang应该改成你的repo名字）deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;huajiaohuixiang&#x2F;huajiaohuixiang.github.io branch: main 然后 12hexo clean hexo deploy 打开https://huajioahuixiang.github.io即可本人第一次hexo deploy的时候报错 1234567FATAL &#123; err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (Y:\\个人博客\\hexo\\node_modules\\_hexo-util@2.4.0@hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (events.js:315:20) at ChildProcess.cp.emit (Y:\\个人博客\\hexo\\node_modules\\_cross-spawn@7.0.3@cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123; &#125; 在deploy一次就好了 可能有用的文章：https://1187100546.github.io/2019/11/24/spawn-failed/https://perry96.com/archives/882898e3.html 这个是回退本地git版本 回退了就好了，很奇怪","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://huajiaohuixiang.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Java-@HotSpotIntrinsicCandidate","slug":"@HotSpotIntrinsicCandidate","date":"2021-02-19T06:13:38.000Z","updated":"2021-02-19T14:11:57.124Z","comments":true,"path":"2021/02/19/@HotSpotIntrinsicCandidate/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/19/@HotSpotIntrinsicCandidate/","excerpt":"","text":"@HotSpotIntrinsicCandidate看源码的时候看到了很多这种注释 ， JDK的Object类源码中，被@HotSpotIntrinsicCandidate标注的方法，在HotSpot中都有一套高效的实现，该高效实现基于CPU指令，运行时，HotSpot维护的高效实现会替代JDK的源码实现，从而获得更高的效率。参考https://blog.csdn.net/javaer_lee/article/details/87161952 下面的源码对其的解释 The {@code @HotSpotIntrinsicCandidate} annotation is specific to the HotSpot Virtual Machine. It indicates that an annotated method may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method is intrinsified if the HotSpot VM replaces the annotated method with hand-written assembly and/or hand-written compiler IR – a compiler intrinsic – to improve performance. The {@code @HotSpotIntrinsicCandidate} annotation is internal to the Java libraries and is therefore not supposed to have any relevance for application code. Maintainers of the Java libraries must consider the following when modifying methods annotated with {@code @HotSpotIntrinsicCandidate}. When modifying a method annotated with {@code @HotSpotIntrinsicCandidate}, the corresponding intrinsic code in the HotSpot VM implementation must be updated to match the semantics of the annotated method. For some annotated methods, the corresponding intrinsic may omit some low-level * checks that would be performed as a matter of course if the intrinsic is implemented * using Java bytecodes. This is because individual Java bytecodes implicitly check * for exceptions like {@code NullPointerException} and {@code ArrayStoreException}. * If such a method is replaced by an intrinsic coded in assembly language, any * checks performed as a matter of normal bytecode operation must be performed * before entry into the assembly code. These checks must be performed, as * appropriate, on all arguments to the intrinsic, and on other values (if any) obtained * by the intrinsic through those arguments. The checks may be deduced by inspecting * the non-intrinsic Java code for the method, and determining exactly which exceptions * may be thrown by the code, including undeclared implicit {@code RuntimeException}s. * Therefore, depending on the data accesses performed by the intrinsic, * the checks may include: null checks on references range checks on primitive values used as array indexes other validity checks on primitive values (e.g., for divide-by-zero conditions) store checks on reference values stored into arrays array length checks on arrays indexed from within the intrinsic reference casts (when formal parameters are {@code Object} or some other weak type) Note that the receiver value ({@code this}) is passed as a extra argument * to all non-static methods. If a non-static method is an intrinsic, the receiver * value does not need a null check, but (as stated above) any values loaded by the * intrinsic from object fields must also be checked. As a matter of clarity, it is * better to make intrinisics be static methods, to make the dependency on {@code this} * clear. Also, it is better to explicitly load all required values from object * fields before entering the intrinsic code, and pass those values as explicit arguments. * First, this may be necessary for null checks (or other checks). Second, if the * intrinsic reloads the values from fields and operates on those without checks, * race conditions may be able to introduce unchecked invalid values into the intrinsic. * If the intrinsic needs to store a value back to an object field, that value should be * returned explicitly from the intrinsic; if there are multiple return values, coders * should consider buffering them in an array. Removing field access from intrinsics * not only clarifies the interface with between the JVM and JDK; it also helps decouple * the HotSpot and JDK implementations, since if JDK code before and after the intrinsic * manages all field accesses, then intrinsics can be coded to be agnostic of object * layouts. * * Maintainers of the HotSpot VM must consider the following when modifying intrinsics. * * When adding a new intrinsic, make sure that the corresponding method * in the Java libraries is annotated with {@code @HotSpotIntrinsicCandidate} * and that all possible call sequences that result in calling the intrinsic contain * the checks omitted by the intrinsic (if any). When modifying an existing intrinsic, the Java libraries must be updated * to match the semantics of the intrinsic and to execute all checks omitted * by the intrinsic (if any). Persons not directly involved with maintaining the Java libraries or the * HotSpot VM can safely ignore the fact that a method is annotated with * {@code @HotSpotIntrinsicCandidate}. * * The HotSpot VM defines (internally) a list of intrinsics. Not all intrinsic * are available on all platforms supported by the HotSpot VM. Furthermore, * the availability of an intrinsic on a given platform depends on the * configuration of the HotSpot VM (e.g., the set of VM flags enabled). * Therefore, annotating a method with {@code @HotSpotIntrinsicCandidate} does * not guarantee that the marked method is intrinsified by the HotSpot VM. * * If the {@code CheckIntrinsics} VM flag is enabled, the HotSpot VM checks * (when loading a class) that (1) all methods of that class that are also on * the VM’s list of intrinsics are annotated with {@code @HotSpotIntrinsicCandidate} * and that (2) for all methods of that class annotated with * {@code @HotSpotIntrinsicCandidate} there is an intrinsic in the list.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-Object","slug":"Object","date":"2021-02-19T06:13:38.000Z","updated":"2021-03-07T14:14:48.037Z","comments":true,"path":"2021/02/19/Object/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/19/Object/","excerpt":"","text":"12Class &#123;@code Object&#125; is the root of the class hierarchy. Every class has &#123;@code Object&#125; as a superclass. All objects, including arrays, implement the methods of this class.类Object是类层次结构的根。 每个类都把Object作为父类。 所有对象，包括数组，实现该类的方法。 源码介绍如上。 1.hashcode()12@HotSpotIntrinsicCandidatepublic native int hashCode(); native修饰的方法，不由java实现，hashcode()方法就是将该对象再内存中的位置转换为整数然后返回，所有的对象由JVM管理。 2.equals()123public boolean equals(Object obj) &#123; return (this == obj);&#125; ==即判断两者的内存地址是否相同。 对于String来说，其重写了equals()函数，先判断内存地址然后再判断内容。 需要注意的是必须保证如果两者的equals()为true，那么hashcode()相同。即重写的话也要先判断内存地址是否相同，然后对于不同的情况再判断其他的。 建议但不强制对于不相等的对象的hashCode一定要不同。 3.clone()方法12345678910111213141516/* * The method &#123;@code clone&#125; for class &#123;@code Object&#125; performs a * specific cloning operation. First, if the class of this object does * not implement the interface &#123;@code Cloneable&#125;, then a * &#123;@code CloneNotSupportedException&#125; is thrown. Note that all arrays * are considered to implement the interface &#123;@code Cloneable&#125; and that * the return type of the &#123;@code clone&#125; method of an array type &#123;@code T[]&#125; * is &#123;@code T[]&#125; where T is any reference or primitive type. * Otherwise, this method creates a new instance of the class of this * object and initializes all its fields with exactly the contents of * the corresponding fields of this object, as if by assignment; the * contents of the fields are not themselves cloned. Thus, this method * performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation. */@HotSpotIntrinsicCandidateprotected native Object clone() throws CloneNotSupportedException; 只包含了部分注释，这一部分注释解释了该函数的内容： 如果该类没有实现Cloneable接口，会抛出CloneNotSupportedException异常。 如果实现了Cloneable接口，那么该方法将会创建该类的新实例，并且初始化所有字段，字段的内容本身不是克隆的。 从而，这种方法执行此对象的“浅拷贝”，而不是“深拷贝”操作 4.toString()1234//It is recommended that all subclasses override this method.public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 返回类名+@+哈希值（内存地址转换而成） 5.wait(), notify(), notifyAll()java的线程同步函数 12345678910111213141516171819202122232425@HotSpotIntrinsicCandidatepublic final native void notify();@HotSpotIntrinsicCandidatepublic final native void notifyAll();public final void wait() throws InterruptedException &#123; wait(0L);&#125;public final native void wait(long timeoutMillis) throws InterruptedException;public final void wait(long timeoutMillis, int nanos) throws InterruptedException &#123; if (timeoutMillis &lt; 0) &#123; throw new IllegalArgumentException(&quot;timeoutMillis value is negative&quot;); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( &quot;nanosecond timeout value out of range&quot;); &#125; if (nanos &gt; 0) &#123; timeoutMillis++; &#125; wait(timeoutMillis);&#125; 6.finalize()函数12@Deprecated(since&#x3D;&quot;9&quot;)protected void finalize() throws Throwable &#123; &#125; finalize()方法就是再JVM确定已经没有任何线程可以访问该对象，那么将会清空该内存区域，如果其他类又使用了该类将会报异常。抛出的是Throwable，说明除了常规的异常Exceprion外，还有可能是JVM错误。当一个对象在回收前想要执行一些操作，就要覆写Object类中的finalize( )方法。 @Deprecated(since=”9”)表示自从JDK9已废除该方法","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-String","slug":"String","date":"2021-02-19T06:13:38.000Z","updated":"2021-02-19T11:50:36.287Z","comments":true,"path":"2021/02/19/String/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/19/String/","excerpt":"","text":"关于字符串 推荐阅读源码，或者https://blog.csdn.net/zhxdick/article/details/80803507 以下是几个String的问题，总结一下。 String 被final修饰 不能被继承final的作用： ​ 修饰变量 表示变量只能一次赋值以后值不能被修改 ​ 如果是修饰了一个基本类型数据，就表示一个常量 ​ 如果是引用类型数据，则引用初始化后将永远指向一个内存地址（就相当于一个不能变的指针） ​ 但是该引用对象中的内容是可以变的 ​ 修饰方法 该方法不能被重写，但可以继承 ​ 修饰类 该类不能被继承 final修饰变量的本质: final修饰的变量会指向一块固定的内存, 这块内存中的值不能改变. 参考https://blog.csdn.net/qq_24309787/article/details/100942044 那为何String要被修饰成final？ 为了实现字符串常量池：字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量池中的同一个对象。这样一方面能够节约内存，另一方面也提升了性能。 但是仅有一个final不能保证字符串常量，原因在上面final作用第一条已说明。我们看String源码 123456789101112131415public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; //String类被final修饰了，表明其不可被继承。 //实现了 Serializable接口---&gt;使其可以序列化，方便数据的传输 //实现了Comparable接口，可以调用Collections.sort() 和 Arrays.sort() 方法排序，并且String类实现 compareTo() 方法。 //实现了CharSequence接口，该接口能表示char值的一个可读序列。几个String兄弟类都实现了此接口。 @Stable private final byte[] value; private final byte coder; private int hash; // Default to 0 ...&#125; 其中的final修饰的byte数组用来存储String内容，然后再加上private修饰，本身也没有提供修改自己value数组的方法，所以value数组不可变，即字符串不可变，生成了字符串常量池。 还有因为其不可变所以String是线程安全的，同一个字符串实例可以被多个线程共享。 因为字符串是不可变的，所以在它创建的时候HashCode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。 ​ 参考https://blog.csdn.net/zhxdick/article/details/80803507 ​ https://www.jianshu.com/p/9c7f5daac283 JDK8 和JDK9 String的变化​ 再JDK8中 String中是用char数组来存储 char是由UTF16编码咱用两个字节，但是很多都只用了一个字节（ASICII），所有再9中对其进行了优化，将char[] 更改为了 byte [] 以及一个coder来存储。 ​ coder一般只有两个值：分别用来表示8位表示还剩16位表示 12static final byte LATIN1 &#x3D; 0; static final byte UTF16 &#x3D; 1; 关于== 和equal()“==”判断的是两个对象的内存地址是否一样，适用于原始数据类型和枚举类型（它们的变量存储的是值本身，而引用类型变量存储的是引用）；equals是Object类的方法，Object对它的实现是比较内存地址，我们可以重写这个方法来自定义“相等”这个概念。比如类库中的String、Date等类就对这个方法进行了重写。综上，对于枚举类型和原始数据类型的相等性比较，应该使用”==”；对于引用类型的相等性比较，应该使用equals方法。 下面是String的equal函数,equal()函数的object的一个函数，String对其进行了重写，首先它判断了两者内存地址是否一样，然后将anObject转换为String比较内容。 12345678910111213public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String aString = (String)anObject; if (coder() == aString.coder()) &#123; return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); &#125; &#125; return false;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"Java-@Native","slug":"native","date":"2021-02-19T06:13:38.000Z","updated":"2021-02-20T03:03:13.065Z","comments":true,"path":"2021/02/19/native/","link":"","permalink":"https://huajiaohuixiang.github.io/2021/02/19/native/","excerpt":"","text":"看Object的源码的时候发现了从未见过的修饰符native，雨伞学习一下。 就是这几个： 123456789101112131415161718192021private static native void registerNatives();public final native Class&lt;?&gt; getClass(); public native int hashCode();@HotSpotIntrinsicCandidatepublic final native void notify();@HotSpotIntrinsicCandidatepublic final native void notifyAll();public final void wait() throws InterruptedException &#123; wait(0L);&#125;public final native void wait(long timeoutMillis) throws InterruptedException;public final void wait(long timeoutMillis, int nanos) throws InterruptedException &#123; ...&#125; 参考博客https://www.cnblogs.com/KingIceMou/p/7239668.html 被native修饰的方法就是不是由java实现的，而是由C或者C++实现，并且编译成了dll，然后由java调用，调用过程如下： 实现步骤 １、在Java中声明native()方法，然后编译； ２、用javah产生一个.h文件； ３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）； ４、将第三步的.cpp文件编译成动态链接库文件； ５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"}]},{"title":"悲惨世界","slug":"悲惨世界","date":"2020-12-03T16:00:00.000Z","updated":"2021-02-19T06:25:31.753Z","comments":true,"path":"2020/12/04/悲惨世界/","link":"","permalink":"https://huajiaohuixiang.github.io/2020/12/04/%E6%82%B2%E6%83%A8%E4%B8%96%E7%95%8C/","excerpt":"","text":"人有肉体，这对人来说，既是负担优势诱惑。人拖着肉体，又屈从于肉体。 有罪的人并不是犯罪的人，而是制造黑暗的人。 最好看的祭坛，是不幸者因得到了安慰而感谢上帝的一颗心灵 我在这世上不是守护自己的生命，而是守护灵魂。 p34-44","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://huajiaohuixiang.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"SpringBoot 学习","slug":"SpringBoot","date":"2020-11-19T16:00:00.000Z","updated":"2021-03-10T02:21:16.599Z","comments":true,"path":"2020/11/20/SpringBoot/","link":"","permalink":"https://huajiaohuixiang.github.io/2020/11/20/SpringBoot/","excerpt":"","text":"依赖：spring-boot-plugin 可以将应用打包成一个jar包 @SpringBootApplication 注解可以用来标注主程序 其实是一个组合注解 @SpringBootConfiguration、@EnableAutoConfiguration等等 @Reponse Body 返回主体 @Controller 控制器 ​ 这俩合成一个@RestController 4.跨域的话+@CrossOrigin 5.YAML新的配置文件类型。k： v格式 冒号后面要有空格 6.@ConfigurationProperties(prefix=” “)来标识一个配置类，松散绑定 @Value() 也可以只不过是标识一个变量，不支持松散绑定 IOCIoC（Inverse of Control:控制反转）是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。 将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来，也可以避免循环依赖的问题。 AOPAOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://huajiaohuixiang.github.io/tags/SpringBoot/"}]},{"title":"Linux/Windows系统命令","slug":"Linux Window命令","date":"2020-11-15T16:00:00.000Z","updated":"2021-03-12T10:02:08.876Z","comments":true,"path":"2020/11/16/Linux Window命令/","link":"","permalink":"https://huajiaohuixiang.github.io/2020/11/16/Linux%20Window%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1.Putty 传送文件到服务器：​ 打开putty目录：命令行运行 psftp​ put -r foldername 上传文件夹 2.Linux获取应用程序位置1dpkg -S softwarename 显示包含此软件包的所有位置， 1dpkg -L softwarename 显示安装路径。 3.开启关闭HypeV 管理员打开命令行 123bcdedit &#x2F;set hypervisorlaunchtype off bcdedit &#x2F;set hypervisorlaunchtype Auto 4.Linux 命令1234567netstat -ntlp 查看端口使用情况ps ux 查看nohup进程jobs 未退出过终端 查看nohup进程kill -9 id 5.查找当前文件夹下所有以.go的文件数目find ./ -name “*.go” | wc -l","categories":[],"tags":[{"name":"杂类","slug":"杂类","permalink":"https://huajiaohuixiang.github.io/tags/%E6%9D%82%E7%B1%BB/"}]}],"categories":[],"tags":[{"name":"frp","slug":"frp","permalink":"https://huajiaohuixiang.github.io/tags/frp/"},{"name":"服务器搭建","slug":"服务器搭建","permalink":"https://huajiaohuixiang.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"name":"Java","slug":"Java","permalink":"https://huajiaohuixiang.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"锁","slug":"锁","permalink":"https://huajiaohuixiang.github.io/tags/%E9%94%81/"},{"name":"操作系统","slug":"操作系统","permalink":"https://huajiaohuixiang.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","permalink":"https://huajiaohuixiang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"https://huajiaohuixiang.github.io/tags/redis/"},{"name":"mysql","slug":"mysql","permalink":"https://huajiaohuixiang.github.io/tags/mysql/"},{"name":"JVM","slug":"JVM","permalink":"https://huajiaohuixiang.github.io/tags/JVM/"},{"name":"jetson","slug":"jetson","permalink":"https://huajiaohuixiang.github.io/tags/jetson/"},{"name":"nano","slug":"nano","permalink":"https://huajiaohuixiang.github.io/tags/nano/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://huajiaohuixiang.github.io/tags/ubuntu/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://huajiaohuixiang.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"面经","slug":"面经","permalink":"https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"习概","slug":"习概","permalink":"https://huajiaohuixiang.github.io/tags/%E4%B9%A0%E6%A6%82/"},{"name":"毛概","slug":"毛概","permalink":"https://huajiaohuixiang.github.io/tags/%E6%AF%9B%E6%A6%82/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://huajiaohuixiang.github.io/tags/Ubuntu/"},{"name":"Redis","slug":"Redis","permalink":"https://huajiaohuixiang.github.io/tags/Redis/"},{"name":"Mysql","slug":"Mysql","permalink":"https://huajiaohuixiang.github.io/tags/Mysql/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://huajiaohuixiang.github.io/tags/SpringBoot/"},{"name":"leetcode","slug":"leetcode","permalink":"https://huajiaohuixiang.github.io/tags/leetcode/"},{"name":"Kinect","slug":"Kinect","permalink":"https://huajiaohuixiang.github.io/tags/Kinect/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://huajiaohuixiang.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"杂类","slug":"杂类","permalink":"https://huajiaohuixiang.github.io/tags/%E6%9D%82%E7%B1%BB/"}]}