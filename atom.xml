<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花椒茴香的个人博客</title>
  
  <subtitle>安得广厦千万间</subtitle>
  <link href="https://huajiaohuixiang.github.io/atom.xml" rel="self"/>
  
  <link href="https://huajiaohuixiang.github.io/"/>
  <updated>2021-04-19T03:20:49.335Z</updated>
  <id>https://huajiaohuixiang.github.io/</id>
  
  <author>
    <name>huajiaohuixiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书笔记</title>
    <link href="https://huajiaohuixiang.github.io/2021/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://huajiaohuixiang.github.io/2021/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-04-19T03:14:05.000Z</published>
    <updated>2021-04-19T03:20:49.335Z</updated>
    
    <content type="html"><![CDATA[<p>n</p><p>那些80年代的红砖还能叫红色吗，大概只能算是煤球渣子的近亲。正如唱歌的最终会沉默，昨日奔跑着的青年和鸵鸟，一转眼就是今天的腐肉、秃鹫。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;n&lt;/p&gt;
&lt;p&gt;那些80年代的红砖还能叫红色吗，大概只能算是煤球渣子的近亲。正如唱歌的最终会沉默，昨日奔跑着的青年和鸵鸟，一转眼就是今天的腐肉、秃鹫。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="https://huajiaohuixiang.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>3.14字节面经</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/14/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/14/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2/</id>
    <published>2021-03-14T13:18:29.000Z</published>
    <updated>2021-03-14T13:47:59.970Z</updated>
    
    <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ol><li>项目</li><li>token如何解密的</li><li>session和cookie的区别</li><li>登陆的逻辑</li><li>两个栈实现一个队列</li><li>巴什博奕（Bash Game）：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。</li><li>hashMap的扩容原理，为什么扩容二倍；</li><li>写一个select语句  两个表 组合查询 我用嵌套实现的，他想考我join查询 </li><li>四大事务特性</li><li>TCP的可靠性是怎么实现的</li><li>TIME_WAIT</li><li>算法 有一个二维数组，里面的数字要么是0，要么是1，求出 全由1组成的正方形的面积最大是多少？</li></ol><p>二面：问项目和数据库。。。因为他们用的go  所以java一点没问 </p><ol><li>给一个正数 &gt;0 ，求这个数的平方根，结果精切到小数点后5位。（我是傻逼，本来很简单的题）</li><li>项目写了用的Oracle数据库，为什么用Oracle，Oracle与mysql数据库的区别？</li><li>Redis五大数据类型底层数据结构</li><li>如何使用Redis和MQ实现的抢购优惠券</li><li>Mysql表锁和行锁之间间隙锁是如何实现的。</li><li>四大事务特性的一致性是怎么实现的</li><li>讲一下可重复读</li><li>聚簇索引</li><li>undolog和redolog</li><li>HTTP状态码</li><li>HTTPS和HTTP的区别</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;项目&lt;/li&gt;
&lt;li&gt;token如何解密的&lt;/li&gt;
&lt;li&gt;session和cookie的区别&lt;/li&gt;
&lt;li&gt;登陆的逻辑&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="面经" scheme="https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>3.9蚂蚁面经</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/09/3-9%E8%9A%82%E8%9A%81%E9%9D%A2%E7%BB%8F/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/09/3-9%E8%9A%82%E8%9A%81%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-03-09T15:18:29.000Z</published>
    <updated>2021-03-14T13:47:19.730Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-项目"><a href="#1-项目" class="headerlink" title="1.项目"></a>1.项目</h4><h4 id="2-你是如何设计数据库的"><a href="#2-你是如何设计数据库的" class="headerlink" title="2.你是如何设计数据库的"></a>2.你是如何设计数据库的</h4><h4 id="3-HashMap-ConcurrentHashMap的区别"><a href="#3-HashMap-ConcurrentHashMap的区别" class="headerlink" title="3.HashMap  ConcurrentHashMap的区别"></a>3.HashMap  ConcurrentHashMap的区别</h4><h4 id="4-Array-List-LinkedList-扩容机制"><a href="#4-Array-List-LinkedList-扩容机制" class="headerlink" title="4.Array List   LinkedList   扩容机制"></a>4.Array List   LinkedList   扩容机制</h4><h4 id="5-JVM-堆（）中对象的转移？https-www-cnblogs-com-guanghe-p-10524314-html"><a href="#5-JVM-堆（）中对象的转移？https-www-cnblogs-com-guanghe-p-10524314-html" class="headerlink" title="5.JVM   堆（）中对象的转移？https://www.cnblogs.com/guanghe/p/10524314.html"></a>5.JVM   堆（）中对象的转移？<a href="https://www.cnblogs.com/guanghe/p/10524314.html">https://www.cnblogs.com/guanghe/p/10524314.html</a></h4><h4 id="6-数据库-悲观锁乐观锁-如何实现的？"><a href="#6-数据库-悲观锁乐观锁-如何实现的？" class="headerlink" title="6.数据库 悲观锁乐观锁  如何实现的？"></a>6.数据库 悲观锁乐观锁  如何实现的？</h4><h4 id="7-排序算法"><a href="#7-排序算法" class="headerlink" title="7.排序算法"></a>7.排序算法</h4><h4 id="8-算法：1G的文件、1M的内存，每一行一个词、求最高的100个词"><a href="#8-算法：1G的文件、1M的内存，每一行一个词、求最高的100个词" class="headerlink" title="8.算法：1G的文件、1M的内存，每一行一个词、求最高的100个词"></a>8.算法：1G的文件、1M的内存，每一行一个词、求最高的100个词</h4><h4 id="9-索引-在什么字段上建立索引，索引大概的原理"><a href="#9-索引-在什么字段上建立索引，索引大概的原理" class="headerlink" title="9.索引 在什么字段上建立索引，索引大概的原理"></a>9.索引 在什么字段上建立索引，索引大概的原理</h4><h4 id="10-Spring-Aop？原理？"><a href="#10-Spring-Aop？原理？" class="headerlink" title="10.Spring Aop？原理？"></a>10.Spring Aop？原理？</h4><h4 id="11-进程线程区别"><a href="#11-进程线程区别" class="headerlink" title="11.进程线程区别"></a>11.进程线程区别</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-项目&quot;&gt;&lt;a href=&quot;#1-项目&quot; class=&quot;headerlink&quot; title=&quot;1.项目&quot;&gt;&lt;/a&gt;1.项目&lt;/h4&gt;&lt;h4 id=&quot;2-你是如何设计数据库的&quot;&gt;&lt;a href=&quot;#2-你是如何设计数据库的&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="面经" scheme="https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huajiaohuixiang.github.io/2021/03/08/%E5%8F%8D%E5%B0%84/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/08/%E5%8F%8D%E5%B0%84/</id>
    <published>2021-03-08T12:27:53.797Z</published>
    <updated>2021-03-09T03:17:52.115Z</updated>
    
    <content type="html"><![CDATA[<p>什么是反射？</p><p>​    </p><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><h3 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6?id=%E8%8E%B7%E5%8F%96-class-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F">获取 Class 对象的四种方式</a></h3><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p><p>1.知道具体类的情况下可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取Class对象不会进行初始化</p><p>2.通过 <code>Class.forName()</code>传入类的路径获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>Class.forName(className)方法，内部实际调用的是一个native方法  forName0(className, true, ClassLoader.getClassLoader(caller), caller);</p><p>第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。</p><p>一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。</p><p>3.通过对象实例<code>instance.getClass()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">Class alunbarClass2 = e.getClass();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>4.通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clazz</span> </span>= ClassLoader.LoadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>通过类加载器获取Class对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行</p><ol><li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li><li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li><li>动态配置实例的属性；</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么是反射？&lt;/p&gt;
&lt;p&gt;​    &lt;/p&gt;
&lt;p&gt;JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huajiaohuixiang.github.io/2021/03/08/%E9%98%BF%E9%87%8C3.6%E7%AC%94%E8%AF%95%E9%A2%982/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/08/%E9%98%BF%E9%87%8C3.6%E7%AC%94%E8%AF%95%E9%A2%982/</id>
    <published>2021-03-08T02:33:15.038Z</published>
    <updated>2021-03-08T02:54:14.303Z</updated>
    
    <content type="html"><![CDATA[<p>给定N条线路</p><p>每条线路经过一些站点，判断能否从一个点到达另一个点；</p><p>floyd算法，但不需要求最短路径</p><p>输入：</p><p>2 3 6  两条线路 3起始站 6终点站</p><p>3    第i个线路经过几个站</p><p>1 6 7</p><p>4</p><p> 2 3 4 7</p><p>返回true</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定N条线路&lt;/p&gt;
&lt;p&gt;每条线路经过一些站点，判断能否从一个点到达另一个点；&lt;/p&gt;
&lt;p&gt;floyd算法，但不需要求最短路径&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;2 3 6  两条线路 3起始站 6终点站&lt;/p&gt;
&lt;p&gt;3    第i个线路经过几个站&lt;/p&gt;
&lt;p&gt;1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/08/%E9%9B%86%E5%90%88-1/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/08/%E9%9B%86%E5%90%88-1/</id>
    <published>2021-03-08T01:21:56.000Z</published>
    <updated>2021-03-08T01:21:56.948Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/07/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-07T13:41:59.000Z</published>
    <updated>2021-03-14T03:26:10.817Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>面向对象和面向过程的区别</p><p>面向对象是一种 <strong>对现实世界理解和抽象的方法</strong>，是计算机编程技术发展到一定阶段后的产物。</p><p><strong>面向过程</strong>  (Procedure Oriented) 是一种 <strong>以过程为中心</strong> 的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。</p></li><li><p>Java 语言有哪些特点?</p><p>一处编译、到处执行</p><p>支持多线程</p><p>面向对象</p><p>支持网络编程并且很方便</p><p>编译与解释并存</p></li><li><p>关于 JVM JDK 和 JRE </p><p>JDK  java develop kit 包括java的一切</p><p>JRE是运行时环境</p></li><li><p>Oracle JDK 和 OpenJDK 的对比</p></li><li><p>Java 和 C++的区别?</p></li><li><p>字符型常量和字符串常量的区别?</p><p>​    形式上  字符型是由单引号，字符串是由双引号</p><p>​    含义上，字符型可以当作数字处理，参加表达式运算 </p><p>​     字符串可以占n个字节 其底层是byte数组，字节只占两个字节utf16</p></li><li><p>重载和重写的区别</p><p>重写是指子类重写父类的方法，返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</p><p>重载： 根据不同的输入进行不同的处理，方法签名包括：方法名+参数  返回类型不是属于方法签名</p></li><li><p>Java 面向对象编程三大特性: 封装 继承 多态</p><p>多态：程序中定义的引用类型调用的方法在编译时并不能确定，需要在运行时确定</p></li><li><p>自动装箱与拆箱</p><p>基本类型 引用类型</p></li><li><p>在 Java 中定义一个不做事且没有参数的构造方法的作用</p><p>如果子类有一个无参构造函数，而父类没有无参构造函数、只有有参构造函数，则会编译不通过，子类的无参需要先调用父类的无参，而父类有了有参后，默认的无参就不生效了。</p></li><li><p>接口和抽象类的区别是什么？</p><p>抽象类可以实现静态方法与普通方法、普通变量、静态变量、常量；</p><p>接口不能拥有普通方法与普通变量，但可以有默认方法实现，静态变量静态方法；</p><p>接口的默认访问权限是public ；可以实现多个接口但只能继承一个抽象类。</p><p>从抽象来看 接口定义了一组规范，而抽象类是对类的抽象。</p></li><li><p>成员变量与局部变量的区别有哪些？</p><p>​    成员变量属于类或对象；局部变量属于方法；</p></li><li><p>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？（和HashMap、HashSet查找有关）</p><p>，其实简单的说就是为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。</p></li><li><p>为什么 Java 中只有值传递？（即使穿的是引用对象，也是值传递，传递的是堆引用对象指针的copy）</p></li><li><p>简述线程、程序、进程的基本概念。以及他们之间关系是什么?</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p><p>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p></li><li><p>线程有哪些基本状态?</p><p>创建、（就绪）、运行、阻塞、等待、超时等待、结束</p><p>在java中只能看到运行，就绪被隐藏了</p><p>等待是指wait(),需要notify()，超时等待是sleep();</p></li><li><p>Java 中的异常处理      受检查的异常，不受检查的异常，异常处理与抛出</p><p>​    Exception 分为RunTImeException和IOException</p><p>​    Runtime下的都是不受检查的异常，只能在运行中通过try catch</p><p>​    受检查的异常没有捕获代码无法通过编译</p></li><li><p>Java 中 IO 流</p></li><li><p> BIO,NIO,AIO 有什么区别?</p></li></ol><p>20.反射</p><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><p>RPC远程过程调用</p><p>如何解决的循环依赖</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;面向对象和面向过程的区别&lt;/p&gt;
&lt;p&gt;面向对象是一种 &lt;strong&gt;对现实世界理解和抽象的方法&lt;/strong&gt;，是计算机编程技术发展到一定阶段后的产物。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向过程&lt;/strong&gt;  (Procedure Oriente</summary>
      
    
    
    
    
    <category term="Java" scheme="https://huajiaohuixiang.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存区域</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/07/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/07/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2021-03-07T02:37:27.000Z</published>
    <updated>2021-03-10T05:19:32.276Z</updated>
    
    <content type="html"><![CDATA[<h5 id="看了好多面经，感觉还是要看书，然后自己整理一下-于是决定看深入理解java虚拟机这本书"><a href="#看了好多面经，感觉还是要看书，然后自己整理一下-于是决定看深入理解java虚拟机这本书" class="headerlink" title="###看了好多面经，感觉还是要看书，然后自己整理一下,于是决定看深入理解java虚拟机这本书###"></a>###看了好多面经，感觉还是要看书，然后自己整理一下,于是决定看深入理解java虚拟机这本书###</h5><h5 id="Java与C-之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里-面的人却想出来。"><a href="#Java与C-之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里-面的人却想出来。" class="headerlink" title="####Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里 面的人却想出来。####"></a>####Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里 面的人却想出来。####</h5><h4 id="1-JVM内存区域分为五大部分："><a href="#1-JVM内存区域分为五大部分：" class="headerlink" title="1.JVM内存区域分为五大部分："></a>1.JVM内存区域分为五大部分：</h4><h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>   java线程的栈帧，线程的每一个方法会生成一个栈帧，用于存放该线程的局部变量表、操作数栈、动态连接、方法出口等信息。随着方法的调用与结束，对应着入栈与出栈；局部变量表中存放着方法参数和内部定义的局部变量，基本存储单位是方法槽。<br>    动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用是为了支持方法调用过程中的动态连接(DynamicLinking) 这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析  另外一部分符号引用将在每一次运行期间都转化为直接引用，这部分就称为动态连接<br>    操作数栈：java虚拟机栈中的一个用于计算的临时数据存储区</p><h5 id="本地方法栈-Native方法的栈帧-和虚拟机栈差不多，只不过是调用ni方法的栈帧"><a href="#本地方法栈-Native方法的栈帧-和虚拟机栈差不多，只不过是调用ni方法的栈帧" class="headerlink" title="本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧"></a>本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧</h5><h5 id="堆-几乎所有的对象都在这里分配内存"><a href="#堆-几乎所有的对象都在这里分配内存" class="headerlink" title="堆  几乎所有的对象都在这里分配内存"></a>堆  几乎所有的对象都在这里分配内存</h5><p>​    堆分为老年代、新生代、永久代；</p><p>​    新生代分为Eden FromSurvivors To Survivors  8：1：1</p><p>​    这两个Survivors有什么用呢？</p><p>​    在分配内存时，每次只使用一块Eden和 Survivor然后使用标记复制算法将其复制到另一块Survivor上。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）。</p><h5 id="方法区-："><a href="#方法区-：" class="headerlink" title="方法区 ："></a>方法区 ：</h5><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><h5 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h5><p> 当前线程字节码文件的行号指示器，通过改变该计数器的值来获得下一步执行的字节码指令；程序控制流的指示器，程序当中的分支、循环、线程恢复、跳转、异常处理都要由它指示。由于Java虚拟机通过时间片轮转实现多线程，所以每一个线程都需要一个程序计数器记录当前执行的位置。</p><h4 id="2-Java对象的创建过程：（每一步详细实现）"><a href="#2-Java对象的创建过程：（每一步详细实现）" class="headerlink" title="2.Java对象的创建过程：（每一步详细实现）"></a>2.Java对象的创建过程：（每一步详细实现）</h4><p>​    检查类是否加载</p><p>​    分配内存，在堆中分配内存</p><p>​    初始化   为变量赋默认值</p><p>​    设置对象头</p><p>​    执行init</p><h4 id="3-对象访问定位的方式："><a href="#3-对象访问定位的方式：" class="headerlink" title="3.对象访问定位的方式："></a>3.对象访问定位的方式：</h4><p>​    句柄池：每一个句柄   数据结构中包括对象数据的指针以及类的指针</p><p>​    直接指针 在对象数据中存放类指针</p><h4 id="4-JVM内存分配与回收："><a href="#4-JVM内存分配与回收：" class="headerlink" title="4.JVM内存分配与回收："></a>4.JVM内存分配与回收：</h4><p>​    大对象直接放在老年代</p><p>​     对象有限在eden分配</p><p>​    长期存活的对象进入老年代</p><h4 id="5堆内存中对象分配的基本策略：2种"><a href="#5堆内存中对象分配的基本策略：2种" class="headerlink" title="5堆内存中对象分配的基本策略：2种"></a>5堆内存中对象分配的基本策略：2种</h4><p>​    碰撞指针、空闲表</p><h5 id="并发问题如何解决"><a href="#并发问题如何解决" class="headerlink" title="并发问题如何解决"></a>并发问题如何解决</h5><p>   CAS乐观锁+失败重试   先创建失败了就重试  </p><p>   TLAB  为每个线程在Eden初设一点内存，现在TLAB分配 当TLAB用完后，用CAS+失败重试</p><h4 id="6-如何判断对象是否死亡："><a href="#6-如何判断对象是否死亡：" class="headerlink" title="6.如何判断对象是否死亡："></a>6.如何判断对象是否死亡：</h4><p>​    如果没有任何一个对象引用该对象则判断为死亡（可达性方法）</p><p>​     （引用计数法）没引用一次加一取消引用减一；不好解决互相引用的问题；</p><h5 id="GCRoots有哪些？"><a href="#GCRoots有哪些？" class="headerlink" title="GCRoots有哪些？"></a>GCRoots有哪些？</h5><p>​        虚拟机栈中引用的对象，本地方法栈中引用的对象</p><p>​        方法区中常量引用的对象，方法区中类静态属性引用的对象</p><h4 id="7-如何判断常量是否无用，类是否无用？"><a href="#7-如何判断常量是否无用，类是否无用？" class="headerlink" title="7.如何判断常量是否无用，类是否无用？"></a>7.如何判断常量是否无用，类是否无用？</h4><p>​    常量无用：没有引用即可</p><p>​    类无用：该Class类没有被引用、没有该类的对象还在存活、该类的ClassLoader已经销毁</p><h4 id="8-GC的算法有哪些？3种"><a href="#8-GC的算法有哪些？3种" class="headerlink" title="8.GC的算法有哪些？3种"></a>8.GC的算法有哪些？3种</h4><p>​    标记-清除 （可以标记被清除的，也可以标记不被清除的）造成空间破碎</p><p>​    标记 复制 （可利用空间减半）</p><p>​    标记 整理 老年代专用</p><h4 id="9-常见的垃圾回收器"><a href="#9-常见的垃圾回收器" class="headerlink" title="9.常见的垃圾回收器"></a>9.常见的垃圾回收器</h4><p>​    七个收集器（三个新生代 三个老年代 G1通吃）</p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210307141614043.png" alt="image-20210307141614043" style="zoom: 50%;" /><p>G1跳出了这个樊笼，它可以面向堆内存任 何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式</p><p>G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理 论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的 分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的 旧对象都能获取很好的收集效果。</p><p>两个支持低延迟垃圾收集器（ZGC  、 Sh。。。）以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210307142929097.png" alt="image-20210307142929097" style="zoom:50%;" /><h4 id="10-HotSpot虚拟机实现："><a href="#10-HotSpot虚拟机实现：" class="headerlink" title="10.HotSpot虚拟机实现："></a>10.HotSpot虚拟机实现：</h4><p>根节点枚举、安全点、写屏障</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;看了好多面经，感觉还是要看书，然后自己整理一下-于是决定看深入理解java虚拟机这本书&quot;&gt;&lt;a href=&quot;#看了好多面经，感觉还是要看书，然后自己整理一下-于是决定看深入理解java虚拟机这本书&quot; class=&quot;headerlink&quot; title=&quot;###看了好</summary>
      
    
    
    
    
    <category term="Java" scheme="https://huajiaohuixiang.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://huajiaohuixiang.github.io/tags/JVM/"/>
    
    <category term="面试" scheme="https://huajiaohuixiang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>目标模块</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/05/%E7%9B%AE%E6%A0%87%E6%A8%A1%E5%9D%97/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/05/%E7%9B%AE%E6%A0%87%E6%A8%A1%E5%9D%97/</id>
    <published>2021-03-05T00:21:17.000Z</published>
    <updated>2021-03-07T02:36:32.530Z</updated>
    
    <content type="html"><![CDATA[<p>1.Lambda表达式<br>2.Stream流计算<br>3.函数式接口</p><p>4.多线程部分</p><p>5.JVM虚拟机</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.Lambda表达式&lt;br&gt;2.Stream流计算&lt;br&gt;3.函数式接口&lt;/p&gt;
&lt;p&gt;4.多线程部分&lt;/p&gt;
&lt;p&gt;5.JVM虚拟机&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Java" scheme="https://huajiaohuixiang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>习概笔记</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/04/%E4%B9%A0%E6%A6%82/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/04/%E4%B9%A0%E6%A6%82/</id>
    <published>2021-03-04T01:13:38.000Z</published>
    <updated>2021-03-04T01:02:59.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>天下为私</p><p>大道之行也，天下为公；</p><p>今大道既隐，天下为家；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;天下为私&lt;/p&gt;
&lt;p&gt;大道之行也，天下为公；&lt;/p&gt;
&lt;p&gt;今大道既隐，天下为家；&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="习概" scheme="https://huajiaohuixiang.github.io/tags/%E4%B9%A0%E6%A6%82/"/>
    
    <category term="毛概" scheme="https://huajiaohuixiang.github.io/tags/%E6%AF%9B%E6%A6%82/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的实现</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-03-02T08:45:02.000Z</published>
    <updated>2021-03-02T09:02:23.116Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单例模式实现的六种方法"><a href="#单例模式实现的六种方法" class="headerlink" title="单例模式实现的六种方法"></a>单例模式实现的六种方法</h4><h5 id="1懒汉模式"><a href="#1懒汉模式" class="headerlink" title="1懒汉模式"></a>1懒汉模式</h5><p> 获取时判断是否为null，然后创建</p><p> 可能会出现线程安全问题，所以对他加上Synchronize</p><h5 id="2-Synchronize修饰的get方法"><a href="#2-Synchronize修饰的get方法" class="headerlink" title="2.Synchronize修饰的get方法"></a>2.Synchronize修饰的get方法</h5><p>  速度会很慢，通过双重校验锁法来实现</p><h5 id="3-双重校验锁法"><a href="#3-双重校验锁法" class="headerlink" title="3.双重校验锁法"></a>3.双重校验锁法</h5><p>在get方法中，先判断是否为null，为空则加一个Synchronize代码块，里面还需要再判断一次，因为可能有多个线程同时阻塞在了这里，当第一个创建好后，没有判断的话还会创建其他的。</p><p>实例需要添加volatile修饰符  禁止指令重排序保证线程安全</p><h4 id="4-饿汉模式"><a href="#4-饿汉模式" class="headerlink" title="4.饿汉模式"></a>4.饿汉模式</h4><p>直接在定义的时候就实现</p><h4 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5.静态内部类"></a>5.静态内部类</h4><p>定义一个静态内部类</p><p>通过一个方法返回该内部类</p><p>实现了懒加载</p><h4 id="6-枚举类实现"><a href="#6-枚举类实现" class="headerlink" title="6.枚举类实现"></a>6.枚举类实现</h4><p><a href="https://cloud.tencent.com/developer/article/1497592">https://cloud.tencent.com/developer/article/1497592</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;单例模式实现的六种方法&quot;&gt;&lt;a href=&quot;#单例模式实现的六种方法&quot; class=&quot;headerlink&quot; title=&quot;单例模式实现的六种方法&quot;&gt;&lt;/a&gt;单例模式实现的六种方法&lt;/h4&gt;&lt;h5 id=&quot;1懒汉模式&quot;&gt;&lt;a href=&quot;#1懒汉模式&quot; class</summary>
      
    
    
    
    
    <category term="Java" scheme="https://huajiaohuixiang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/01/HashMap/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/01/HashMap/</id>
    <published>2021-03-01T15:02:58.000Z</published>
    <updated>2021-03-02T07:02:01.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hash table based implementation of the &#123;@code Map&#125; interface.  This</span></span><br><span class="line"><span class="comment">//implementation provides all of the optional map operations, and permits</span></span><br><span class="line"><span class="comment">//&#123;@code null&#125; values and the &#123;@code null&#125; key. </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*  实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap继承于抽象Map类，抽象Map类为Map接口实现了一些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//This implementation provides constant-time performance for the basic</span></span><br><span class="line"><span class="comment">//operations (&#123;@code get&#125; and &#123;@code put&#125;), </span></span><br></pre></td></tr></table></figure><p>HasmMap实现了常量级的get和put操作实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//An instance of &#123;@code HashMap&#125; has two parameters that affect its</span></span><br><span class="line"><span class="comment">//performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.</span></span><br></pre></td></tr></table></figure><p>HashMap是不同步的，可以在外面套一个 Collections.synchronizedMap来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap(...));</span><br></pre></td></tr></table></figure><p>HashMap通常使用数组+链表的实现方式，当bins变得很大时，链表会变成红黑树，每一个bin都相当于TreeMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This map usually acts as a binned (bucketed) hash table, but</span></span><br><span class="line"><span class="comment">* when bins get too large, they are transformed into bins of</span></span><br><span class="line"><span class="comment">* TreeNodes, each structured similarly to those in</span></span><br><span class="line"><span class="comment">* java.util.TreeMap. Most methods try to use normal bins, but</span></span><br><span class="line"><span class="comment">* relay to TreeNode methods when applicable (simply by checking</span></span><br><span class="line"><span class="comment">* instanceof a node).  Bins of TreeNodes may be traversed and</span></span><br><span class="line"><span class="comment">* used like any others, but additionally support faster lookup</span></span><br><span class="line"><span class="comment">* when overpopulated. However, since the vast majority of bins in</span></span><br><span class="line"><span class="comment">* normal use are not overpopulated, checking for existence of</span></span><br><span class="line"><span class="comment">* tree bins may be delayed in the course of table methods.</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><h4 id="2-一些参数fields"><a href="#2-一些参数fields" class="headerlink" title="2.一些参数fields"></a>2.一些参数fields</h4><p>DEFAULT_INITIAL_CAPACITY初始化容量，默认16，且必须是2的幂。（为何要2的幂，因为哈希函数为hash(key)&amp; capacity-1 这样就可以很快的确定位置（如果使用hash%数组大小的话也可以，但是会很慢）。<a href="https://www.iteye.com/topic/539465%EF%BC%89">https://www.iteye.com/topic/539465）</a></p><p>MAXIMUM_CAPACITY 最大容量小于2^30。</p><p>DEFAULT_LOAD_FACTOR默认加载因子 0.75.</p><p>TREEIFY_THRESHOLD 当bins中的节点大于其是会转化为红黑树</p><p>UNTREEIFY_THRESHOLD 小于其时会变成链表</p><p>MIN_TREEIFY_CAPACITY 最小表容量应大于4*TREEIFY_THRESHOLD</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-Node类-普通Node和TreNode"><a href="#3-Node类-普通Node和TreNode" class="headerlink" title="3.Node类 普通Node和TreNode"></a>3.Node类 普通Node和TreNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.类的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;<span class="comment">//获得类的哈希值 右移16位</span></span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//https://blog.csdn.net/qq_42034205/article/details/90384772</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns x&#x27;s Class if it is of the form &quot;class C implements</span></span><br><span class="line"><span class="comment"> * Comparable&lt;C&gt;&quot;, else null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; ParameterizedType p;</span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Type t : ts) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((t <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType) t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable</span></span><br><span class="line"><span class="comment"> * class), else 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> 检查所传的参数是否为2的幂次方，且不能为负数（负数变为1），且不能超过常量MAXIMUM_CAPACITY（超过变为MAXIMUM_CAPACITY），如果不为2的幂次方，将其变为，比cap大的最小的2的幂次方的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-fields"><a href="#5-fields" class="headerlink" title="5.fields"></a>5.fields</h4><h5 id="Node表"><a href="#Node表" class="headerlink" title="Node表"></a>Node表</h5><p>transient<a href="https://www.cnblogs.com/lanxuezaipiao/p/3369962.html">https://www.cnblogs.com/lanxuezaipiao/p/3369962.html</a></p><h5 id="entrySet键值对集合"><a href="#entrySet键值对集合" class="headerlink" title="entrySet键值对集合"></a>entrySet键值对集合</h5><h5 id="当前数量size"><a href="#当前数量size" class="headerlink" title="当前数量size"></a>当前数量size</h5><h5 id="结构性修改的次数modcount"><a href="#结构性修改的次数modcount" class="headerlink" title="结构性修改的次数modcount"></a>结构性修改的次数modcount</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>threshold  当size&gt;threhold时变成红黑树。</p><h5 id="加载因子，默认0-75"><a href="#加载因子，默认0-75" class="headerlink" title="加载因子，默认0.75"></a>加载因子，默认0.75</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h4 id="6-构造函数"><a href="#6-构造函数" class="headerlink" title="6.构造函数"></a>6.构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &#123;<span class="doctag">@code</span> HashMap&#125; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &#123;<span class="doctag">@code</span> Map&#125;.  The &#123;<span class="doctag">@code</span> HashMap&#125; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &#123;<span class="doctag">@code</span> Map&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment"> * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7.get方法"></a>7.get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">get()方法调用getNode方法，传入hash值和key值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> 如果 table不为空 table[(n - 1) &amp; hash]不为空，说明该点有值</span></span><br><span class="line"><span class="comment"> 判断第一个是不是，然后往下判断</span></span><br><span class="line"><span class="comment"> 如果是TreeNode类型，直接getTreeNode();</span></span><br><span class="line"><span class="comment"> 否则链表往下判断；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node &lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-put方法"><a href="#8-put方法" class="headerlink" title="8.put方法"></a>8.put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">调用putVal方法，设置值或更新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment"> *         (A &#123;<span class="doctag">@code</span> null&#125; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &#123;<span class="doctag">@code</span> null&#125; with &#123;<span class="doctag">@code</span> key&#125;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//如果table为空，resize一下</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//如果当前table中(n - 1) &amp; hash位置为空，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果不为空，找到key的那个entry</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//先判断第一个</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//然后往下判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//如果是Tree实现的，调用树的putTreeVal()方法</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//说明是链表实现的 循环判断</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">//查找后存在该点，更新值返回oldValue existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明原来table中没有带key的entry ，插入了一个新的，判断是否需要resize()</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-resize方法"><a href="#9-resize方法" class="headerlink" title="9.resize方法"></a>9.resize方法</h4><p>分为三步：获取原表、创建新表、为新表添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一部分</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;  <span class="comment">//复制旧表</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//获得旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">//旧阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;<span class="comment">//新容量和新阈值</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//分支1</span></span><br><span class="line">        <span class="comment">//说明原来表中有东西zMAX_VALUE</span></span><br><span class="line">        <span class="comment">//可能是添加的时候或者其他时调用了resize方法，然后将xin容量设置为原来的两倍且小于MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="comment">//对于阈值：如果本来的oldcap已经是MAXIMUM_CAPACITY，那么将阈值调为整数最大值，其实就是MAXIMUM_CAPACITY，这样不会再扩大容量，如果newcap还是小于MAXIMUM_CAPACITY，则也将新阈值*2</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">//分支2</span></span><br><span class="line">        <span class="comment">//说明原来表里没有元素，但是还调用了resize，说明调用了带初始容量的构造方法</span></span><br><span class="line">        <span class="comment">//只需要将新容量设置为旧的阈值，然后一会判断一下新阈值是否是0；如果是0，则将新阈值设置为容量*加载因子</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">//分支3</span></span><br><span class="line">        <span class="comment">//到这里就是一开始是调用了无参构造方法，只需将容量阈值设置成默认的即可。</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面的对分支2没有设置新阈值的情况在判断一下，设置一下新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三部分</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//创建新Node数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果旧数组为空，则不需要复制；不为空就需要执行下面的赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;<span class="comment">//循环遍历数组</span></span><br><span class="line">           <span class="comment">//判断下当前位置是否有值，没有则跳过，有就将旧的复制到新的里面</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="comment">//HashMap使用数组+链表或者数组+红黑树，需要分三种情况讨论</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//说明当前桶内只有一个节点，直接复制</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是TreeNode的情况</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//链表的情况，而且由于新表是原表的两倍大。对于新表的哈希地址其实有两种情况，低位和高位，分别对应c1，c2</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//c1  如果等于0 说明e.hash的第i位是0,因为oldcap的第i位是1，当我们把newcap=oldcap&lt;&lt;1时，e.hash&amp;newCap-1不会发生变化</span></span><br><span class="line">                            <span class="comment">//说明是要放在低位</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//c2</span></span><br><span class="line">                            <span class="comment">//说明要放在高位</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将低位链表放在低位</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将低位链表放在高位</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是TreeNode类的静态方法split，将某个树枝拆分为高位树枝和低位树枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment"> * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment"> * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2021/3/2未完</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    
    <category term="Java" scheme="https://huajiaohuixiang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashTable</title>
    <link href="https://huajiaohuixiang.github.io/2021/03/01/HashTable/"/>
    <id>https://huajiaohuixiang.github.io/2021/03/01/HashTable/</id>
    <published>2021-03-01T14:59:01.000Z</published>
    <updated>2021-03-01T15:03:30.054Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210301230055892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YWppYW9odWl4aWFuZw==,size_16,color_FFFFFF,t_70"></p><p>HashTable继承于Dictionary类，字典类是一个抽象类，而且已经被废弃了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">NOTE:</span> This class is obsolete.  New implementations should</span></span><br><span class="line"><span class="comment">//implement the Map interface, rather than extending this class.</span></span><br></pre></td></tr></table></figure><p>对于Hashtable使用场景也很少，因为JDK中有一个和他类似的类，HashMap。</p><p>Hashtable和Hashmap的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(The &#123;<span class="meta">@code</span> HashMap&#125;<span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">roughly</span> <span class="title">equivalent</span> <span class="title">to</span> </span>&#123;<span class="meta">@code</span> Hashtable&#125;, except that it is unsynchronized and permits nulls.) </span><br></pre></td></tr></table></figure><p>HashTable比HashMap多了同步，少了对null的支持，，所以我们可以直接移步到HashMap。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
    <category term="Java" scheme="https://huajiaohuixiang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Synchronize</title>
    <link href="https://huajiaohuixiang.github.io/2021/02/25/Synchronize/"/>
    <id>https://huajiaohuixiang.github.io/2021/02/25/Synchronize/</id>
    <published>2021-02-25T08:53:35.000Z</published>
    <updated>2021-03-08T12:27:50.497Z</updated>
    
    <content type="html"><![CDATA[<p>Synchronized的用法<br><a href="https://blog.csdn.net/luoweifu/article/details/46613015">https://blog.csdn.net/luoweifu/article/details/46613015</a></p><p>额外：<br>同步与互斥的区别：<a href="https://www.cnblogs.com/baizhanshi/p/6844356.html">https://www.cnblogs.com/baizhanshi/p/6844356.html</a></p><p>进程线程基础<br><a href="https://blog.csdn.net/luoweifu/article/details/46595285">https://blog.csdn.net/luoweifu/article/details/46595285</a><br>java中的 多线程<a href="https://blog.csdn.net/luoweifu/article/details/46673975">https://blog.csdn.net/luoweifu/article/details/46673975</a></p><p>3/2更新</p><p>Synchronized的原理：</p><p>详细<a href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a></p><p>简单<a href="https://blog.csdn.net/u011212394/article/details/82228321">https://blog.csdn.net/u011212394/article/details/82228321</a></p><p>偏向锁、轻量锁、重量锁的升级 <a href="https://www.cnblogs.com/mcjhcnblogs/p/14226505.html">https://www.cnblogs.com/mcjhcnblogs/p/14226505.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Synchronized的用法&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/luoweifu/article/details/46613015&quot;&gt;https://blog.csdn.net/luoweifu/article/details/46613</summary>
      
    
    
    
    
    <category term="Java" scheme="https://huajiaohuixiang.github.io/tags/Java/"/>
    
    <category term="操作系统" scheme="https://huajiaohuixiang.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Redis、Mysql</title>
    <link href="https://huajiaohuixiang.github.io/2021/02/23/%E5%AE%89%E8%A3%85Redis%EF%BC%8CMysql/"/>
    <id>https://huajiaohuixiang.github.io/2021/02/23/%E5%AE%89%E8%A3%85Redis%EF%BC%8CMysql/</id>
    <published>2021-02-23T09:06:01.000Z</published>
    <updated>2021-02-23T14:40:35.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-Ubuntu18-01安装redis和Mysql"><a href="#Linux-Ubuntu18-01安装redis和Mysql" class="headerlink" title="Linux Ubuntu18.01安装redis和Mysql"></a>Linux Ubuntu18.01安装redis和Mysql</h3><h4 id="1-安装redis"><a href="#1-安装redis" class="headerlink" title="1.安装redis"></a>1.安装redis</h4><p>​    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure><h4 id="2-启动redis"><a href="#2-启动redis" class="headerlink" title="2.启动redis"></a>2.启动redis</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><h4 id="3-让其他电脑可以访问"><a href="#3-让其他电脑可以访问" class="headerlink" title="3.让其他电脑可以访问"></a>3.让其他电脑可以访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S redis_server 显示包含此软件包的所有位置，</span><br></pre></td></tr></table></figure><p>有一个/etc/redis/redis.conf  文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/redis/redis.conf  <span class="comment">//打开</span></span><br></pre></td></tr></table></figure><p>关闭保护模式并将127.0.0.1换成0.0.0.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 ::1     换成 bind 0.0.0.0 ::1</span><br><span class="line">protected-mode yes     换成 protected-mode no</span><br></pre></td></tr></table></figure><p>保存退出重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart redis-server</span><br></pre></td></tr></table></figure><h4 id="1-安装Mysql"><a href="#1-安装Mysql" class="headerlink" title="1.安装Mysql"></a>1.安装Mysql</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br><span class="line">sudo systemctl status mysql  //安装完成后输入这个看看状态</span><br></pre></td></tr></table></figure><h4 id="2-然后可以根据阿里云的这个增加一下数据库安全"><a href="#2-然后可以根据阿里云的这个增加一下数据库安全" class="headerlink" title="2.然后可以根据阿里云的这个增加一下数据库安全"></a>2.然后可以根据阿里云的这个增加一下数据库安全</h4><p><a href="https://yq.aliyun.com/articles/758177">https://yq.aliyun.com/articles/758177</a></p><h4 id="3-配置外网访问"><a href="#3-配置外网访问" class="headerlink" title="3.配置外网访问"></a>3.配置外网访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/mysql</span><br><span class="line"></span><br><span class="line">//然后ls一下 我的有下面这些东西，配置文件在mysql.conf.d中</span><br><span class="line">//conf.d      debian-start  my.cnf.fallback  mysql.conf.d</span><br><span class="line">//debian.cnf  my.cnf        mysql.cnf</span><br><span class="line"></span><br><span class="line">cd mysql.conf.d</span><br><span class="line">vim mysqld.cnf</span><br><span class="line">     //将地址127.0.0.1 改成0.0.0.0</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux-Ubuntu18-01安装redis和Mysql&quot;&gt;&lt;a href=&quot;#Linux-Ubuntu18-01安装redis和Mysql&quot; class=&quot;headerlink&quot; title=&quot;Linux Ubuntu18.01安装redis和Mysql&quot;&gt;</summary>
      
    
    
    
    
    <category term="Ubuntu" scheme="https://huajiaohuixiang.github.io/tags/Ubuntu/"/>
    
    <category term="Redis" scheme="https://huajiaohuixiang.github.io/tags/Redis/"/>
    
    <category term="Mysql" scheme="https://huajiaohuixiang.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>拦截器</title>
    <link href="https://huajiaohuixiang.github.io/2021/02/23/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://huajiaohuixiang.github.io/2021/02/23/%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2021-02-23T09:06:01.000Z</published>
    <updated>2021-02-23T14:40:41.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot配置拦截器"><a href="#SpringBoot配置拦截器" class="headerlink" title="SpringBoot配置拦截器"></a>SpringBoot配置拦截器</h3><h4 id="1-实现一个拦截器"><a href="#1-实现一个拦截器" class="headerlink" title="1.实现一个拦截器"></a>1.实现一个拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实现HandlerInterceptor</span><br><span class="line">重写preHandle方法，postHandler，afterCompletion方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//这里就可以根据request判断token session等等。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进入拦截器啦！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了TestInterceptor的afterCompletion方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.将拦截器配置到SpringBoot程序中，在Spring中，使用XML的方式，而在Boot中只需要定义一个带有@Configuration的配置类即可，需要实现WebMvcConfigure接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testMvcConfigure</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        InterceptorRegistration registration = registry.addInterceptor(<span class="keyword">new</span> testInterceptor());</span><br><span class="line">        registration.addPathPatterns(<span class="string">&quot;/**&quot;</span>);                      <span class="comment">//所有路径都被拦截</span></span><br><span class="line">        registration.excludePathPatterns(                         <span class="comment">//添加不拦截路径</span></span><br><span class="line">                <span class="string">&quot;/vip/wang&quot;</span>          </span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SpringBoot配置拦截器&quot;&gt;&lt;a href=&quot;#SpringBoot配置拦截器&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot配置拦截器&quot;&gt;&lt;/a&gt;SpringBoot配置拦截器&lt;/h3&gt;&lt;h4 id=&quot;1-实现一个拦截器&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://huajiaohuixiang.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer38</title>
    <link href="https://huajiaohuixiang.github.io/2021/02/23/%E5%89%91%E6%8C%87offer38/"/>
    <id>https://huajiaohuixiang.github.io/2021/02/23/%E5%89%91%E6%8C%87offer38/</id>
    <published>2021-02-23T02:40:18.000Z</published>
    <updated>2021-02-23T05:37:18.152Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>一开始的做法，回溯法模拟了一遍全排列；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; tempResult;<span class="comment">//因为字符串中可能有重复的元素，所以用了它去重</span></span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;used.push_back(<span class="literal">false</span>);&#125;</span><br><span class="line">        huiSu(tempResult,s,temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:tempResult)&#123;</span><br><span class="line">            result.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">huiSu</span><span class="params">(<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; result,<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp; temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.length()==s.length())&#123;</span><br><span class="line">            result.insert(temp);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[j])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;     </span><br><span class="line">            temp.push_back(s[j]);</span><br><span class="line">            used[j]=<span class="literal">true</span>;</span><br><span class="line">            huiSu(result,s,temp);</span><br><span class="line">            used[j]=<span class="literal">false</span>;</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于有重复元素的情况，我使用了set集合先把所有的结果加进去，然后再返回到vector中</p><p>还可以先将字符串排序，排序后相同的元素在一起，然后把他们看成一个即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span>&amp; temp,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size()==s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;s[i<span class="number">-1</span>]==s[i]&amp;&amp;!used[i<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                temp.push_back(s[i]);</span><br><span class="line">                used[i]=<span class="literal">true</span>;</span><br><span class="line">                backtrack(s,temp,used);</span><br><span class="line">                used[i]=<span class="literal">false</span>;</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;used(s.size());</span><br><span class="line">        backtrack(s,temp,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进行通过字符交换来实现全排列,然后使用unordered_set去重（这个去重与上面的作用完全不一样），如果某个已经交换过了，就不用在交换了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        dfs(s, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt;= s.size()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; used;  <span class="comment">//局部set去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = depth; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used.find(s[i]) != used.end())   <span class="keyword">continue</span>;   <span class="comment">//去重</span></span><br><span class="line">            used.insert(s[i]);</span><br><span class="line">            swap(s[depth],s[i]);</span><br><span class="line">            dfs(s, res, depth+<span class="number">1</span>);</span><br><span class="line">            swap(s[depth],s[i]);        <span class="comment">//回溯撤销操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：zrita</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/chui-su-z-by-zrita-gvc0/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入一个字符串，打印出该字符串中字符的所有排列。&lt;br&gt;你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入：s = “abc”&lt;br&gt;输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://huajiaohuixiang.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Lambda</title>
    <link href="https://huajiaohuixiang.github.io/2021/02/22/Lambda/"/>
    <id>https://huajiaohuixiang.github.io/2021/02/22/Lambda/</id>
    <published>2021-02-22T09:07:05.000Z</published>
    <updated>2021-02-22T09:07:05.357Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>maven</title>
    <link href="https://huajiaohuixiang.github.io/2021/02/22/maven/"/>
    <id>https://huajiaohuixiang.github.io/2021/02/22/maven/</id>
    <published>2021-02-22T09:06:43.000Z</published>
    <updated>2021-02-22T09:06:43.134Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>单元测试</title>
    <link href="https://huajiaohuixiang.github.io/2021/02/22/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://huajiaohuixiang.github.io/2021/02/22/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2021-02-22T09:06:17.000Z</published>
    <updated>2021-02-22T09:06:17.250Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
