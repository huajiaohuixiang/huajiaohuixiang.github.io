<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="2021/05/13/test/"/>
      <url>2021/05/13/test/</url>
      
        <content type="html"><![CDATA[<h1>111</h1><h2 id="222">222</h2><h3 id="333">333</h3><h4 id="444">444</h4><h5 id="555">555</h5><h6 id="666">666</h6><p>777</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用frp进行内网穿透</title>
      <link href="2021/05/13/%E4%BD%BF%E7%94%A8frp%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>2021/05/13/%E4%BD%BF%E7%94%A8frp%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<p>之前使用花生壳来进行内网穿透，只能穿透一个，相当于没有，然后发现了frp这个神仙项目。</p><p>frp可以通过一个有公网IP的服务器来进行转发，服务器启动frps，内网机器启动frps，然后就可以访问内网机器啦。</p><h4 id="搭建过程">搭建过程</h4><h6 id="硬件条件">硬件条件</h6><p>Jetson Nano B01 ，阿里云服务器一台，域名一个。</p><h6 id="下载frp">下载frp</h6><p>首先下载frp项目，<a href="https://github.com/fatedier/frp/releases%EF%BC%8C%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E8%AF%A5%E6%98%AF%E8%A6%81%E4%B8%8B%E8%BD%BDfrp_0.36.2_linux_amd64.tar.gz%EF%BC%8C%E7%84%B6%E5%90%8E%E8%A7%A3%E5%8E%8B%E3%80%82Jetson">https://github.com/fatedier/frp/releases，阿里云服务器应该是要下载frp_0.36.2_linux_amd64.tar.gz，然后解压。Jetson</a> nano需要下载frp_0.36.2_linux_arm.tar.gz，然后解压。</p><h6 id="观察frp配置文件">观察frp配置文件</h6><p>里面一共有一个systemd文件夹和frpc、frpc.ini、frpc_full.ini、frps、frps.ini、frps_full.ini。systemd先不用管，后面才会用到。</p><p>其中frpc和frps是两个启动程序。其余四个ini分别是启动程序的简单配置例子和详细配置例子。</p><h6 id="实现ssh">实现ssh</h6><p>如果要实现ssh ，服务器和内网机器分别要进行以下配置。</p><p>服务器需要配置frps.ini文件，其实不用变哈哈，本来就是这样。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure><p>然后内网机器需要进行一哈配置frpc.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment">#这个是服务器的公网IP地址</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment">#这个是服务器的监听端口，需要和服务器配置文件中的bind_port相同</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的ssh配置</span></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="comment">#类型是tcp</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"></span><br><span class="line"><span class="comment">#本地ip地址，可以是192.168.1.xxx这种，如果是127.0.0.1就是本机</span></span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span>、</span><br><span class="line"></span><br><span class="line"><span class="comment">#本地端口</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务器端口，我们连接的时候连接服务器的6000端口就好了</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><h6 id="实现http">实现http</h6><p>服务器的frps.ini配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#表示用10000来监听http</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">10000</span>  </span><br></pre></td></tr></table></figure><p>本地的frpc.ini配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x  </span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[web]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">10000</span></span><br><span class="line"><span class="attr">custom_domains</span> = 你的域名<span class="number">1</span>或者ip地址</span><br><span class="line"></span><br><span class="line"><span class="section">[web2]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">100001</span></span><br><span class="line"><span class="attr">custom_domains</span> = 你的域名<span class="number">2</span>或者ip地址</span><br></pre></td></tr></table></figure><p>因为每个web中的custom_domains都必须不同，如果直接写服务器的公网ip的话，只能实现一个http的转发，如果你有域名的话，是可以创建很多子域名，因此可以实现很多http转发。只需要在本地机器的frpc.ini中增加local_port和custon_domains即可。</p><h6 id="将其注册成服务">将其注册成服务</h6><p>我是看着这个教程做的https://blog.csdn.net/fjh1997/article/details/103672631，但是文中应该是有一个错误，“我们把下载好的所有*.ini文件放到/etc/frpc/目录下”，因为frpc@.service中的路径是 /etc/frp 所以应该放在 /etc/frp下。如果放在了frpc下需要改一下service中的路径。</p><p>还记得之前的systemd文件夹吗，那个就是注册成服务用的。</p><p>cd systemd进入文件夹 ls</p><p>一共有四个文件 frpc.service 和 frpc@.service还有frps的，带@和不带@的区别就是带@可以在启动服务的时候指定配置文件，不带@的只能使用文件中固定的配置文件</p><p>下面是frpc@.service的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Frp Client Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=idle</span><br><span class="line">User=nobody</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line">ExecStart=/usr/bin/frpc -c /etc/frp/%i.ini    #重点</span><br><span class="line">ExecReload=/usr/bin/frpc reload -c /etc/frp/%i.ini#重点</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>比较重要的就是这两个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/frpc -c /etc/frp/%i.ini   </span><br><span class="line"><span class="meta">#</span><span class="bash">这两个分别是frpc的路径和 frpc.ini的路径，其中frpc.ini通过%i实现了实时替换</span></span><br></pre></td></tr></table></figure><p>所以我们重点就是将 frpc 移动到 /usr/bin/下 ， 将 frpc.ini移动带 /etc/frp/下 ， 将frpc@.service移动到/etc/systemd/system/下。</p><p>然后通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable frpc@frpc  #这步用来注册服务     第一个frpc表示在/etc/systemd/system/下的frpc@.service，第二个frpc表示配置文件的前缀</span><br><span class="line">systemctl start frpc@frpc   #这步用来启动服务 通过x@x来表示 </span><br><span class="line">systemctl restart frpc@test  #如果我想更改配置，那么可以在/etc/frp/下创建test.ini，然后通过这个重新启动。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于frps也一样哦，移动三个文件，然后注册服务、启动，大功告成啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> frp </tag>
            
            <tag> 服务器搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java锁和并发</title>
      <link href="2021/05/12/Java%E9%94%81%E5%92%8C%E5%B9%B6%E5%8F%91/"/>
      <url>2021/05/12/Java%E9%94%81%E5%92%8C%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h4 id="Synchronized实现原理"><a href="#Synchronized实现原理" class="headerlink" title="Synchronized实现原理"></a>Synchronized实现原理</h4><p>通过加锁来实现同步，在编译之后，通过在代码块前后加monitor enter和exit来实现；</p><p>分别修饰代码块、修饰方法、修饰静态方法，加锁的对象。</p><p>每个对象都是由对象头、对象实际数据、填充组成的。</p><p>对象头中的MarkWord会记录锁的信息，对于不同的锁格式不相同。</p><p>如果是重量级锁的话，存储了指向重量级锁的指针。偏向锁就是存储了线程ID等信息。</p><p>轻量级锁指向线程中markword副本。</p><h4 id="Synchronized如何实现可重入"><a href="#Synchronized如何实现可重入" class="headerlink" title="Synchronized如何实现可重入"></a>Synchronized如何实现可重入</h4><p>每个锁对象内部维护一个计数器，该计数器初始值为0，表示任何线程都可以获取该锁并执行相应的方法。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p><h4 id="ReentrantLock如何实现可重入"><a href="#ReentrantLock如何实现可重入" class="headerlink" title="ReentrantLock如何实现可重入"></a>ReentrantLock如何实现可重入</h4><p> ReentrantLock在内部使用了内部类Sync来管理锁，所以真正的获取锁是由Sync的实现类控制的。Sync有两个实现，分别为NonfairSync（非公平锁）和FairSync（公平锁）。Sync通过继承AQS实现，在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作带来效率问题。3个状态：没占用是0，占用了是1，大于1是可重入锁</p><p>AQS<a href="https://javadoop.com/post/AbstractQueuedSynchronizer">https://javadoop.com/post/AbstractQueuedSynchronizer</a></p><h4 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h4><h4 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h4><h4 id="synchronized锁升级的原理？"><a href="#synchronized锁升级的原理？" class="headerlink" title="synchronized锁升级的原理？"></a>synchronized锁升级的原理？</h4><p>在无锁状态下markword中偏向标志为0，如果这时有线程请求锁并且设置了可以是偏向锁就将偏向标志设为1 .线程ID设置为当前线程。如果这时候另外一个线程请求锁，锁就会升级为轻量级锁，markword中放着指向线程栈中markword副本的指针，这时候会自旋。如果自旋的线程过多就会升级为重量级锁。</p><h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p>强引用：</p><p>软引用：SoftReference</p><p>弱引用：WeakReference</p><p>虚引用：</p><h4 id="哪里使用了弱引用？"><a href="#哪里使用了弱引用？" class="headerlink" title="哪里使用了弱引用？"></a>哪里使用了弱引用？</h4><p>ThreadLocal</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>通过ThreadLocal来存储当前线程需要存储变量的一个副本。但实际上ThreadLocal是把这个（它自己，变量）存在了Thread的ThreadLocaMap中，然后通过该ThreadLocal取取值。</p><p>每一个Thread中都有一个ThreadLocalMap，ThreadLocalMap是ThreadLOcal的内部类，ThreadLocalMap里由一个Entry数组实现。</p><p>一个Thread,通过ThreadLocal对象来保存一个值，每个ThreadLocal是键，对应着一个值。如果要保存两个变量就需要两个threadlocal。</p><h4 id="ThreadLocal为什么会造成内存泄漏"><a href="#ThreadLocal为什么会造成内存泄漏" class="headerlink" title="ThreadLocal为什么会造成内存泄漏?"></a>ThreadLocal为什么会造成内存泄漏?</h4><p>因为ThreadLocalMap是在Thread中，ThreadLocalMap中某个V的K指向了ThreadLocal对象，但这个对象是弱引用WeakReference，如果该对象的没有其他强引用之后该对象将被回收。此时Thread将无法获得该V，但是它永远都在Thread的ThreadLocalMap的Entry数组中。</p><h4 id="ThreadLocal正确的使用方法"><a href="#ThreadLocal正确的使用方法" class="headerlink" title="ThreadLocal正确的使用方法"></a>ThreadLocal正确的使用方法</h4><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p><p>悲观锁的实现，往往依靠数据库提供的锁机制。Synchronized  java；数据库的页锁和行锁。</p><p>select…for update 会锁住数据 如果用到了索引是 行锁；没用到索引是表锁。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。CAS+MVCC</p><p>Java中AtomicInteger等</p><p>CAS操作中包括三个操作数：内存中的值，期望的值，修改后的值。每次提交修改后的值要检查期望值于内存中的值是否相同，不相同会失败；相同则成功。</p><p><a href="https://www.cnblogs.com/kyoner/p/11318979.html">https://www.cnblogs.com/kyoner/p/11318979.html</a></p><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行 效率。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢 复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。所以如果处理器有两个以上的核心九合一让后面请求锁的线程多等一会而不是加入阻塞队列然后挂起。多等一会就是通过自旋（忙循环）来实现。</p><p>但是自旋锁会占用处理器时间，所以需要设定一个自旋次数，默认十次，超过后就挂起。</p><h4 id="适应性自旋"><a href="#适应性自旋" class="headerlink" title="适应性自旋"></a>适应性自旋</h4><p>自旋的时间不是固定的，是由前一次在同一个锁上的自选时间以及锁的拥有者的状态来确定的。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>一些代码要求了同步，但是检测不到存在的数据竞争，就可以将这个锁来消除，主要是通过逃逸分析的数据支持来判断。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果一系列的操作对同一个对象进行反复加锁和解锁，甚至在循环体中，那么锁的范围会扩展到整个操作序列的外部。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416194929575.png" alt="image-20210416194929575"></p><p>MarkWord一共32位，在不同的锁状态下有不同的结构</p><p>未锁定和可偏向差不多  标志位都为01  偏向模式不同 可偏向下有一个线程ID指向偏向的线程</p><p>轻量级锁下30位用来存储指向调用栈中锁记录的指针。每个线程在竞争锁的时候都会在本地栈帧放一下对象头，然后CAS尝试修改对象的对象头，如果失败就看一下对象的对象头是否指向自己。</p><p>持有偏向锁的线程访问这个对象不会存在任何同步操作，如果访问的线程不是该偏向锁ID中的线程，那么偏向锁模式会升级为轻量锁</p><p>重量级锁下30 位指向重量级锁的指针。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><a href="https://blog.csdn.net/weixin_42636552/article/details/82383272">https://blog.csdn.net/weixin_42636552/article/details/82383272</a></p><h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p>AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制</p><p>如果当前请求的资源空闲，将当前请求的线程设置为有效的工作线程，那么将其设置为锁定状态（通过CAS修改状态）。如果请求的线程不空闲，那么通过CLH队列锁实现线程的阻塞以及唤醒。</p><p>AQS 定义了两种资源共享方式：<br>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p><p><a href="https://blog.csdn.net/TZ845195485/article/details/109210263">https://blog.csdn.net/TZ845195485/article/details/109210263</a></p><h4 id="https-blog-csdn-net-mulinsen77-article-details-84583716"><a href="#https-blog-csdn-net-mulinsen77-article-details-84583716" class="headerlink" title="https://blog.csdn.net/mulinsen77/article/details/84583716"></a><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">https://blog.csdn.net/mulinsen77/article/details/84583716</a></h4><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>线程控制</p><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>可重置的线程控制</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量来模拟资源</p><h4 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h4><p>阶段性的控制</p><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2021/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="malloc-动态内存分配"><a href="#malloc-动态内存分配" class="headerlink" title="malloc 动态内存分配"></a>malloc 动态内存分配</h4><p>malloc的全称是memory allocation，中文名为<strong>动态内存分配</strong>，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址</p><h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h4><p>clear allocation，中文名为<strong>动态内存分配并清零</strong>如果分配成功则返回指向被分配内存的指针**(此空间中的初始值为0)**，否则返回空指针NULL</p><h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h4><p><strong>动态内存调整</strong></p><p>先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域(原来的指针会自动释放，不需要再使用free)，同时返回新分配的内存区域的首地址。重新分配成功返回指向被分配内存的指针，否则返回空指针NULL。</p><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>使用malloc,calloc,realloc函数进行内存分配后要使用free(起始地址的指针) 对内存进行释放</p><p>在C++中是new  delete</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p><img src="https://upload-images.jianshu.io/upload_images/15744422-0f91fa4d5a55339c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/925/format/webp" alt="img"></p><p>进程切换</p><p>上图展示了进程切换中几个最重要的步骤：</p><ol><li>当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。</li><li>操作系统内核负责保存进程 i 在 CPU 中的上下文（程序计数器， 寄存器）到 PCBi （操作系统分配给进程的一个内存块）中。</li><li>从 PCBj 取出进程 j 的CPU 上下文， 将 CPU 控制权转移给进程 j ， 开始执行进程 j 的指令。</li></ol><h4 id="孤儿进程和僵尸进程的区别？"><a href="#孤儿进程和僵尸进程的区别？" class="headerlink" title="孤儿进程和僵尸进程的区别？"></a>孤儿进程和僵尸进程的区别？</h4><p><a href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p><p>子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p><p>孤儿进程：父进程执行完或被终止，但是它仍在运行。孤儿进程将会被init进行进程号为1的进程收集。</p><p>僵尸进程：是指执行完成后，但是在进程控制块PCB中仍然还有一个表项。一般是由一个进程fork创建子进程，如果子进程退出，但是父进程没有调用wait或waitpid获取子进程的信息，那么子进程的进程描述符仍然在PCB中，这种进程称为姜丝进程。</p><p>每个进程再exit()之后都会成为僵尸进程，但是父进程调用wait后便可以删除PCB中的信息。</p><h4 id="僵尸进程危害？"><a href="#僵尸进程危害？" class="headerlink" title="僵尸进程危害？"></a>僵尸进程危害？</h4><p>孤儿进程会被init进程收集，不会产生危害。</p><p>僵尸进程：但是如果父进程没有调用wait或者waitpid来获取子进程结束的信息，那么PCB中的信息将不会被释放，进程号一直被占用。</p><h4 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>（1）通过信号，子进程结束的时候向父进程发送一个信号，在信号处理函数中调用wait进行处理僵尸进程。</p><p><strong>（2）fork两次</strong>原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>守护进程是一个在后台运行并且不受任何终端控制的进程。</p><h4 id="如何创建守护进程？"><a href="#如何创建守护进程？" class="headerlink" title="如何创建守护进程？"></a>如何创建守护进程？</h4><p><strong>(1)创建子进程，终止父进程</strong></p><p>由于守护进程是脱离控制终端的，因此首先创建子进程，终止父进程，使得程序在shell终端里造成一个已经运行完毕的假象。之后所有的工作都在子进程中完成，而用户在shell终端里则可以执行其他的命令，从而使得程序以僵尸进程形式运行，在形式上做到了与控制终端的脱离。</p><p><strong>(2)在子进程中创建新会话</strong></p><p>这个步骤是创建守护进程中最重要的一步，在这里使用的是系统函数setsid。</p><p>setsid函数用于创建一个新的会话，并担任该会话组的组长。调用setsid仃三个作用：让进程摆脱原会话的控制、让进程摆脱原进程组的控制和让进程摆脱原控制终端的控制。</p><p>在调用fork函数时，<a href="https://baike.baidu.com/item/%E5%AD%90%E8%BF%9B%E7%A8%8B">子进程</a>全盘拷贝父进程的会话期(session，是一个或多个进程组的集合)、进程组、控制终端等，虽然父进程退出了，但原先的会话期、进程组、控制终端等并没有改变，因此，那还不是真正意义上使两者独立开来。setsid函数能够使进程完全独立出来，从而脱离所有其他进程的控制。</p><p><strong>(3)改变工作目录</strong></p><p>使用fork创建的子进程也继承了父进程的当前工作目录。由于在进程运行过程中，当前目录所在的文件系统不能卸载，因此，把当前工作目录换成其他的路径，如“/”或“/tmp”等。改变工作目录的常见函数是chdir。</p><p><strong>(4)重设文件创建掩码</strong></p><p>文件创建掩码是指屏蔽掉文件创建时的对应位。由于使用fork函数新建的子进程继承了父进程的文件创建掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件创建掩码设置为0，可以大大增强该守护进程的灵活性。设置文件创建掩码的函数是umask，通常的使用方法为umask(0)。</p><p>(5)关闭[文件描述符]</p><p>用fork新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，可能导致所在的文件系统无法卸载</p><p>syslogd</p><h4 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h4><p>第一类：传统的Unix通信机制</p><ol><li>管道/匿名管道(pipe)</li></ol><p>管道的实质：<br>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><ol start="2"><li><p>有名管道(FIFO)</p><p>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p></li><li><p>信号(Signal)</p><p>​    信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></li><li><p>消息(Message)队列</p><p>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>共享内存(share memory)</p><p>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p></li><li><p>信号量(semaphore)</p><p>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p></li><li><p>套接字(socket)</p><p>可用于不同机器间的进程通信。</p></li></ol><h4 id="linux底层是怎么创建线程的"><a href="#linux底层是怎么创建线程的" class="headerlink" title="linux底层是怎么创建线程的"></a>linux底层是怎么创建线程的</h4><p><a href="https://blog.csdn.net/melody157398/article/details/104912317">https://blog.csdn.net/melody157398/article/details/104912317</a></p><h4 id="0号进程是什么东西"><a href="#0号进程是什么东西" class="headerlink" title="0号进程是什么东西"></a>0号进程是什么东西</h4><p><a href="https://www.cnblogs.com/wanghetao/archive/2012/03/29/2422723.html">Linux中的0号进程和1号进程 </a>     </p><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。整个linux系统的所有进程也是一个树形结 构。树根是系统自动构造的，即在内核态下执行的0号进程，它是所有进程的祖先。由0号进程创建1号进程（内核态），1号负责执行内核的部分初始化工作及进 行系统配置，并创建若干个用于高速缓存和虚拟主存管理的内核线程。随后，1号进程调用execve（）运行可执行程序init，并演变成用户态1号进程， 即init进程。它按照配置文件/etc/initab的要求，完成系统启动工作，创建编号为1号、2号…的若干终端注册进程getty</p><h4 id="进程调度的几种方式"><a href="#进程调度的几种方式" class="headerlink" title="进程调度的几种方式"></a>进程调度的几种方式</h4><ol><li><p>先来先服务  有利于长作业，不利于短作业</p><p>​    最短作业优先    短作业先行，长作业有可能长时间无法执行</p><p>短作业优先</p></li><li><p>带有优先级的    抢占式和非抢占式，</p><p>每个进行都有一个优先级，系统会先给优先级高的分配，对于抢占式的，如果当前进程正在执行，然后来了一个优先级高的，当前进程就阻塞，先给优先级高的执行；非抢占的就是先执行完当前这个在给优先级高的执行</p></li><li><p>最短作业优先</p><p>​    </p></li><li><p>时间片轮转</p><p>​    每个进程都执行一段时间 按FCFS排队，比较重要的是如何确定时间片长度；</p></li><li><p>优先级队列</p></li><li><p>多级队列 将上面的算法都结合到了一起</p><p>​    有很多优先级不同的队列，每个优先级执行的时间片长度也不同，优先级越低，时间片越长。当一个进程到来时，先进入第一队列，如果在当前时间段没有运行完，则进入第二队列，然后依次往下。。。当且仅当高优先级处理完后才处理低优先级的队列。</p></li></ol><p><a href="https://www.cnblogs.com/Blog-day/p/My_Blog_Days1-11.html">https://www.cnblogs.com/Blog-day/p/My_Blog_Days1-11.html</a></p><h4 id="操作系统的吧，进程、线程和协程分别是什么以及他们之间的关系"><a href="#操作系统的吧，进程、线程和协程分别是什么以及他们之间的关系" class="headerlink" title="操作系统的吧，进程、线程和协程分别是什么以及他们之间的关系"></a>操作系统的吧，进程、线程和协程分别是什么以及他们之间的关系</h4><p>（自己整理一下答案，到时候就会说了）</p><h4 id="32、64位系统有什么区别"><a href="#32、64位系统有什么区别" class="headerlink" title="32、64位系统有什么区别"></a><strong>32、64位系统有什么区别</strong></h4><p>32位和64位表示CPU一次能处理的最大位数</p><p>32位系统的最大寻址空间是2的32次方=4294967296（bit）= 4（GB）左右；</p><p>64位系统的最大寻址空间为2的64次方=4294967296（bit）的32次方，数值大于1亿GB</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h4><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><p>页式、段式、段页式</p><h4 id="段页式系统访存次数"><a href="#段页式系统访存次数" class="headerlink" title="段页式系统访存次数"></a>段页式系统访存次数</h4><p>3次  段表-&gt;页地址-&gt;页表-&gt;地址 -&gt;访问</p><p>为了访存的次数不这么多，在地址变换机构中增设一个高速缓冲寄存器，从中得到相应页的物理块号。</p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>OPT最佳，因为不可能向后预知，无法实现</p><p>LRU 最近最少未使用</p><p>FIFO先进先出</p><p>LFU最不长使用算法</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁，发生的条件以及如何避免？"><a href="#死锁，发生的条件以及如何避免？" class="headerlink" title="死锁，发生的条件以及如何避免？"></a>死锁，发生的条件以及如何避免？</h4><p><strong>1**</strong>）互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p><p><strong>2**</strong>）请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p><p><strong>3**</strong>）不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p><p><strong>4**</strong>）环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p><h4 id="如何避免？"><a href="#如何避免？" class="headerlink" title="如何避免？"></a>如何避免？</h4><p>通过哲学家就餐问题分析</p><h4 id="杀掉一个进程-9-代表什么（强制）-还有什么其他参数-、-使用kill命令后，操作系统是如何通知进程的"><a href="#杀掉一个进程-9-代表什么（强制）-还有什么其他参数-、-使用kill命令后，操作系统是如何通知进程的" class="headerlink" title="杀掉一个进程         -9 代表什么（强制）         还有什么其他参数    、    使用kill命令后，操作系统是如何通知进程的"></a><strong>杀掉一个进程</strong>         <strong>-9 代表什么</strong>（强制）         <strong>还有什么其他参数</strong>    、    <strong>使用kill命令后，操作系统是如何通知进程的</strong></h4><h4 id="虚拟内存，虚地址实地址"><a href="#虚拟内存，虚地址实地址" class="headerlink" title="虚拟内存，虚地址实地址"></a>虚拟内存，虚地址实地址</h4><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p>FIFO</p><p>最短寻道时间优先</p><p>电梯算法</p><h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><h4 id="系统调用是什么"><a href="#系统调用是什么" class="headerlink" title="系统调用是什么"></a>系统调用是什么</h4><p>系统调用（英语：system call），又称为系统呼叫，指<strong>运行在使用者空间的程序</strong>向<strong>操作系统内核</strong>请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。</p><p>　　操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。</p><p>危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。</p><h4 id="两个进程如何访问临界区？"><a href="#两个进程如何访问临界区？" class="headerlink" title="两个进程如何访问临界区？"></a>两个进程如何访问临界区？</h4><p>1.一个turn 标志哪一个进入  （问题：只能ABABABAB的形式）</p><p>2.设置flag[2]  flag[0]表示A  flag[1]表示B能否进入{<br>    这时候有两种情况  先设置true还是先判断</p><p>​        先判断有可能两个一起进入</p><p>​        先设置有可能两个都进不去    </p><p>​    }</p><p>3.flag[2]+turn </p><p>​    设置flag  设置turn=另外一个  判断 flag&amp;&amp;turn==另外一个  </p><p>​    结束后设置flag</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag[2]  turn</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>同步阻塞IO ：从系统调用开始一直到系统调用结束一直在阻塞。</p><p>阻塞时间太久，基本上会为每一个连接IO分配一个线程，不能处理高并发的情况。</p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210421104956983.png" alt="image-20210421104956983"></p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>同步非阻塞IO： 系统调用开始后一直轮询数据是否准备好，如果准备好了就拷贝数据。</p><p>需要大量的轮询操作，占用大量的CPU时间</p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210421105031788.png" alt="image-20210421105031788"></p><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>同步IO多路复用：线程发起select调用后，询问内核数据是否就绪，等内核准备好了以后用户线程在发起read调用。</p><p>需要不断select轮询，但是它可以通过一个线程处理成千上万个连接。</p><p>使用select的优势在于可以等待多个描述符就绪</p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210421105400836.png" alt="image-20210421105400836"></p><h4 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h4><p>调用后会立即返回，然后再数据准备好的时候会返回一个信号</p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210421105506866.png" alt="image-20210421105506866"></p><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>异步IO： 通过通知回调机制完全不阻塞.对于异步来说，内核是调用的发起方</p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210421105617920.png" alt="image-20210421105617920"></p><h4 id="epoll-基于事件的轮询-也是Reactor设计模式"><a href="#epoll-基于事件的轮询-也是Reactor设计模式" class="headerlink" title="epoll(基于事件的轮询)  也是Reactor设计模式"></a>epoll(基于事件的轮询)  也是Reactor设计模式</h4><p><strong>效率提升</strong>，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><h4 id="Select-poll-和epoll的区别？"><a href="#Select-poll-和epoll的区别？" class="headerlink" title="Select poll  和epoll的区别？"></a>Select poll  和epoll的区别？</h4><p>select使用数组 ，有1024的最大连接限制</p><p>poll使用链表没有最大连接限制</p><p>传统select/poll的另一个致命弱点就是当你拥有一个很大的socket集合，由于网络得延时，使得任一时间只有部分的socket是”活跃” 的，而select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。</p><p>epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd。</p><h4 id="Select、Poll、Epoll详解"><a href="#Select、Poll、Epoll详解" class="headerlink" title="Select、Poll、Epoll详解"></a>Select、Poll、Epoll详解</h4><p><a href="https://www.jianshu.com/p/722819425dbd">https://www.jianshu.com/p/722819425dbd</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="2021/05/12/%E7%BD%91%E7%BB%9C/"/>
      <url>2021/05/12/%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="2021/05/12/redis/"/>
      <url>2021/05/12/redis/</url>
      
        <content type="html"><![CDATA[<p><strong>官方文档也针布错http://redis.cn/documentation.html</strong></p><h4 id="这个博客针布错https-blog-csdn-net-qq-38261137-article-details-106949963">这个博客针布错https://blog.csdn.net/qq_38261137/article/details/106949963</h4><p><a href="https://thinkwon.blog.csdn.net/article/details/103522351">https://thinkwon.blog.csdn.net/article/details/103522351</a></p><h4 id="不能用的命令">不能用的命令</h4><p>keys、flushdb、flushall</p><h4 id="Redis的应用场景">Redis的应用场景</h4><p>总结一</p><p>计数器</p><p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><p>缓存</p><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><p>会话缓存</p><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><p>全页缓存（FPC）</p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p>查找表</p><p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p><p>消息队列(发布/订阅功能)</p><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><p>分布式锁实现</p><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><p>其它</p><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><p>总结二</p><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p><p>数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set</p><p>其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。</p><p>string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。</p><p>hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</p><p>list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。</p><p>set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。</p><p>Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。</p><p>如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。</p><h4 id="过期数据的删除策略">过期数据的删除策略</h4><p>定时  使用定时器，时间到了就删除过期的key</p><p>惰性+定期   每隔一段时间抽取一些key进行检查，然后删除；惰性的话就是用到该key时发现数据过期了就删除该key返回空。</p><p>这样的话还是有很多没有删除，这就需要内存淘汰策略。</p><h4 id="内存淘汰策略-6-内存不够用时，会删除没有过期的">内存淘汰策略*6   内存不够用时，会删除没有过期的</h4><p>设置过期时间的key*3 最近最少未使用、最快要过期的、随机</p><p>所有key*2 随机、最近最少未使用</p><p>不淘汰，内存不足新写入的时候报错。</p><ol start="4"><li>0 引入volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</li></ol><h4 id="手写一下LRU算法实现？">手写一下LRU算法实现？</h4><p>继承于LinkedHashMap</p><p>通过HashMap实现LinkedHashMap</p><h4 id="两种持久化方案">两种持久化方案</h4><p>RDB  AOF</p><p>RDB 每隔一段时间将数据存储到硬盘上，宕机可能会丢失部分数据；如果数据量很大保存时间过长。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期</p><p>AOF 将命令追加到日志记录中，可以选择逐条追加/每秒追加/让操作系统选择</p><ul><li>redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li></ul><p>AOF安全，但是占的空间大，恢复也会比较慢。</p><p>redis默认使用RDB，性能最大化，fork子进程来完成写操作，让主进程继续处理命令，IO最大化，保证了Redis的高性能，数据集大的时候AOF启动效率更高。缺点是数据安全性比较低。</p><p>AOF数据安全，但是占用空间更大，恢复的时候启动效率低。</p><h4 id="什么是事务？">什么是事务？</h4><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h4 id="Redis事务">Redis事务</h4><p>multi   命令入队  exec</p><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><p><strong>Redis的事务总是具有ACID中的一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在<em>AOF</em>持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p><h4 id="Redis和Memchace的区别">Redis和Memchace的区别</h4><p>redis 支持复杂的数据结构</p><p>redis 相比 memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， redis 会是不错的选择。</p><p>redis 原生支持集群模式。在 redis3.x 版本中，便能支持 cluster 模式，而 memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</p><p>性能对比。由于 redis 只使用单核，而 memcached 可以使用多核，所以平均每一个核上 redis 在存储小数据时比 memcached 性能更高。而在 100k 以上的数据中，memcached 性能要高于 redis。虽然 redis 最近也在存储大数据的性能上进行优化，但是比起 memcached，还是稍有逊色。</p><h4 id="redis-的线程模型">redis 的线程模型</h4><p>redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><p>多个 socketIO 多路复用程序文件事件分派器事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。</p><h4 id="哪里使用了缓存？">哪里使用了缓存？</h4><p>快递网点的一些统计信息，总包裹数量等；取件消息进入缓存，通常一个人看到取件消息后至少还要再看一次取件；</p><p>当前仓库和快递柜的包裹信息。</p><p>在抢购优惠券功能上将优惠券剩余量放到了redis中，防止超卖。</p><h4 id="缓存和数据库双写一致性问题">缓存和数据库双写一致性问题</h4><p>只能实现最终一致性不能实现强一致性。</p><h5 id="首先是通过设置过期时间，在过期时间内缓存的值都可能不是干净的。">首先是通过设置过期时间，在过期时间内缓存的值都可能不是干净的。</h5><h5 id="然后是不设置过期时间的三种更新策略：">然后是不设置过期时间的三种更新策略：</h5><ol><li><p>先写数据库，在更新缓存（最不好的）</p><p>因为是更新缓存，存在并发问题，两个线程写数据库的顺序和删除缓存的顺序不一致会导致错误的缓存一直使用</p></li><li><p>先删除缓存在更新数据库，B的查询在A的删除缓存之后A的写入数据库之前，同样会出现很久的错误缓存</p><p>可以采用延迟双删的策略，写入数据库1s后再次删除缓存</p></li><li><p>先更新数据库，在删缓存</p><p>有很小的几率会产生问题，A读取缓存失效，然后读取数据库，之后卡住了，知道B写入数据库之后，写入缓存之后A再写入缓存导致旧的缓存。</p></li></ol><p>每种方法都有删除缓存失败的情况使用失败重试机制，使用消息队列，将需要删除的key放入MQ中。</p><h5 id="就有了通过订阅mysql的binlog来删缓存的操作。">就有了通过订阅mysql的binlog来删缓存的操作。</h5><p>只更缓存，不更MySQL，MySQL由缓存异步的更新</p><p><strong>使用canal解析binlog</strong> Mysql通过binlog同步redis   基于zookeeper临时有序节点可以实现的分布式锁</p><h4 id="Redis为什么快">Redis为什么快</h4><ul><li>纯内存操作。</li><li>核心是基于非阻塞的 IO 多路复用机制。</li><li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题</li></ul><h4 id="讲一下IO多路复用">讲一下IO多路复用</h4><p><img src="C:%5CUsers%5C%E8%8A%B1%E6%A4%92%E8%8C%B4%E9%A6%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210414192259605.png" alt="image-20210414192259605"></p><p>有一个线程监听socket，每来一个事件将其放入到事件队列，然后事件分派器将事件分派到不同的处理器进行处理。</p><p><a href="https://blog.csdn.net/mashaokang1314/article/details/88636371">https://blog.csdn.net/mashaokang1314/article/details/88636371</a></p><p><a href="https://www.cnblogs.com/zwt1990/p/8821185.html">https://www.cnblogs.com/zwt1990/p/8821185.html</a></p><h4 id="redis如何保证高可用的"><a href="https://www.nowcoder.com/jump/super-jump/word?word=redis">redis</a>如何保证高可用的</h4><p>哨兵模式 和主从模式</p><h4 id="redis主从模式">redis主从模式</h4><p>一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点，同时每个从节点也可以是别的从节点的父节点，即主从节点连接形成树结构。</p><h4 id="redis主从模式如何复制的？">redis主从模式如何复制的？</h4><p><a href="http://kaito-kidd.com/2020/06/30/redis-replication/">http://kaito-kidd.com/2020/06/30/redis-replication/</a></p><p><strong>主从结构中数据的复制是单向的，只能由主节点到从节点</strong>，所有的内存变更，即数据的增删改都只能在主节点上进行，从节点通过同步的方式完成修改。默认情况下，从节点对非Master节点客户端是只读的。</p><p>主从复制分为全量复制和增量复制+命令传播</p><p>全量复制就是将主节点生成RDB文件发给从节点，从节点清除内存中的数据并删除之前RDB，然后将接受到的RDB放入内存。（第一次复制）</p><p>增量复制：master复制的时候可能会有新的数据产生，master会把数据放入缓冲区，等slave加载RDB完成后再将这些增量数据发送给slave。</p><p>命令传播就是每处理完一个命令都会把命令广播给所有的子节点，每个子结点收到广播后会继续广播给子节点，然后各个子结点会执行这个命令</p><p>如果主从断开连接，可能会发生全量复制，也可能只是增量复制。在slave第一次全量同步的时候记录了master的runid，然后slave知道自己的offset，这时候只需要把offset发送给master，master会先检查runid是否相同，然后检查offset中的命令是否再缓冲区中，因为缓冲区是有大小的，时间就的就会被删除，如果找得到offset之后的数据就可以只发送这些命令，否则就要进行全量复制。</p><h4 id="心跳机制">心跳机制</h4><h4 id="redis哨兵模式"><a href="https://www.nowcoder.com/jump/super-jump/word?word=redis">redis</a>哨兵模式</h4><p>单点模式就是一个单机</p><p>主从 1个主N个从  主机挂了之后 不能提供服务</p><p>哨兵模式  单哨兵和多哨兵 单哨兵是一个哨兵线程不断向redis服务器发送命令等待响应，没有响应表示挂掉，然后从其余的服务器选出一个主服务器；多哨兵是要所有的哨兵都认为该服务器挂掉，然后投票选举。</p><p>使用哨兵是，客户端直接连哨兵服务器</p><h4 id="【集群模式】">【集群模式】</h4><p>多个主从节点，实现了 Redis 的分布式存储，<strong>也就是说每台 Redis 节点上存储不同的内容</strong></p><h4 id="并发竞争的问题">并发竞争的问题</h4><h4 id="五个类型-的底层数据结构">五个类型 的底层数据结构</h4><h5 id="字符串">字符串</h5><p><a href="https://www.cnblogs.com/reecelin/p/13352694.html">https://www.cnblogs.com/reecelin/p/13352694.html</a></p><p>char数组+len长度+free长度</p><p>Simple Dynamic String  SDS来存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdsshr</span>&lt;</span>T&gt;&#123;</span><br><span class="line">    T len;<span class="comment">//数组长度</span></span><br><span class="line">    T alloc;<span class="comment">//数组容量</span></span><br><span class="line">    <span class="keyword">unsigned</span>  flags;<span class="comment">//sdshdr类型</span></span><br><span class="line">    <span class="keyword">char</span> buf[];<span class="comment">//数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>int</code>：当存储的字符串全是数字时，此时使用<code>int</code>方式来存储；</li><li><code>embstr</code>：当存储的字符串长度小于44个字符时，此时使用<code>embstr</code>方式来存储；</li><li><code>raw</code>：当存储的字符串长度大于44个字符时，此时使用<code>raw</code>方式来存储；</li></ul><h5 id="链表">链表</h5><p><a href="https://www.cnblogs.com/reecelin/p/13358432.html">https://www.cnblogs.com/reecelin/p/13358432.html</a></p><p>通过linkedList<code>、</code>zipList<code>和</code>quickList三种方式实现</p><p>分别是双向链表（与Java中的一样）、压缩列表、快表</p><h6 id="zipList">zipList</h6><p>通过Entry数组实现，每个Entry中存着前一个Entry的长度，编码，内容，节省了linkedList的前后指针。</p><h6 id="quickList">quickList</h6><p><code>qucikList</code>是由<code>zipList</code>和双向链表<code>linkedList</code>组成的混合体。</p><h5 id="哈希Map">哈希Map</h5><p><a href="https://www.cnblogs.com/reecelin/p/13362104.html">https://www.cnblogs.com/reecelin/p/13362104.html</a></p><h6 id="ziplist">ziplist</h6><h6 id="hash">hash</h6><p>数组+链表  dictEntry  **table    每一个dictentry有key，val</p><p>​rehash hashmap中有两个table  一次使用一个，rehash的时候将一个rehash到另一个上；如果数据量特别大会渐进式哈希，一次弄不完。</p><p>压缩列表：</p><h5 id="集合">集合</h5><p><a href="https://www.cnblogs.com/reecelin/p/13364089.html">https://www.cnblogs.com/reecelin/p/13364089.html</a></p><h6 id="intset">intset</h6><h6 id="hashmap">hashmap</h6><h5 id="有序集合">有序集合</h5><p><a href="https://www.cnblogs.com/reecelin/p/13368374.html">https://www.cnblogs.com/reecelin/p/13368374.html</a></p><h6 id="压缩列表zipList">压缩列表zipList</h6><h6 id="跳表">跳表</h6><p>跳表实现，解决了有序链表查询慢的问题，将查询时间降低到logN</p><p>将一些点提出来做索引，然后在从这些点中提出来做二级索引。</p><p>插入的时候采用随机的方式决定他最多要插到几层。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (random(<span class="number">0</span>,<span class="number">1</span>))  </span><br><span class="line">        K++;  </span><br></pre></td></tr></table></figure><h4 id="hash底层结构">hash底层结构</h4><p><a href="https://www.jianshu.com/p/7f53f5e683cf">https://www.jianshu.com/p/7f53f5e683cf</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表的table指向的数组存放这dictEntry类型的地址。定义在dict.h/dictEntryt中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span><span class="comment">//字典的节点</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">//使用的联合体</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;<span class="comment">//这两个参数很有用</span></span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个hash节点，用来解决hash键冲突（collision）</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dictType类型保存着 操作字典不同类型key和value的方法 的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;      <span class="comment">//计算hash值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);   <span class="comment">//复制key的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);   <span class="comment">//复制value的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);  <span class="comment">//比较key的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);   <span class="comment">//销毁key的析构函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);   <span class="comment">//销毁val的析构函数</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//redis中哈希表定义dict.h/dictht</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span> <span class="comment">//哈希表</span></span><br><span class="line">    dictEntry **table;      <span class="comment">//存放一个数组的地址，数组存放着哈希表节点dictEntry的地址。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;     <span class="comment">//哈希表table的大小，初始化大小为4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">//用于将哈希值映射到table的位置索引。它的值总是等于(size-1)。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;     <span class="comment">//记录哈希表已有的节点（键值对）数量。</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//字典结构定义在dict.h/dict</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;     <span class="comment">//指向dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据。</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;     <span class="comment">//私有数据，保存着dictType结构中函数的参数。</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];       <span class="comment">//两张哈希表。</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;     <span class="comment">//rehash的标记，rehashidx==-1，表示没在进行rehash</span></span><br><span class="line">    <span class="keyword">int</span> iterators;      <span class="comment">//正在迭代的迭代器数量</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/12474275-68e045cc8f730270?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp" alt=""></p><p>dict内部有两个dicthashtable  平常只有一个有内容，另一个的table为null，在扩容的时候，将一个重新映射到另一个上。</p><p>拉链法解决哈希冲突 ，数组中存储的是第二维链表的第一个指针</p><p>扩容时机是数组元素个数等于数组大小的时候就会扩容，但如果正在bgsave不会扩容，当entry个数为数组大小的五倍的时候就会强制扩容。而且它的扩容并不是一次完成的，可以渐进式的扩容rehash。</p><h4 id="Redis中的Rehash机制">Redis中的Rehash机制</h4><p><a href="https://blog.csdn.net/cqk0100/article/details/80400811">https://blog.csdn.net/cqk0100/article/details/80400811</a></p><p>你是如何查询</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="2021/05/12/mysql/"/>
      <url>2021/05/12/mysql/</url>
      
        <content type="html"><![CDATA[<p>阅读这个https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html</p><h4 id="事务">事务</h4><p>事务是数据库访问并可能操作数据项的一个操作序列，该序列的操作要么执行要么全部不执行。</p><h4 id="mysql中的事务特性">mysql中的事务特性</h4><p>[四大特性ACID]:</p><p>A 原子性**一次操作是不可分割的，要么全部成功，要么全部失败。比如我们的转账操作，不允许出款方成功，收款方失败这种情况，要么都成功，要么多失败，不可能出现中间状态。**<strong>InnoDB 引擎使用 undo log（归滚日志）来保证原子性操作</strong>，你对数据库的每一条数据的改动（INSERT、DELETE、UPDATE）都会被记录到 undo log 中，执行失败的时候就会回滚。</p><p>C一致性 使数据在执行前后处于合法的状态。（通过原子性、隔离性、持久性来实现一致性）</p><p>I 隔离性 <strong>多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<strong>隔离性可能会引入</strong>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）等问题</strong>，为了解决这些问题就引入了“隔离级别”的概念。</p><p>​InnoDB 引擎是如何保证隔离性的？<strong>利用锁和 MVCC 机制</strong>。这里简单的介绍一下 MVCC 机制，也叫<strong>多版本并发控制</strong>，在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务下，每条记录在更新的时候都会同时记录一条回滚操作，就会形成一个版本链，在执行普通的 SELECT 操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><p>D 持久性</p><p><strong>事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</strong></p><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。当数据库宕机重启的时候，会将 redo log 中的内容恢复到数据库中，再根据 undo log和 binlog 内容决定回滚数据还是提交数据。</p><p><strong><a href="https://yq.aliyun.com/articles/531757">https://yq.aliyun.com/articles/531757</a></strong></p><h4 id="隔离等级以及脏读幻读不可重复读">隔离等级以及脏读幻读不可重复读</h4><p>脏读：还没提交就读了，对应读未提交，未提交读</p><p>不可重复读：A事务在提交之前，两次读取得到的值不一样，可能是B事务对数据进行了修改（侧重编辑或删除）-对应读已提交</p><p>​隔离等级为读已提交的时候会出现不可重复读的问题</p><p>幻读：A事务在提交之前，两次读取得到的值不一样，可能是B事务对数据进行了修改（侧重于插入）-</p><p>​隔离等级为可重复读时会出现幻读问题</p><p>该sql第一次读取到数据后。就将这些数据加锁，其他事务无法改动这些数据。就能够实现可反复读了。但这样的方法却无法锁住insert的数据。所以当事务A先前读取了数据，或者改动了所有数据，事务B还是能够insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据。这就是幻读。不能通过行锁来避免。</p><p>须要Serializable隔离级别 。读用读锁，写用写锁，读锁和写锁相互排斥，这么做能够有效的避免幻读、不可反复读、脏读等问题，但会极大的减少数据库的并发能力。</p><h4 id="MVCC在MySQL的InnoDB中的实现">MVCC在MySQL的InnoDB中的实现</h4><p>在InnoDB中，会在每行数据后加入两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中。存储的并非时间，而是事务的版本，每开启一个新事务，事务的版本就会递增。 在可重读Repeatable reads事务隔离级别下：</p><ul><li>SELECT时。读取创建版本&lt;=当前事务版本。删除版本为空或&gt;当前事务版本。</li><li>INSERT时，保存当前事务版本为行的创建版本</li><li>DELETE时，保存当前事务版本为行的删除版本</li><li>UPDATE时，插入一条新纪录。保存当前事务版本为行创建版本，同一时候保存当前事务版本到原来删除的行</li><li>通过MVCC，尽管每行记录都须要额外的存储空间，很多其它的行检查工作以及一些额外的维护工作。但能够降低锁的使用，大多数读操作都不用加锁，读数据操作非常easy，性能非常好，而且也能保证仅仅会读取到符合标准的行。也仅仅锁住必要行。</li></ul><h4 id="MVCChttps-blog-csdn-net-weixin-34341117-article-details-91425439">MVCChttps://blog.csdn.net/weixin_34341117/article/details/91425439</h4><h4 id="乐观锁悲观锁的实现">乐观锁悲观锁的实现</h4><p><a href="https://www.cnblogs.com/kyoner/p/11318979.html">https://www.cnblogs.com/kyoner/p/11318979.html</a></p><ol><li><p>乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁。</p><p>可重复读的时候，如果Ainsert 但B提前Insert并且提交，则A会报错。</p></li><li><p>悲观锁是读取的时候为后面的更新加锁，之后再来的读操作都会等待。这种是数据库锁乐观锁优点程序实现，不会存在死锁等问题。他的适用场景也相对乐观。阻止不了除了程序之外的数据库操作。悲观锁是数据库实现，他阻止一切数据库操作。</p><p>序列化的实现方式</p></li></ol><h4 id="间隙锁https-blog-csdn-net-qq-42214953-article-details-106148054">间隙锁https://blog.csdn.net/qq_42214953/article/details/106148054</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)” ，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key 锁）。举例来说， 假如 user 表中只有 101 条记录， 其 userid 的值分别是 1,2,…,100,101， 下面的 SQL：</p><p>Select * from user where userid &gt; 100 for update;</p><p>是一个范围条件的检索，InnoDB 不仅会对符合条件的 userid 值为 101 的记录加锁，也会对userid 大于 101（但是这些记录并不存在）的“间隙”加锁，防止其它事务在表的末尾增加数据。</p><p>InnoDB 使用间隙锁的目的，为了防止幻读，以满足串行化隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 userid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读。</p><p>但是只能解决部分幻读问题</p><h4 id="共享锁、排他锁">共享锁、排他锁</h4><p>共享锁 select in share mode  是一个行级读锁   并发读，写要加锁</p><p>排他锁 select for  update   行级写锁  加完锁之后其余事务不能加锁</p><h4 id="缓存穿透-空结果缓存-布隆过滤器">缓存穿透  空结果缓存  布隆过滤器</h4><p><a href="https://www.cnblogs.com/lazyegg/p/12857374.html">https://www.cnblogs.com/lazyegg/p/12857374.html</a></p><p>BloomFilter 是由一个固定大小的二进制向量或者位图（bitmap）和一系列映射函数组成的。</p><p>在初始状态时，对于长度为 m 的位数组，它的所有位都被置为0，如下图所示：</p><h4 id="缓存击穿">缓存击穿</h4><p>0.热点数据设置为永远不过期</p><p>1.后台刷新  后台定义一个job(定时任务)专门主动更新缓存数据.</p><p>2.分级缓存</p><p>采用 L1 (一级缓存)和 L2(二级缓存) 缓存方式，L1 缓存失效时间短，L2 缓存失效时间长。 请求优先从 L1 缓存获取数据，如果 L1缓存未命中则加锁，只有 1 个线程获取到锁,这个线程再从数据库中读取数据并将数据再更新到到 L1 缓存和 L2 缓存中，而其他线程依旧从 L2 缓存获取数据并返回。</p><p>3.多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p><h4 id="缓存雪崩-大量缓存相同的过期时间">缓存雪崩 大量缓存相同的过期时间</h4><p>4.2.1 事前：</p><ul><li><h4 id="使用集群缓存，保证缓存服务的高可用"><strong>使用集群缓存，保证缓存服务的高可用</strong></h4></li></ul><p>这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。</p><p>4.2.2 事中：</p><ul><li><h4 id="ehcache本地缓存-Hystrix限流-降级-避免MySQL被打死"><strong>ehcache本地缓存 + Hystrix限流&amp;降级,避免MySQL被打死</strong></h4></li></ul><p>使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。</p><p>使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。</p><p>然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。</p><p>4.2.3 事后：</p><p>开启Redis持久化机制，尽快恢复缓存集群</p><p>一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p><h4 id="什么时候建立索引？">什么时候建立索引？</h4><p>主键 外键需要建立索引</p><p>经常join的需要建立索引</p><p>数据量比较大的表应该创建索引；</p><p>经常在where中的列</p><h4 id="聚簇索引和非聚簇的区别">聚簇索引和非聚簇的区别</h4><p>**聚簇索引：**将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</p><p>**非聚簇索引：**将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置</p><p><strong>在innodb中</strong>，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。<strong>辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找</strong>。</p><h4 id="为什么B-不用B">为什么B+不用B</h4><p>一般来说索引非常大，所以为了减少内存的占用，索引也会被存储在磁盘上。</p><p>那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。　　另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。(数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）)</p><p></p><h4 id="MySQL的自增ID用完了，会出现什么问题？">MySQL的自增ID用完了，会出现什么问题？</h4><p>不会在增加，报错</p><h4 id="mysql主从复制原理">mysql主从复制原理</h4><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p><p>1–在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压）2–在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全）3–当主服务器出现问题时，可以切换到从服务器。（提升性能）</p><p>1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：2.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。</p><p>3.从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。</p><h4 id="binlog日志的格式？row格式的优点">binlog日志的格式？row格式的优点</h4><p>undo log的主要作用是用作事务的回滚和实现mvcc功能，因为mvcc的问题，需要对undolog随机读</p><p><strong>redolog用来保证事务的原子性和持久性</strong>数据库运行阶段不需要读redolog进行读取。 所有线程公用一份redolog buffer。 在事务执行期间，redolog是记录在redolog buffer中的</p><p><strong>binlog 其实是数据库server层的日志</strong>，一般用作主从同步和数据恢复，数据格式有statement、row、还有mixed.statement是sql格式的，row记录了行的变更（从什么到什么），mixed是这两种的混合形式.binlog是在两阶段提交 preparre 和 commit之间，也是要先write到page cache（文件系统缓冲区），然后调用fsync进行刷盘</p><h4 id="索引分类">索引分类</h4><p><strong>BTree索引，哈希索引，全文索引</strong></p><p>索引的本质：索引是数据结构。</p><h4 id="mysql索引的底层实现https-www-cnblogs-com-boothsun-p-8970952-html-autoid-6-1-0">mysql索引的底层实现<s><a href="https://www.cnblogs.com/boothsun/p/8970952.html#autoid-6-1-0">https://www.cnblogs.com/boothsun/p/8970952.html#autoid-6-1-0</a></s></h4><p>这个比较好http://blog.codinglabs.org/articles/theory-of-mysql-index.html</p><p>基本上都有</p><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h4 id="聚簇索引的优缺点">聚簇索引的优缺点</h4><p><strong>聚簇索引的优点</strong>1、聚簇索引将索引和数据行保存在同一个B-Tree中，查询如果是通过聚簇索引查询的，可以直接获取数据，而非聚簇索引查到的是数据所在的指针，还需要进行一次I/O获取数据，因此聚簇索引通常比非聚簇索引查找更快。2、对主键进行范围查询的效率很高，因为其数据是按照主键排列的3、减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新二级索引的行指针</p><p><strong>聚簇索引的缺点</strong>1、聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据都存放在内存中，则访问顺序就不那么重要了，非聚簇索引也能很快在内存中查到数据，那聚簇索引也没什么优势。2、插入速度严重依赖于插入顺序。按照主键顺序往InnoDB中进行数据导入是最快的。如果不是按照主键插入，最好在导入完成后使用OPTIMIZE TABLE命令重新组织一下表。事实上，如果不是按照顺序插入，可能会引起大量的页面分裂和数据移动3、聚簇索引在插入新行和更新主键时，可能导致“页分裂”问题：当插入到某个已满的叶子结点时，B+树会分裂成两个页来容纳新插入的行数据。页分裂会导致表占用更多的磁盘空间（不要用UUID或随机数做主键，而应该使用单调递增的值做主键）。4、聚簇索引可能导致全表扫描速度变慢，因为可能需要加载物理上相隔较远的页到内存中（需要耗时的磁盘寻道操作）。5、二级索引访问数据行需要两次索引查找，解决办法是实现索引覆盖，直接在二级索引就能获取要所有需要的字段了，这样就不用再去主键索引搜索。6、由于二级索引保存了主键列，二级索引会占更大的空间(所以选用一个短主键是有利的)。</p><h4 id="mysql联合索引的结构-联合索引失效的场景">mysql联合索引的结构 联合索引失效的场景</h4><p><a href="https://www.zhihu.com/question/304037770/answer/541460420">https://www.zhihu.com/question/304037770/answer/541460420</a></p><p>比如有一个表的索引是（年龄、姓名）的联合索引。</p><p>它也是一颗B+树，和其他非聚簇索引不同的是，它是按多个列从左往右进行排序的，叶子节点还是存储主键的值。所以如果没有使用最左边的那一列来筛选索引就会失效。最左匹配原则</p><h4 id="什么是覆盖索引？">什么是覆盖索引？</h4><p>如果一个索引包含了所有需要select的信息，那么就不用回表了。</p><p><strong>MySQL的引擎有哪几种，它们有什么区别</strong>（常规题）</p><p>innoDB  支持事务、外键    聚集索引  支持表、行级锁</p><p>MyISAM非聚集索引    可以压缩数据  仅支持表级锁</p><h4 id="当前读-current-read">当前读(current read)</h4><p>select … lock in share mode</p><p>select … for update</p><p>insert</p><p>update</p><p>delete</p><h4 id="快照读">快照读</h4><p>RR级别下的select</p><h4 id="如何快速插入百万级数据">如何快速插入百万级数据</h4><p>java可以使用  预编译PreparedStatement  批次执行</p><h4 id="建立了哪些索引，联合索引哪个放在了前面">建立了哪些索引，联合索引哪个放在了前面</h4><h4 id="哪些情况下数据库索引会失效？"><strong>哪些情况下数据库索引会失效？</strong></h4><p><a href="https://www.cnblogs.com/itsharehome/p/4972948.html">https://www.cnblogs.com/itsharehome/p/4972948.html</a></p><p>最左匹配复合索引的时候</p><p>使用Like 且%在 最前面的时候</p><p>查询条件中含有函数或者表达式</p><p>条件带or</p><p>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</p><p>如果它认为全表扫描比走索引快</p><h4 id="BinLog">BinLog</h4><p>是服务层的Server Layer</p><h4 id="Redo-Log-持久化">Redo Log  持久化</h4><p>是引擎层的</p><p>重做日志是在崩溃恢复期间使用的基于磁盘的数据结构，以纠正由不完整事务编写的数据。</p><p>因为mysql一开始只是对内存中的数据进行操作，然后将命令写入RedoLog</p><h4 id="Undo-Log-回滚">Undo Log  回滚</h4><p>撤消日志是与单个读写事务关联的撤消日志记录的集合。 undo log记录包含有关如何撤消事务到群集索引记录的最新更改的信息。如果另一个事务需要将原始数据视为一致读取操作的一部分，则从撤消日志记录中检索未修改的数据。 undo日志存在于undo日志段中，这些段包含在回滚段内。回滚段驻留在系统表空间中，在撤消表空间中以及临时表空间中。</p><h4 id="什么是DCL？">什么是DCL？</h4><p>数据库控制语言 grant user</p><p>REVOKE user</p><p>commit</p><h4 id="DDL？">DDL？</h4><p>craete table/view/index/</p><h4 id="DML？">DML？</h4><p>insert/update/delete</p><h4 id="DQL？">DQL？</h4><p>select</p><h4 id="分库分表">分库分表</h4><p>在项目中我将包裹表分表，因为包裹表列数太多，而有刚好可以通过寄件人信息、收件人信息、包裹信息来拆分为三个表，然后通过主键关联；联合查询性能不好</p><p>id 、select_type、table、type、possible keys、key、keylen、ref、rows、extra</p><h4 id="SQL在是如何在mysql运行的？">SQL在是如何在mysql运行的？</h4><p><img src="C:%5CUsers%5C%E8%8A%B1%E6%A4%92%E8%8C%B4%E9%A6%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210421141757250.png" alt="image-20210421141757250"></p><p>分析器</p><p>优化器</p><p>执行器（引擎提供）</p><h4 id="一条SQL语句执行得很慢的原因有哪些">一条SQL语句执行得很慢的原因有哪些</h4><p><a href="https://zhuanlan.zhihu.com/p/62941196">https://zhuanlan.zhihu.com/p/62941196</a></p><h4 id="MYSQL的调优">MYSQL的调优</h4><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><p>sql语句的优化，like  or in 慎用  避免*</p><p>对where中经常判断的建立索引，并分析可能失效的时候</p><h4 id="Explain命令">Explain命令</h4><p>Id：代表执行select子句或操作表的顺序Select_type：查询的类型,主要用于区别普通查询,联合查询,子查询等复杂查询</p><p>simple:简单的select查询,查询中不包含子查询或union查询primary:查询中若包含任何复杂的子部分,最外层查询则被标记为primarySubquery： 在select 或where 列表中包含了子查询Derived： 在from列表中包含的子查询被标记为derived,mysql会递归这些子查询,把结 果在临时表里Union： 做第二个select出现在union之后,则被标记为union,若union包含在from子句的子查询中,外层select将被标记为derivedunion result： 从union表获取结果的selectTable：显示一行的数据时关于哪张表的</p><p>Type：查询类型从最好到最差依次是:system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;All,一般情况下,得至少保证达到range级别,最好能达到ref</p><p>system:表只有一行记录,这是const类型的特例,平时不会出现const:表示通过索引一次就找到了,const即常量,它用于比较primary key或unique 索引,因为只匹配一行数据,所以效率很快,如将主键置于where条件中,mysql就能将该 查询转换为一个常量eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配,常见于主键或唯 一索引扫描ref:非唯一性索引扫描,返回匹配某个单独值的行,它可能会找到多个符合条件的行,所以 他应该属于查找和扫描的混合体range:只检索给定范围的行,使用一个索引来选择行,如where语句中出现了 between,&lt;,&gt;,in等查询,这种范围扫描索引比全表扫描要好，因为它只需要开始于索引 的某一点，而结束于另一点，不用扫描全部索引。index:只遍历索引树,这通常比All快,因为索引文件通常比数据文件小,index是从索引 中读取,all从硬盘中读取all:全表扫描,是最差的一种查询类型Possible_keys：显示可能应用在这张表中的索引,一个或多个,查询到的索引不一定是真正被用到的</p><p>Key：实际使用的索引,如果为null,则没有使用索引,因此会出现possible_keys列有可能被用到的索引,但是key列为null,表示实际没用索引。</p><p>Key_len：表示索引中使用的字节数,而通过该列计算查询中使用的 索引长度,在不损失精确性的情况下,长度越短越好,key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即,key_len是根据表定义计算而得么不是通过表内检索出的</p><p>Ref：显示索引的哪一列被使用了,如果可能的话是一个常数,哪些列或常量被用于查找索引列上的值</p><p>Rows：根据表统计信息及索引选用情况,大只估算出找到所需的记录所需要读取的行数</p><p>Extra：包含不适合在其他列中显式但十分重要的额外信息</p><h4 id="SQL慢查询">SQL慢查询</h4><p>主要的原因：全表扫描、全索引扫描、索引过滤性不好。</p><p>超过 long_query_time 参数设定的时间阈值（默认10s），就被认为是慢查询。</p><p>通过set global slow_query_log=1开启慢查询日志。</p><p>通过set log_queries_not_using_indexes=1设置是否记录未使用索引的sql。</p><p>即使使用到了索引也有可能会导致慢查询，比如有id为主键的一个表，id全部&gt;0，但是你如果使用where id &gt;0那就其实还是走了全表扫描，主键只使用在了第一个地方。</p><h4 id="数据库设计三大范式">数据库设计三大范式</h4><ul><li>第一范式(确保每列保持原子性) 地址拆分为省市区</li><li>第二范式(确保表中的每列都和主键相关)</li><li>第三范式(确保每列都和主键列直接相关,而不是间接相关) 去除冗余  a-&gt;b -&gt; c  拆为ab和bc</li></ul><h4 id="SQL写横标纵表的转换？">SQL写横标纵表的转换？</h4><p><strong>纵表变横表</strong></p><p>聚合函数[max或sum]配合case语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 姓名,</span><br><span class="line"><span class="built_in">sum</span> (<span class="keyword">case</span> 课程 <span class="keyword">when</span> <span class="string">&#x27;语文&#x27;</span> <span class="keyword">then</span> 成绩 <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> 语文,</span><br><span class="line"><span class="built_in">sum</span> (<span class="keyword">case</span> 课程 <span class="keyword">when</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">then</span> 成绩 <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> 数学,</span><br><span class="line"><span class="built_in">sum</span> (<span class="keyword">case</span> 课程 <span class="keyword">when</span> <span class="string">&#x27;英语&#x27;</span> <span class="keyword">then</span> 成绩 <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> 英语</span><br><span class="line"><span class="keyword">from</span> Table_A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 姓名</span><br></pre></td></tr></table></figure><p><strong>横表变纵表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 姓名,<span class="string">&#x27;语文&#x27;</span> <span class="keyword">as</span> 课程,语文 <span class="keyword">as</span> 成绩 <span class="keyword">from</span> Table_B <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> 姓名,<span class="string">&#x27;数学&#x27;</span> <span class="keyword">as</span> 课程,数学 <span class="keyword">as</span> 成绩 <span class="keyword">from</span> Table_B <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> 姓名,<span class="string">&#x27;英语&#x27;</span> <span class="keyword">as</span> 课程,英语 <span class="keyword">as</span> 成绩 <span class="keyword">from</span> Table_B</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 姓名,课程 <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h4 id="查看建表语句">查看建表语句</h4><p>SHOW CREATE TABLE package</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 面试 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="2021/05/12/JVM/"/>
      <url>2021/05/12/JVM/</url>
      
        <content type="html"><![CDATA[<h3 id="1-JVM内存区域"><a href="#1-JVM内存区域" class="headerlink" title="1.JVM内存区域"></a>1.JVM内存区域</h3><h4 id="OOM了解吗？什么情况下会出现OOM？"><a href="#OOM了解吗？什么情况下会出现OOM？" class="headerlink" title="OOM了解吗？什么情况下会出现OOM？"></a>OOM了解吗？什么情况下会出现OOM？</h4><p>​    对栈来说，如果没有空间来为新的栈帧开辟空间就会产生OOM</p><p>​    对永久代如果空间不够会抛出OOM</p><p>​    对堆：如果空间不够也GC没用的情况下也会抛出OOM</p><p>​    一般可能是内存泄漏或者是内存溢出照成的。</p><h4 id="StackOverflow出现的场景？"><a href="#StackOverflow出现的场景？" class="headerlink" title="StackOverflow出现的场景？"></a>StackOverflow出现的场景？</h4><p>​    对栈来说，如果线程请求的栈深度大于虚拟机所能接受的栈深度会抛出SOF</p><h4 id="1-JVM内存区域分为五大部分："><a href="#1-JVM内存区域分为五大部分：" class="headerlink" title="1.JVM内存区域分为五大部分："></a>1.JVM内存区域分为五大部分：</h4><h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>   java线程的栈帧，线程的每一个方法会生成一个栈帧，用于存放该线程的局部变量表、操作数栈、动态连接、方法出口等信息。随着方法的调用与结束，对应着入栈与出栈；局部变量表中存放着方法参数和内部定义的局部变量，基本存储单位是方法槽。<br>    动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用是为了支持方法调用过程中的动态连接(DynamicLinking) 这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析  另外一部分符号引用将在每一次运行期间都转化为直接引用，这部分就称为动态连接<br>    操作数栈：java虚拟机栈中的一个用于计算的临时数据存储区</p><h5 id="本地方法栈-Native方法的栈帧-和虚拟机栈差不多，只不过是调用ni方法的栈帧"><a href="#本地方法栈-Native方法的栈帧-和虚拟机栈差不多，只不过是调用ni方法的栈帧" class="headerlink" title="本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧"></a>本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧</h5><h5 id="堆-几乎所有的对象都在这里分配内存"><a href="#堆-几乎所有的对象都在这里分配内存" class="headerlink" title="堆  几乎所有的对象都在这里分配内存"></a>堆  几乎所有的对象都在这里分配内存</h5><p>​    堆分为老年代、新生代、永久代；</p><p>​    新生代分为Eden FromSurvivors To Survivors  8：1：1</p><p>​    这两个Survivors有什么用呢？</p><p>​    在分配内存时，每次只使用一块Eden和 Survivor然后使用标记复制算法将其复制到另一块Survivor上。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）。</p><h5 id="方法区-："><a href="#方法区-：" class="headerlink" title="方法区 ："></a>方法区 ：</h5><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><h5 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h5><p>当前线程字节码文件的行号指示器，通过改变该计数器的值来获得下一步执行的字节码指令；程序控制流的指示器，程序当中的分支、循环、线程恢复、跳转、异常处理都要由它指示。由于Java虚拟机通过时间片轮转实现多线程，所以每一个线程都需要一个程序计数器记录当前执行的位置。</p><h4 id="3-对象访问定位的方式："><a href="#3-对象访问定位的方式：" class="headerlink" title="3.对象访问定位的方式："></a>3.对象访问定位的方式：</h4><p>​    句柄池：每一个句柄   数据结构中包括对象数据的指针以及类的指针</p><p>​    直接指针 在对象数据中存放类指针</p><h4 id="5堆内存中对象分配的基本策略：2种"><a href="#5堆内存中对象分配的基本策略：2种" class="headerlink" title="5堆内存中对象分配的基本策略：2种"></a>5堆内存中对象分配的基本策略：2种</h4><p>​    碰撞指针、空闲表</p><h5 id="并发问题如何解决"><a href="#并发问题如何解决" class="headerlink" title="并发问题如何解决"></a>并发问题如何解决</h5><p>   CAS乐观锁+失败重试   先创建失败了就重试  </p><p>   TLAB  为每个线程在Eden初设一点内存，现在TLAB分配 当TLAB用完后，用CAS+失败重试</p><h3 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2.垃圾回收"></a>2.垃圾回收</h3><p>一个长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，就会造成内存泄漏。</p><p>ThreadLocalMap中存在内存泄漏。</p><h4 id="如何判断对象是否死亡："><a href="#如何判断对象是否死亡：" class="headerlink" title="如何判断对象是否死亡："></a>如何判断对象是否死亡：</h4><p>​    如果没有任何一个对象引用该对象则判断为死亡（可达性方法）</p><p>​     （引用计数法）没引用一次加一取消引用减一；不好解决互相引用的问题；</p><h5 id="GCRoots有哪些？"><a href="#GCRoots有哪些？" class="headerlink" title="GCRoots有哪些？"></a>GCRoots有哪些？</h5><p>​        虚拟机栈中引用的对象，本地方法栈中引用的对象</p><p>​        方法区中常量引用的对象，方法区中类静态属性引用的对象</p><h4 id="7-如何判断常量是否无用，类是否无用？"><a href="#7-如何判断常量是否无用，类是否无用？" class="headerlink" title="7.如何判断常量是否无用，类是否无用？"></a>7.如何判断常量是否无用，类是否无用？</h4><p>​    常量无用：没有引用即可</p><p>​    类无用：该Class类没有被引用、没有该类的对象还在存活、该类的ClassLoader已经销毁</p><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>如今的垃圾回收器大都是遵循分代收集。建立在两个分代假说：弱分代假说，强分代假说。垃圾回收器应该将Java堆分为不同的存储区域，根据其年龄进行收集。</p><p>跨代引用假说，跨代引用相对于同代引用仅占用极少数。</p><h4 id="如何解决跨代引用的问题？"><a href="#如何解决跨代引用的问题？" class="headerlink" title="如何解决跨代引用的问题？"></a>如何解决跨代引用的问题？</h4><p>在新生代维护一个记忆集，将老年代分为若干块，标识出哪一块会存在跨代引用，在mingc的时候将它加入到GCroot中。</p><h4 id="MinorGC-MajorGC-FullGC-新生代、老年代、整堆收集"><a href="#MinorGC-MajorGC-FullGC-新生代、老年代、整堆收集" class="headerlink" title="MinorGC MajorGC FullGC  新生代、老年代、整堆收集"></a>MinorGC MajorGC FullGC  新生代、老年代、整堆收集</h4><p>正是因为垃圾回收器每次只回收某一个或者某些部分的区域，才有了这三个回收类型的划分。然后根据不同的区域采取不同的回收算法</p><h4 id="什么时候会FullGC？"><a href="#什么时候会FullGC？" class="headerlink" title="什么时候会FullGC？"></a>什么时候会FullGC？</h4><ol><li>System.gc()方法的调用</li><li>老年代空间不足（新生代转入、创建大对象）</li><li>CMS无法处理浮动垃圾、有可能出现并发清理失败进而导致另一次完全“Stop The World”的Full GC的产生</li></ol><h4 id="垃圾回收算法？各有什么优缺点"><a href="#垃圾回收算法？各有什么优缺点" class="headerlink" title="垃圾回收算法？各有什么优缺点"></a>垃圾回收<a href="">算法</a>？各有什么优缺点</h4><p>​    引用计数算法和追踪式算法（引用式算法实现比较简单但是不好解决循环引用的问题）</p><p>追踪式算法基于分代假说理论，分别在各自的内存区域回收各自的无用对象，关于如何解决跨代引用，需在新生代上建立一个全局的数据结构（该结构被称 为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会 存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p><p>​    标志清除  产生内存碎片 /执行效率不稳定：可能需要回收的对象占大部分</p><p>​    标记复制    解决了内存碎片 可用空间减为一半，改进后在新生代使用。</p><p>​    标记整理    慢，适合老年代</p><h4 id="什么是STW？"><a href="#什么是STW？" class="headerlink" title="什么是STW？"></a>什么是STW？</h4><p>必须全部暂停用户线程</p><h4 id="什么是安全点？"><a href="#什么是安全点？" class="headerlink" title="什么是安全点？"></a>什么是安全点？</h4><p>可达性分析算法中通过根节点枚举来查找引用链，然后通过OopMap来得到对象的引用地址，因为Oopmap变化是实时的不能为每一条指令都生成oopmap，只在安全点生成oopmap，然后让所有的线程跑到最近的安全点 停下来即可完成STW并且进行根节点枚举。</p><h4 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h4><p>—有其他分代区域中对象引用了本区域对象时，其对应的 卡表元素就应该变脏，</p><p>通过写屏障（Write Barrier）技术维护卡表状态的</p><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>三个年轻代  Serial ParNew  Parrllel Scavenge</p><p>三个老年代  CMS   SerialOld  Parallel Old</p><p>然后是G1  SGC ZGC</p><h5 id="Serial-Serial-Old"><a href="#Serial-Serial-Old" class="headerlink" title="Serial/Serial Old"></a>Serial/Serial Old</h5><p>这两个的运行过程一样的</p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416155252023.png" alt="image-20210416155252023"></p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416155303079.png" alt="image-20210416155303079"></p><p>在单核处理器下很好，他说所有收集器占用额外内存最小的。</p><h5 id="然后是ParNew，Serial的多线程版本"><a href="#然后是ParNew，Serial的多线程版本" class="headerlink" title="然后是ParNew，Serial的多线程版本"></a>然后是ParNew，Serial的多线程版本</h5><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416155627557.png" alt="image-20210416155627557"></p><h5 id="然后是Parrllel-Scavenge-和ParNew擦不多"><a href="#然后是Parrllel-Scavenge-和ParNew擦不多" class="headerlink" title="然后是Parrllel Scavenge  和ParNew擦不多"></a>然后是Parrllel Scavenge  和ParNew擦不多</h5><p>重点关注吞吐量</p><h5 id="然后是ParallelOld"><a href="#然后是ParallelOld" class="headerlink" title="然后是ParallelOld"></a>然后是ParallelOld</h5><p>PS的老年代版本 ，标记整理算法/</p><h5 id="老年代的CMS-2次stop-the-world-详细看一下"><a href="#老年代的CMS-2次stop-the-world-详细看一下" class="headerlink" title="老年代的CMS  2次stop the world  详细看一下"></a>老年代的CMS  2次stop the world  详细看一下</h5><p>一种以获取最短回收停顿时间为目标的收集器，并发收集、低停顿。到这里就不一样了，运行过程变成了四个。</p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210329154236724.png" alt="image-20210329154236724"></p><p>四个阶段</p><p>初始标记（STW）、并发标记、重新标记(STW)、并发清除</p><p>单线程                  、单线程与用户并发、多线程、单线程并发</p><p>缺点：1.在核数小于四个的情况下咱用核心数多，吞吐量降低</p><p>2.无法处理浮动垃圾、有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。是CMS运行期间预留的内存无法满 足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不 得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，</p><p>3.标记清除会产生碎片，在无法为新对象分配时会FullGC或者进行整理。但是是单线程的</p><h5 id="G1-3次-stop-the-world"><a href="#G1-3次-stop-the-world" class="headerlink" title="G1 3次 stop the world"></a>G1 3次 stop the world</h5><p>开创了收集 器面向局部收集的设计思路和基于Region的内存布局形式。 </p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210329180346655.png" alt="image-20210329180346655"></p><p>且其内存区域是按Region来划分，每一个Region都可以作为Eden From To 或者是老年代，它可以面向堆内存任 何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理。</p><p>可以建立起停顿时间模型的收集器，每次收集停顿时间都少于某个时间。</p><p>四个阶段（三次STW）</p><p>初始标记（STW）、并发标记、最终标记(STW)、筛选回收（STW）</p><p>单线程                  、单线程与用户并发、多线程、 多线程</p><p>Region引用对象如何解决？解决的思 路我们已经知道（见3.3.1节和3.4.4节）：使用记忆集避免全堆作为GC Roots扫描，</p><p>·初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。</p><p> ·并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。 </p><p>·最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。</p><p> ·筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。</p><h5 id="两个低延迟的垃圾回收器"><a href="#两个低延迟的垃圾回收器" class="headerlink" title="两个低延迟的垃圾回收器"></a>两个低延迟的垃圾回收器</h5><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416161248975.png" alt="image-20210416161248975"></p><p>​    ZGC  染色指针 Region大小可变</p><p>​    shenandoahGC  对G1的增强</p><h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><p>对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起 一次Minor GC。</p><p>大对象直接进入老年代</p><p>长期存活的对象将进入老年代，每经过一次minorGC年龄增加一岁，增加到一定程度就会晋升至老年代</p><p>动态对象年龄判定：当Survivor空间中相同年龄所有对象占用的空间大于Survivor空间的一半，大于等于该年龄的对象就会直接进入老年代。</p><p>空间分配担保：每次MinorGC之前都要检查老年代的连续可用空间是否能够容纳当前新生代所有对象的大小，如果不能容纳就需要FullGC，如果设定了允许担保失败可以不进行FullGC</p><h4 id="会不会发生内存泄漏？"><a href="#会不会发生内存泄漏？" class="headerlink" title="会不会发生内存泄漏？"></a>会不会发生内存泄漏？</h4><p><a href="https://www.cnblogs.com/gaopeng527/p/5258413.html">https://www.cnblogs.com/gaopeng527/p/5258413.html</a></p><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</p><p>静态集合，容器中的对象在程序结束前不能释放（但是还是可能有用，如果没用了就是泄漏）</p><p>HashMap中对象的hash值被改变</p><p>各种连接，比如数据库的连接，如果没有close会泄漏</p><p>内部类持有外部类，外部类无法GC</p><p>ThreadLocalMap中会发生内存泄漏</p><h3 id="3-类加载"><a href="#3-类加载" class="headerlink" title="3.类加载"></a>3.类加载</h3><h4 id="何时加载类"><a href="#何时加载类" class="headerlink" title="何时加载类"></a>何时加载类</h4><ol><li><p>使用new ，获取类的static，</p></li><li><p>子类加载的时候发现父类还没有加载</p></li><li><p>JVM启动的时候main类</p></li><li><p>使用反射</p></li><li><p>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p></li><li><p>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ol><h4 id="类加载过程-Java对象的创建过程：（每一步详细实现）"><a href="#类加载过程-Java对象的创建过程：（每一步详细实现）" class="headerlink" title=".类加载过程/Java对象的创建过程：（每一步详细实现）"></a>.类加载过程/Java对象的创建过程：（每一步详细实现）</h4><p><a href="https://www.cnblogs.com/xiaoxian1369/p/5498817.html#:~:text=%E5%85%B6%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%8C%85,%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5%E3%80%82">https://www.cnblogs.com/xiaoxian1369/p/5498817.html#:~:text=%E5%85%B6%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%8C%85,%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5%E3%80%82</a></p><p>加载（加载进内存、转换成Class实例对象）、</p><p>连接（验证、准备：分配空间设置0值、解析）</p><p>验证：是确保Class文件的字节流中包含的信息符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>准备：准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初 始值的阶段。</p><p>解析：：符号引用-&gt;直接引用</p><p>​    直接引用就是直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。</p><p>初始化：（执行静态变量复制、静态代码块）</p><p>​    执行类构造器·clinit()方法</p><h4 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h4><p>​    检查类是否加载</p><p>​    分配内存，在堆中分配内存</p><p>​    初始化   为变量赋默认值</p><p>​    设置对象头  </p><p>​    执行<init>()      <init>()是指收集类中的所有实例变量的赋值动作、实例代码块和构造函数</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><h5 id="启动类加载器-由C-实现"><a href="#启动类加载器-由C-实现" class="headerlink" title="启动类加载器  由C++实现"></a>启动类加载器  由C++实现</h5><p>是虚拟机自身的一部分</p><p>加载<JAVA_HOME>/lib下的</p><h5 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h5><p>加载<JAVA_HOME>/lib/ext/下的</p><h5 id="应用程序加载器"><a href="#应用程序加载器" class="headerlink" title="应用程序加载器"></a>应用程序加载器</h5><h5 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h5><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>当一个类加载器接收到一个类加载的任务时，不会立即展开加载，而是将加载任务委托给它的父类加载器去执行，每一层的类都采用相同的方式，直至委托给最顶层的启动类加载器为止。如果父类加载器无法加载委托给它的类，便将类的加载任务退回给下一级类加载器去执行加载。</p><p>双亲委托模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载。</p><h4 id="为什么要使用双亲委托模型？"><a href="#为什么要使用双亲委托模型？" class="headerlink" title="为什么要使用双亲委托模型？"></a>为什么要使用双亲委托模型？</h4><p>使用双亲委托机制的好处是：能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。使用双亲委托模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委托给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种加载器环境中都是同一个类。相反，如果没有使用双亲委托模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果自己去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行。</p><p>双亲委托模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委托的代码都集中在java.lang.ClassLoader的loadClass()方法中，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass方法进行加载。</p><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>自定义一个类加载器，不让他委托给父类</p><h4 id="JDK9的模块"><a href="#JDK9的模块" class="headerlink" title="JDK9的模块"></a>JDK9的模块</h4><h3 id="4-Java-内存模型-JMM"><a href="#4-Java-内存模型-JMM" class="headerlink" title="4.Java 内存模型 JMM"></a>4.Java 内存模型 JMM</h3><h4 id="工作内存与主内存"><a href="#工作内存与主内存" class="headerlink" title="工作内存与主内存"></a>工作内存与主内存</h4><p>所有变量都存在主内存，每个线程都还有自己的工作内存，工作内存通过load和store将变量取出或放入。</p><h4 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h4><p>大多数现代计算机为了提高性能而采取乱序执行，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。</p><p>java的内存屏障通常所谓的四种即<code>LoadLoad</code>,<code>StoreStore</code>,<code>LoadStore</code>,<code>StoreLoad</code>实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p><p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p><p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p><p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p><p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</p><p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p><h4 id="DCL为何需要加volatile"><a href="#DCL为何需要加volatile" class="headerlink" title="DCL为何需要加volatile"></a>DCL为何需要加volatile</h4><p>使用了它的禁止重排序，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便 是赋值操作）多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个内存屏障 （Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置</p><h4 id="volatile如何实现的内存可见性？"><a href="#volatile如何实现的内存可见性？" class="headerlink" title="volatile如何实现的内存可见性？"></a>volatile如何实现的内存可见性？</h4><p>addl$0x0，(%esp)”的空操作可以将本地处理器的缓存写入内存，该写入动作也会引起处理器或者别的内核缓存无效化，实现了可见性。</p><h4 id="volatile如何实现的禁止重排序？"><a href="#volatile如何实现的禁止重排序？" class="headerlink" title="volatile如何实现的禁止重排序？"></a>volatile如何实现的禁止重排序？</h4><p>关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便 是赋值操作）多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个内存屏障 （Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置</p><h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><p>​    volatile 变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反映到其他线程之中。从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看 不到不一致的情况，因此可以认为不存在一致性问题。但是由于java中的操作不是原子性的，所以多线程是不安全的。</p><p>指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。Volatile修饰的变量可以禁止指令重排序。</p><p>在操作前后加一个内存屏障</p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416190044852.png" alt="image-20210416190044852"></p><h4 id="线程的状态转换"><a href="#线程的状态转换" class="headerlink" title="线程的状态转换"></a>线程的状态转换</h4><p>·新建（New）：创建后尚未启动的线程处于这种状态。 </p><p>·运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可 能正在执行，也有可能正在等待着操作系统为它分配执行时间。 </p><p>·无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线 程显式唤醒。以下方法会让线程陷入无限期的等待状态： ■没有设置Timeout参数的Object::wait()方法； ■没有设置Timeout参数的Thread::join()方法； ■LockSupport::park()方法。 </p><p>·限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待 被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状 态： ■Thread::sleep()方法； ■设置了Timeout参数的Object::wait()方法； ■设置了Timeout参数的Thread::join()方法； ■LockSupport::parkNanos()方法； ■LockSupport::parkUntil()方法。 </p><p>·阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到 一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时 间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 </p><p>·结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</p><p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210416191130738.png" alt="image-20210416191130738"></p><h3 id="5-JVM调优"><a href="#5-JVM调优" class="headerlink" title="5.JVM调优"></a>5.JVM调优</h3><h4 id="设置堆大小"><a href="#设置堆大小" class="headerlink" title="设置堆大小"></a>设置堆大小</h4><p>Xms初始堆大小 </p><p>Xmx最大堆大小</p><p>PermSize 初始分配的非堆内存</p><p>MaxPermSize 最大非堆内存</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetson Nano 搭建Mysql</title>
      <link href="2021/05/12/Jetson-Nano-%E6%90%AD%E5%BB%BAMysql/"/>
      <url>2021/05/12/Jetson-Nano-%E6%90%AD%E5%BB%BAMysql/</url>
      
        <content type="html"><![CDATA[<h1>如何使用JetsonNano或者树莓派搭建自己的服务器？</h1><h3 id="nano介绍">nano介绍</h3><h4 id="Jetson-Nano和树莓派的区别">Jetson Nano和树莓派的区别</h4><p>Jetson Nano 是一款功能强大的小型计算机，专为支持入门级边缘 AI 应用程序和设备而设计，拥有完善的 NVIDIA JetPack™ SDK 包含用于深度学习、计算机视觉、图形、多媒体等方面的加速库。相比于树莓派多了显卡，也就是你可以通过图形化界面去操作，不只是命令行，在图像处理方面很强。</p><h4 id="系统">系统</h4><p>Jetson nano 官方系统是ubuntu，是在ubuntu上修改的NVIDIA系统 ubuntu18.04 LTS，好像是是aarch架构，系统界面如下</p><h3 id="安装配置mysql">安装配置mysql</h3><h4 id="安装">安装</h4><p>和直接在ubuntu上安装没有什么区别，直接使用apt-get install mysql-server 得到的是5.x版本，不是最新的8.x版本使用 apt-get 安装完后 会生成一些默认的账户在 /etc/mysql/debian.cnf中可以通过sudo cat /etc/mysql/debian.cnf查看</p><h4 id="配置用户">配置用户</h4><p>登录应该是需要安装mysqsl-client,也是使用apt-get install mysql-client安装</p><p>然后登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u username -p </span><br></pre></td></tr></table></figure><p>然后输入密码</p><p>新建用户，赋予权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create user &#39;username&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</span><br><span class="line">#username是你想创建的用户名</span><br><span class="line">#localhost是表示它可以通过那个ip来访问，localhost表示本地 其余ip表示其他地址 %表示所有</span><br><span class="line">#password是密码</span><br><span class="line">grant all privileges on 数据库.* to username@ip地址 ;</span><br><span class="line">#好像mysql的用户是通过 username+ip来区别，可以有连个username相同的用户，只要ip不一样。</span><br></pre></td></tr></table></figure><h4 id="修改配置文件，实现远程访问">修改配置文件，实现远程访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/mysql</span><br><span class="line"></span><br><span class="line">//然后ls一下 我的有下面这些东西，配置文件在mysql.conf.d中</span><br><span class="line">//conf.d      debian-start  my.cnf.fallback  mysql.conf.d</span><br><span class="line">//debian.cnf  my.cnf        mysql.cnf</span><br><span class="line"></span><br><span class="line">cd mysql.conf.d</span><br><span class="line">vim mysqld.cnf</span><br><span class="line">     //将地址127.0.0.1 改成0.0.0.0</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h4 id="mysql其他常用命令：">mysql其他常用命令：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql restart</span><br><span class="line">sudo netstat -tap | grep mysql        #查看是否允许</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置内网穿透">配置内网穿透</h3><p>我选择使用花生壳进行内网穿透，花生壳还是比较方便的。</p><p>应该是可以直接参考树莓派的官方教程https://service.oray.com/question/11639.html</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i phtunnel_5_0_rapi_aarch64.deb      #安装</span><br></pre></td></tr></table></figure><p>可以通过以下命令来操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">phddns           #查看命令</span><br><span class="line">phddns start#打开</span><br><span class="line">phddns status#可以查看SN码</span><br></pre></td></tr></table></figure><p>打开http://b.oray.com ，在登录页面中输入SN码与默认密码（admin）登录。</p><p>剩下的就看官方教程就好了https://service.oray.com/question/11639.html</p><p>建立的映射应该是tcp类型，绑定到3306端口</p><p><strong>注意，需要先给你的Nano 配置IP与MAC绑定，因为你的路由器应该是使用动态分配IP，打开192.168.1.1即可进行绑定，不然每次都要重新 在管理界面绑定一次</strong>。</p><h3 id="测试">测试</h3><p>可以先在内网测试一下能否脸上nano的mysql，使用ifconfig获得内网地址类似与192.168.1.101，然后在自己电脑上用workbench测试一下。</p><p>测试成功后绑定外网然后在外网试一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> jetson </tag>
            
            <tag> nano </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="2021/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>n</p><p>那些80年代的红砖还能叫红色吗，大概只能算是煤球渣子的近亲。正如唱歌的最终会沉默，昨日奔跑着的青年和鸵鸟，一转眼就是今天的腐肉、秃鹫。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.14字节面经</title>
      <link href="2021/03/14/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2/"/>
      <url>2021/03/14/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ol><li>项目</li><li>token如何解密的</li><li>session和cookie的区别</li><li>登陆的逻辑</li><li>两个栈实现一个队列</li><li>巴什博奕（Bash Game）：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。</li><li>hashMap的扩容原理，为什么扩容二倍；</li><li>写一个select语句  两个表 组合查询 我用嵌套实现的，他想考我join查询 </li><li>四大事务特性</li><li>TCP的可靠性是怎么实现的</li><li>TIME_WAIT</li><li>算法 有一个二维数组，里面的数字要么是0，要么是1，求出 全由1组成的正方形的面积最大是多少？</li></ol><p>二面：问项目和数据库。。。因为他们用的go  所以java一点没问 </p><ol><li>给一个正数 &gt;0 ，求这个数的平方根，结果精切到小数点后5位。（我是傻逼，本来很简单的题）</li><li>项目写了用的Oracle数据库，为什么用Oracle，Oracle与mysql数据库的区别？</li><li>Redis五大数据类型底层数据结构</li><li>如何使用Redis和MQ实现的抢购优惠券</li><li>Mysql表锁和行锁之间间隙锁是如何实现的。</li><li>四大事务特性的一致性是怎么实现的</li><li>讲一下可重复读</li><li>聚簇索引</li><li>undolog和redolog</li><li>HTTP状态码</li><li>HTTPS和HTTP的区别</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.9蚂蚁面经</title>
      <link href="2021/03/09/3-9%E8%9A%82%E8%9A%81%E9%9D%A2%E7%BB%8F/"/>
      <url>2021/03/09/3-9%E8%9A%82%E8%9A%81%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="1-项目"><a href="#1-项目" class="headerlink" title="1.项目"></a>1.项目</h4><h4 id="2-你是如何设计数据库的"><a href="#2-你是如何设计数据库的" class="headerlink" title="2.你是如何设计数据库的"></a>2.你是如何设计数据库的</h4><h4 id="3-HashMap-ConcurrentHashMap的区别"><a href="#3-HashMap-ConcurrentHashMap的区别" class="headerlink" title="3.HashMap  ConcurrentHashMap的区别"></a>3.HashMap  ConcurrentHashMap的区别</h4><h4 id="4-Array-List-LinkedList-扩容机制"><a href="#4-Array-List-LinkedList-扩容机制" class="headerlink" title="4.Array List   LinkedList   扩容机制"></a>4.Array List   LinkedList   扩容机制</h4><h4 id="5-JVM-堆（）中对象的转移？https-www-cnblogs-com-guanghe-p-10524314-html"><a href="#5-JVM-堆（）中对象的转移？https-www-cnblogs-com-guanghe-p-10524314-html" class="headerlink" title="5.JVM   堆（）中对象的转移？https://www.cnblogs.com/guanghe/p/10524314.html"></a>5.JVM   堆（）中对象的转移？<a href="https://www.cnblogs.com/guanghe/p/10524314.html">https://www.cnblogs.com/guanghe/p/10524314.html</a></h4><h4 id="6-数据库-悲观锁乐观锁-如何实现的？"><a href="#6-数据库-悲观锁乐观锁-如何实现的？" class="headerlink" title="6.数据库 悲观锁乐观锁  如何实现的？"></a>6.数据库 悲观锁乐观锁  如何实现的？</h4><h4 id="7-排序算法"><a href="#7-排序算法" class="headerlink" title="7.排序算法"></a>7.排序算法</h4><h4 id="8-算法：1G的文件、1M的内存，每一行一个词、求最高的100个词"><a href="#8-算法：1G的文件、1M的内存，每一行一个词、求最高的100个词" class="headerlink" title="8.算法：1G的文件、1M的内存，每一行一个词、求最高的100个词"></a>8.算法：1G的文件、1M的内存，每一行一个词、求最高的100个词</h4><h4 id="9-索引-在什么字段上建立索引，索引大概的原理"><a href="#9-索引-在什么字段上建立索引，索引大概的原理" class="headerlink" title="9.索引 在什么字段上建立索引，索引大概的原理"></a>9.索引 在什么字段上建立索引，索引大概的原理</h4><h4 id="10-Spring-Aop？原理？"><a href="#10-Spring-Aop？原理？" class="headerlink" title="10.Spring Aop？原理？"></a>10.Spring Aop？原理？</h4><h4 id="11-进程线程区别"><a href="#11-进程线程区别" class="headerlink" title="11.进程线程区别"></a>11.进程线程区别</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/08/%E5%8F%8D%E5%B0%84/"/>
      <url>2021/03/08/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>什么是反射？</p><p>​    </p><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><h3 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6?id=%E8%8E%B7%E5%8F%96-class-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F">获取 Class 对象的四种方式</a></h3><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p><p>1.知道具体类的情况下可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取Class对象不会进行初始化</p><p>2.通过 <code>Class.forName()</code>传入类的路径获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>Class.forName(className)方法，内部实际调用的是一个native方法  forName0(className, true, ClassLoader.getClassLoader(caller), caller);</p><p>第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。</p><p>一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。</p><p>3.通过对象实例<code>instance.getClass()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">Class alunbarClass2 = e.getClass();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>4.通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clazz</span> </span>= ClassLoader.LoadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>通过类加载器获取Class对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行</p><ol><li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li><li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li><li>动态配置实例的属性；</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/08/%E9%98%BF%E9%87%8C3.6%E7%AC%94%E8%AF%95%E9%A2%982/"/>
      <url>2021/03/08/%E9%98%BF%E9%87%8C3.6%E7%AC%94%E8%AF%95%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<p>给定N条线路</p><p>每条线路经过一些站点，判断能否从一个点到达另一个点；</p><p>floyd算法，但不需要求最短路径</p><p>输入：</p><p>2 3 6  两条线路 3起始站 6终点站</p><p>3    第i个线路经过几个站</p><p>1 6 7</p><p>4</p><p> 2 3 4 7</p><p>返回true</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="2021/03/08/%E9%9B%86%E5%90%88-1/"/>
      <url>2021/03/08/%E9%9B%86%E5%90%88-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="2021/03/07/Java%E5%9F%BA%E7%A1%80/"/>
      <url>2021/03/07/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="temp"><a href="#temp" class="headerlink" title="temp"></a>temp</h3><h4 id="说说final-finally-finalize"><a href="#说说final-finally-finalize" class="headerlink" title="说说final,finally,finalize"></a>说说final,finally,finalize</h4><p>final 分别修饰类 方法 变量的时候</p><h4 id="finalize使用的场合是什么"><a href="#finalize使用的场合是什么" class="headerlink" title="finalize使用的场合是什么"></a>finalize使用的场合是什么</h4><p>被废弃了已经，不建议使用。GC在回收对象是先将其加入一个队列，然后执行finalize方法在该方法可以实现自救，但finalize只能自己调用一次</p><h4 id="finally什么情况下不会执行"><a href="#finally什么情况下不会执行" class="headerlink" title="finally什么情况下不会执行"></a>finally什么情况下不会执行</h4><p>1 try语句没有执行 </p><p>2 在try中有System.exit(0)这种语句，会是JVM退出</p><p>3 在守护线程中Daemond</p><h4 id="JDK1-8新增了非常多的特性，本专题主要讨论以下几个"><a href="#JDK1-8新增了非常多的特性，本专题主要讨论以下几个" class="headerlink" title="JDK1.8新增了非常多的特性，本专题主要讨论以下几个"></a>JDK1.8新增了非常多的特性，本专题主要讨论以下几个</h4><ul><li><strong>Lambda表达式</strong>：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li><strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong>：默认方法就是一个在接口里面有了一个实现的方法。</li><li><strong>新工具</strong>：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li><strong>Stream API</strong>：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li><li><strong>Date Time API</strong>：加强对日期与时间的处理。</li><li><strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li><strong>Nashorn，JavaScript引擎</strong>：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><h4 id="多线程读多写少怎么优化"><a href="#多线程读多写少怎么优化" class="headerlink" title="多线程读多写少怎么优化"></a>多线程读多写少怎么优化</h4><p>多读少写的场景 如何提高性能<a href="https://blog.csdn.net/u013452337/article/details/90238052">https://blog.csdn.net/u013452337/article/details/90238052</a></p><p>ReentrantedLock（读读、读写、写写都是互斥）-&gt;ReentrantReadWriteLock（改进了读读，读写、写写还是互斥）-&gt;StampeddLock（允许在读的时候获得写锁，然后读锁阻塞）读写锁  但是会造成饥饿问题</p><p><a href="https://blog.csdn.net/qq_33220089/article/details/105173632">https://blog.csdn.net/qq_33220089/article/details/105173632</a></p><p>Mysql悲观锁乐观锁<a href="https://blog.csdn.net/qq_33220089/article/details/103920324">https://blog.csdn.net/qq_33220089/article/details/103920324</a></p><p>使用读写锁在CopyOnWriteArrayList中，写是往拷贝的数组中写，读是读原来的，写完后在赋值给原来的。通过volatile可见性实现。</p><h4 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h4><p>如果子类有一个无参构造函数，而父类没有无参构造函数、只有有参构造函数，则会编译不通过，子类的无参需要先调用父类的无参，而父类有了有参后，默认的无参就不生效了</p><p>自己整理的题目以及答案</p><h4 id="如何跳出多层循环"><a href="#如何跳出多层循环" class="headerlink" title="如何跳出多层循环"></a>如何跳出多层循环</h4><p>使用带有标号的break   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> a;</span><br></pre></td></tr></table></figure><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？"><a href="#讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？" class="headerlink" title="讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？"></a>讲一下包装类型和基本类型的区别？什么是自动拆箱和装箱？</h4><p>java有八大基本类型，short、int、long、float、double、boolean、byte、char  对于这个八个基本类型都有对应的包装类型，比如int Integer、Short与short、char与Character。基本类型到包装类型就是装箱、包装类型到基本类型就是拆箱。</p><p>对于Integer 来说， Integer i=1     调用了Intteger.valueOf()方法； int n=i 调用了Integer.intValue()方法；</p><h4 id="可能会到缓存池那里"><a href="#可能会到缓存池那里" class="headerlink" title="可能会到缓存池那里"></a>可能会到缓存池那里</h4><p>Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。</p><p>为了性能和资源之间平衡的最好结果。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>默认是同一个包内可见</p><p>protect是同一个包内+所有包的子类</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="为什么只有值传递？"><a href="#为什么只有值传递？" class="headerlink" title="为什么只有值传递？"></a>为什么只有值传递？</h4><p>程序设计语言来说，有值传递和引用传递；</p><p>在Java中，函数得到的都是对对象引用的一个拷贝；对于其他设计语言来讲，比如C++ 如果传递的是&amp; 则函数收到的就是这个对象。</p><h4 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h4><p>重载是指对象中可以有很多相同方法名相同的函数，根据不同的输入参数，可以做不同的事。方法签名包括方法名与参数。<strong>重载函数可以返回类型和访问修饰符可以不同</strong>。<strong>不能有两个方法签名相同但是返回类型不同的方法。</strong>就是不能依靠返回类型来判别。</p><p>重写是指子类对父类继承函数的重新编写，方法名、参数都必须相同。返回值必须比父类的更小或相等，抛出异常的范围要小于父类，访问修饰符的权限要大于等于父类。如果父类方法被final private static 修饰，不能被重写，对于static的函数可以重新声明，代表子类的静态函数。</p><p>返回值必须更小（子类）或者相等是指比如父类返回List  子类可以返回ArrayList （对于Void 和基本数据类型不可更改，只能和父类相同）</p><p>抛出异常： 也是指抛出的要是父类异常的子类</p><h4 id="静态方法为什么不能重写"><a href="#静态方法为什么不能重写" class="headerlink" title="静态方法为什么不能重写"></a>静态方法为什么不能重写</h4><p>静态属性和静态方法只是可以继承没有表现出多态性。根据《java编程思想》中的描述这是因为静态方法和静态属性没有采用动态绑定。即使你定义了相同的静态方法名，他也只是子类和父类的两个方法，并没有继承的关系，并且也会默认隐藏父类的静态方法。具体表现就是，将子类实例向上转型则会调用到基类中的静态方法和属性，不转型就调用子类自身的静态方法和属性。编译器不推荐通过实例去调用静态方法和属性，因为这种调用方式容易造成混淆。</p><p>可以通过子类去调用父类的静态方法，但是子类如果有相同名称的静态方法，会默认隐藏父类的静态方法</p><h4 id="深拷贝与浅拷贝的区别？"><a href="#深拷贝与浅拷贝的区别？" class="headerlink" title="深拷贝与浅拷贝的区别？"></a>深拷贝与浅拷贝的区别？</h4><p>对于基本属于类型来讲，这两个拷贝是一样的都是拷贝的值。</p><p>对于引用数据类型来讲，浅拷贝是指只拷贝当前对象对于对象中的各个属性对象不在继续拷贝。对于深拷贝来讲不仅拷贝当前对象，对于对象中的各个属性也会递归拷贝。</p><p>例如：有一个Student 中有teacher属性，对student 进行浅拷贝后，这两个student是不同的对象但是其中的teacher却指向了相同的对象。如果是深拷贝则会指向不同的对象。</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h4><p>泛型就是编写模板代码来适应任意类型</p><h4 id="为什么是伪泛型？"><a href="#为什么是伪泛型？" class="headerlink" title="为什么是伪泛型？"></a>为什么是伪泛型？</h4><p>Java泛型是伪泛型，对于List<String>和List<Integer>经过JVM编译后都会变成List 里面是通过Object来存储，所以对于List<Integer>我们可以通过反射来向里面添加String而不报错。</p><h4 id="都有什么泛型？"><a href="#都有什么泛型？" class="headerlink" title="都有什么泛型？"></a>都有什么泛型？</h4><p>类的泛型，对接口的泛型，对方法的泛型；</p><h4 id="？extend-Object-和？Super的区别？"><a href="#？extend-Object-和？Super的区别？" class="headerlink" title="？extend Object  和？Super的区别？"></a>？extend Object  和？Super的区别？</h4><p>？代表所有</p><p>?extend  C是指继承于C的都可以，确定了上限</p><p>？Super C是指是C的父类都可以，确定了下限</p><h3 id="Object-方法"><a href="#Object-方法" class="headerlink" title="Object 方法"></a>Object 方法</h3><p>equals  hashcode wait notify </p><h4 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h4><h4 id="为什么重写-equals-时必须重写-hashCode-方法？（和HashMap、HashSet查找有关）"><a href="#为什么重写-equals-时必须重写-hashCode-方法？（和HashMap、HashSet查找有关）" class="headerlink" title="为什么重写 equals 时必须重写 hashCode 方法？（和HashMap、HashSet查找有关）"></a>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？（和HashMap、HashSet查找有关）</h4><p>其实简单的说就是为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。</p><p>因为Object的Hashcode方法是native方法有JVMC或C++实现的，如果重写了equals方法而没有重写hashxcode 有可能出翔equals相等而hashcode不同。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="面向对象的三大特性？"><a href="#面向对象的三大特性？" class="headerlink" title="面向对象的三大特性？"></a>面向对象的三大特性？</h4><p>继承、子类拥有父类的所有属性和方法，但是被private修饰的不能访问</p><p>封装、</p><p>多态 程序中定义的引用类型调用的方法在编译时并不能确定，需要在运行时确定，具体表现就是通过父类来指向子类实现多态 或者通过接口来实现多态</p><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p>面向对象是一种 <strong>对现实世界理解和抽象的方法</strong>，是计算机编程技术发展到一定阶段后的产物。</p><p><strong>面向过程</strong>  (Procedure Oriented) 是一种 <strong>以过程为中心</strong> 的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。</p><h4 id="成员变量和局部变量的区别？"><a href="#成员变量和局部变量的区别？" class="headerlink" title="成员变量和局部变量的区别？"></a>成员变量和局部变量的区别？</h4><p>语法上 成员变量属于类 局部变量属于方法 成员变量可以用访问修饰符修饰 局部变量不能</p><p>内存分配上 成员变量在堆中 局部变量在栈中 如果局部变量是对象的话，也是在堆中分配，栈帧中存放一个引用 （可以分一下引用类型和基本类型）</p><p>生存时间：成员变量随着类  局部变量随着方法</p><p>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p><h4 id="静态方法和实例方法有什么不同？"><a href="#静态方法和实例方法有什么不同？" class="headerlink" title="静态方法和实例方法有什么不同？"></a>静态方法和实例方法有什么不同？</h4><p>静态方法属于类。对于静态方法其不能访问非静态属性，因为调用该静态方法的时候，该类可能没有对象，成员变量还没有初始化。可以通过类名和对象名来调用。</p><p>实例方法属于对象。只能通过对象名来调用实例方法</p><h4 id="接口和抽象类的不同"><a href="#接口和抽象类的不同" class="headerlink" title="接口和抽象类的不同?"></a>接口和抽象类的不同?</h4><p>含义上：而抽象类是对类的抽象,用于捕捉子类共同的特征。</p><p>抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。</p><p>从抽象来看 接口定义了一组行为规范，实现该接口的必须都要实现接口定义的方法</p><p>abstract class 表示的是is a关系，interface表示的是like a关系。</p><p>可以实现多个接口但只能继承一个抽象类。</p><p>语法上：</p><p>抽象类必修要有一个abstract方法，且抽象类不能被实例化，其余和普通方法一样，可以实现静态方法与普通方法、普通变量、静态变量、常量；</p><p>接口不能拥有普通方法与普通变量，但可以有默认方法实现，静态变量静态方法；</p><p>接口的默认访问权限是public，且不能有其他访问权限进行修饰；</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String的subString"><a href="#String的subString" class="headerlink" title="String的subString"></a>String的subString</h4><p>先判断类型lantin1还是utf16   然后分别调用StringLantin1.newString(byte数组，起始位置，长度)或者StringUtf16.newString()</p><h4 id="StringBuffer-SringBuilder-String-区别"><a href="#StringBuffer-SringBuilder-String-区别" class="headerlink" title="StringBuffer SringBuilder String 区别"></a>StringBuffer SringBuilder String 区别</h4><p>String类是被final修饰表示不可继承，其成员变量byte数组被private final修饰被final修饰指向数组不变，private并且没有提供修改数组的方法则整个 字符串是不i可变的。因为String的不可变性，我们每次对字符串操作其实都要生成一个新的字符串，然后指向新的字符串。会产生大量临时对象，然后GC会便麻烦。</p><p>builder和buffer中都是没有final修饰char数组，StringBuilder、<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。</p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>对于任意一个类我们都能知道这个类的属性和方法，对于任意一个对象我们都能调用它的任意一个属性和方法。这种动态获取信息以及动态调用方法的功能称为反射；</p><h4 id="知道获取Class对象的几种途径"><a href="#知道获取Class对象的几种途径" class="headerlink" title="知道获取Class对象的几种途径"></a>知道获取Class对象的几种途径</h4><p>（类名.class、Class.forname()、对象.getClass()</p><h4 id="通过Class对象创建出对象，获取出构造器，成员变量，方法"><a href="#通过Class对象创建出对象，获取出构造器，成员变量，方法" class="headerlink" title="通过Class对象创建出对象，获取出构造器，成员变量，方法"></a>通过Class对象创建出对象，获取出构造器，成员变量，方法</h4><p>.getPackage()、getModifiers()、getName()、getSimpleName()、getSuperclass()</p><p> 获取类属性<br>    getFields()    //获取所有的公共(public)字段包括父类       返回Field[]数组<br>   getDeclaredFields()  // 获取所有声明的字段(不包括父类)       返回Field[]<br>     getField(String name) //  获取指定的公共字段包括父类       返回Field<br>    getDeclaredField(String name)   // 获取指定的声明的字段(不包括父类)                返回Field</p><h4 id="通过反射的API修改成员变量的值，调用方法"><a href="#通过反射的API修改成员变量的值，调用方法" class="headerlink" title="通过反射的API修改成员变量的值，调用方法"></a>通过反射的API修改成员变量的值，调用方法</h4><p>操作类属性<br>**     操作静态属性<br>     类属性对象.get(null)              //返回静态属性的值<br>     类属性对象.set(null,”值”)                //赋值<br>**    操作非静态属性<br>    类属性对象.get(Object obj);<br>    类属性对象.set(Object obj,”值”);</p><h4 id="反射优缺点："><a href="#反射优缺点：" class="headerlink" title="反射优缺点："></a>反射优缺点：</h4><p>比较灵活，反射是框架设计的灵魂，</p><p>速度会变慢</p><h3 id="java异常体系"><a href="#java异常体系" class="headerlink" title="java异常体系"></a>java异常体系</h3><p>​    java异常都是继承于Throwable，分为Exception和Error。错误一般都是很严重的故障，通常不用捕获Error，比如OOM StackOverFlow</p><p>​    Exception分为runtime exception和IO Exception，比如Index OurofBound  NullPointer。</p><p>Exception还可以按可检查与不可检查来分类，可检查的Exception，如果对其没有做try 或者throws不能通过编译。class not found filenot found 。 </p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常</p><p>IO异常和SQL异常是受检查异常。除了runtime其余的都是受检查的异常。</p><h4 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h4><ul><li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li><li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li><li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li><li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h4 id="写代码的时候怎么处理异常，继承自Exception还是RuntimeException"><a href="#写代码的时候怎么处理异常，继承自Exception还是RuntimeException" class="headerlink" title="写代码的时候怎么处理异常，继承自Exception还是RuntimeException"></a>写代码的时候怎么处理异常，继承自Exception还是RuntimeException</h4><p>通常业务类异常如果希望它是Throwable的，或者带有业务语义的异常，就定义checked；系统类异常就unchecked。</p><p>如果我们的服务是很稳定的，可以继承自RuntimeException，不需要try catch去处理。如果不是稳定的，需要调用它的人对逻辑进行补充，那么可以继承自Exception。</p><h4 id="Error能被捕获吗？"><a href="#Error能被捕获吗？" class="headerlink" title="Error能被捕获吗？"></a>Error能被捕获吗？</h4><p>Error跟Exception一样都继承自Throwable，是指不应该被捕获的严重错误。实际上在代码中是可以被catch的。但是没用</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="ArrayList扩容机制grow"><a href="#ArrayList扩容机制grow" class="headerlink" title="ArrayList扩容机制grow"></a>ArrayList扩容机制grow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow函数调用grow(size+1)在另一个里面会调用newCapacity(size+1)，然后返回新的数组长度（原来的+原来的右移一位），然后调用Arrayss.copyOf()</p><h4 id="ArrayList-Add过程"><a href="#ArrayList-Add过程" class="headerlink" title="ArrayList  Add过程"></a>ArrayList  Add过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br><span class="line">add(e, elementData,  size);</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure><p>一个普通的add 会调用私有的add</p><p>先判断当前数组的容量是否和长度相同,相同则表示已经满了需要扩容调用grow</p><p>然后elementData[size]=e；</p><p>size++;</p><h4 id="Hashmap底层实现原理"><a href="#Hashmap底层实现原理" class="headerlink" title="Hashmap底层实现原理"></a>Hashmap底层实现原理</h4><ol><li><p>底层结构</p><p>内部是Entry数组，Entry包含四个字段，hash值，val，key，next；</p><p>数组中每一个位置都当成一个桶，在桶内使用拉链法解决哈希冲突的问题。</p><p>数组的大小为2的幂，默认16，寻址可以通过取余，但是太慢，当size为2的幂的时候，通过与size-1 &amp; 按位与会和取余得到相同的结果还很快；扩容的时候一个拆两个也会更容易。在分库的时候一般也是按2的幂来分库，更容易扩展。</p></li><li><p>put调用putval，1.8链表并不是头插法，是尾插入，要先比较有无key相同的情况。</p></li><li><p>扩容 </p><p>当map中的Entry数量大于阈值，就表明可能存在很多哈希冲突，导致性能下降，会进行扩容。 </p><p>先获取原数组+原容量+原阈值 获得新大小（对容量为0等情况进行了考虑）普通情况下得到2倍容量，然后将原数组映射到新数组，再指向新数组，映射是将hash与size与，因为size的后面全是0 的得到的都是0，第一位是1，通过这样可以快速将其分为高位和低位。</p></li><li><p>树化 每putVal之后会检查当前桶的大小是否大于8 大于8并且总的数组大小大于64会将该桶树化，数组大小小于64的话会扩容，因为扩容也会将该桶内的节点稀释到高位桶中。</p></li><li><p>加载因子用于控制HashMap的疏密程度，如果Entry数量/数组大小&gt;加载因子，表明将有很多哈希冲突，需要扩容</p></li><li><p>计算哈希值  null返回0   否则和hashcode的高16位异或。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure></li><li><p>get方法，先判断数组是否为空 数组的长度是否大于0，在数组的那个节点是否为null ，然后检查第一个节点是不是，然后判断结构，分别调用tree的方法和链表遍历判断equals</p></li></ol><p>capacity+阈值+扩容</p><h4 id="Hashmap底层实现原理-1"><a href="#Hashmap底层实现原理-1" class="headerlink" title="Hashmap底层实现原理"></a>Hashmap底层实现原理</h4><ol><li>size方法   size不仅要得到当前的大小，还需要得到当前CAS失败的数量。</li></ol><h4 id="TreeSet的底层数据结构"><a href="#TreeSet的底层数据结构" class="headerlink" title="TreeSet的底层数据结构"></a>TreeSet的底层数据结构</h4><p>使用TreeMap实现，和HashSet一样</p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>写/删时加锁，并且写的时候写道副本里，然后往副本写，写完后将原指针指向副本。</p><p>读直接读。</p><p>实现了读写分离。</p><h4 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h4><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>解决办法：</p><p>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</p><p>使用CopyOnWriteArrayList来替换ArrayList</p><h4 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h4><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><h4 id="HashMap-和TreeMap的区别"><a href="#HashMap-和TreeMap的区别" class="headerlink" title="HashMap 和TreeMap的区别"></a>HashMap 和TreeMap的区别</h4><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p><h4 id="HashMap和HashTable区别"><a href="#HashMap和HashTable区别" class="headerlink" title="HashMap和HashTable区别"></a>HashMap和HashTable区别</h4><p>HashTable是线程安全的，为每个方法加了Synchronized。HashTable继承于字典类。</p><p>Hash Table 中不能存在null   。HashMap中的key和value都可以是null</p><p>计算Hash的方式不同，hashtable是使用对象的hashcode，hashmap重新计算了hash值，通过和前面16位异或</p><p>计算索引的方法不同：hashtable是取余，hashmap是与length按位与&amp;</p><p>扩容hashtable 长度必须是奇数，减少hash碰撞；hashmap的2的幂</p><h4 id="HashTable和ConcurrentHashMap区别"><a href="#HashTable和ConcurrentHashMap区别" class="headerlink" title="HashTable和ConcurrentHashMap区别"></a>HashTable和ConcurrentHashMap区别</h4><p>HashTable粗暴的为每个方法加了Synchronized，为整个数组加了锁，效率很低。</p><p>ConHashMap在1.7中，将整个数组分为很多Segment，每个Segment中有几个Node，每次只对一个Segment加锁。在1.8中，取消了segment的使用，为每个节点使用CAS和Synchronized保证并发。</p><h4 id="ConcurrentHashMap中如何用的CAS和Synchronized"><a href="#ConcurrentHashMap中如何用的CAS和Synchronized" class="headerlink" title="ConcurrentHashMap中如何用的CAS和Synchronized"></a>ConcurrentHashMap中如何用的CAS和Synchronized</h4><p>put方法中，先判断key地方位置是否为空，如果是空就cas写入，如果不为空则需要加锁来对这个链表写入。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="进程线程的区别？"><a href="#进程线程的区别？" class="headerlink" title="进程线程的区别？"></a>进程线程的区别？</h4><p>进程是程序的一次执行，是系统运行程序的基本单位，相对于程序来讲他是动态的。进程是系统进行资源分配的基本单位，系统会为</p><p>线程是进程的一个执行单元，是进程内的调度实体，是系统进行资源调度的基本单位。</p><p>进程之间是互相独立的地址空间、独立的资源、同一个进程的多个线程之间共享本进程的地址空间，线程共享本进程的资源如内存、I/O、cpu等。在Java中，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p><p>进程切换时，消耗的资源大，线程切换时消耗的资源小。</p><p>线程之间通信更加方便，同一个进程下，线程共享全局变量，静态变量等数据，但是需要处理多线程并发的问题。</p><h4 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h4><p>新建NEW  还没有调用start方法</p><p>可运行-运行RUNNABLE   </p><p>阻塞  等待锁的时候进入阻塞状态 join </p><p>等待 wait()  通过notify()唤醒 </p><p>超时等待 sleep(1000) wait（1000） 通过notify()唤醒</p><p>终止 线程结束</p><h4 id="为什么要多线程？"><a href="#为什么要多线程？" class="headerlink" title="为什么要多线程？"></a>为什么要多线程？</h4><h4 id="为什么程序计数器、本地方法站、虚拟机栈是私有的？"><a href="#为什么程序计数器、本地方法站、虚拟机栈是私有的？" class="headerlink" title="为什么程序计数器、本地方法站、虚拟机栈是私有的？"></a>为什么程序计数器、本地方法站、虚拟机栈是私有的？</h4><h4 id="多线程可能遇到的问题？"><a href="#多线程可能遇到的问题？" class="headerlink" title="多线程可能遇到的问题？"></a>多线程可能遇到的问题？</h4><p>死锁、内存泄漏、不安全</p><h4 id="并发编程三要素？"><a href="#并发编程三要素？" class="headerlink" title="并发编程三要素？"></a>并发编程三要素？</h4><p>原子 可见 有序</p><h4 id="上下文是什么？切换？"><a href="#上下文是什么？切换？" class="headerlink" title="上下文是什么？切换？"></a>上下文是什么？切换？</h4><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。</p><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><h4 id="Java如何安全地停止一个线程-不等它运行结束"><a href="#Java如何安全地停止一个线程-不等它运行结束" class="headerlink" title="Java如何安全地停止一个线程(不等它运行结束)"></a>Java如何安全地停止一个线程(不等它运行结束)</h4><p>共享变量或者 interrupt（）  然后再run中不断判断isInterrupt()</p><h4 id="创建线程的四种方式？"><a href="#创建线程的四种方式？" class="headerlink" title="创建线程的四种方式？"></a>创建线程的四种方式？</h4><p>thread runnable callable 线程池</p><h4 id="Callable的创建过程？"><a href="#Callable的创建过程？" class="headerlink" title="Callable的创建过程？"></a>Callable的创建过程？</h4><ol><li>创建实现Callable接口的类myCallable</li><li>以myCallable为参数创建FutureTask对象</li><li>将FutureTask作为参数创建Thread对象</li><li>调用线程对象的start()方法</li></ol><h4 id="runnable-和-callable-有什么区别？"><a href="#runnable-和-callable-有什么区别？" class="headerlink" title="runnable 和 callable 有什么区别？"></a>runnable 和 callable 有什么区别？</h4><ol><li>返回值callable 通过futuretask.get()获取，且会阻塞当前主进程</li><li>runnable只能抛出运行时异常且无法捕获处理</li><li>callable的call方法允许抛出异常，可以获得异常信息。</li></ol><h4 id="run-和start-的区别？"><a href="#run-和start-的区别？" class="headerlink" title="run()和start()的区别？"></a>run()和start()的区别？</h4><p>start()方法用于启动线程，run()方法是线程体。run可以重复调用，而start只能调用一次。我们如果单独的调用run方法就相当于调用了普通的函数。</p><p>new一个线程进入到新建状态，start后进入可运行状态，在时间片到了之后就可以执行run方法了</p><h4 id="FutureTask原理？"><a href="#FutureTask原理？" class="headerlink" title="FutureTask原理？"></a>FutureTask原理？</h4><p>FutureTask用来表示一个异步执行任务的结果，可以通过get方法获得该结果，如果还没有完成会 阻塞。</p><p>FutureTask本身也实现了callable， 可以用它本身来构建futuretask</p><h4 id="Sleep和wait的区别"><a href="#Sleep和wait的区别" class="headerlink" title="Sleep和wait的区别"></a>Sleep和wait的区别</h4><p>wait是Object的方法，sleep是线程的方法</p><p>wait 释放锁sleep不释放锁</p><p>wait后需要notify来唤醒 wait(long time)会自动唤醒但是会争夺锁如果没有获得锁无法继续向下执行</p><p>sleep自动唤醒</p><h4 id="你是如何调用-wait-方法的？使用-if-块还是循环？为什么？"><a href="#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？" class="headerlink" title="你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h4><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p><h4 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h4><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p><p>wait(), notify()和 notifyAll()这些方法在同步代码块中调用</p><p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p><p>综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。</p><h4 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h4><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p><h4 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h4><p>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><h4 id="为什么要线程池？"><a href="#为什么要线程池？" class="headerlink" title="为什么要线程池？"></a>为什么要线程池？</h4><p>因为对象的创建和销毁是很花费时间的，因为创建一个对象需要获取内存和其它资源。对于线程对象也是如此，所以我们将若干线程放入到线程池中，然后如果有任务来就把任务给线程去执行，减少线程创建和销毁的时间。</p><h4 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h4><p>线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p><h4 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h4><p>new ThreadPoolExcutor()</p><p>使用Excutors工具类创建</p><h4 id="什么是-Executor-框架？为什么使用-Executor-框架？"><a href="#什么是-Executor-框架？为什么使用-Executor-框架？" class="headerlink" title="什么是 Executor 框架？为什么使用 Executor 框架？"></a>什么是 Executor 框架？为什么使用 Executor 框架？</h4><p>使用<strong>Executors</strong>工具类可以很方便的创建线程池。</p><h4 id="自定义线程池ThreadPoolExecutor线程池的参数"><a href="#自定义线程池ThreadPoolExecutor线程池的参数" class="headerlink" title="自定义线程池ThreadPoolExecutor线程池的参数"></a>自定义线程池ThreadPoolExecutor线程池的参数</h4><p><a href="https://juejin.cn/post/6844903475197788168">https://juejin.cn/post/6844903475197788168</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> corePoolSize,</span><br><span class="line"><span class="keyword">int</span> maximumPoolSize,</span><br><span class="line"><span class="keyword">long</span> keepAliveTime,</span><br><span class="line">TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">ThreadFactory threadFactory,</span><br><span class="line">RejectedExecutionHandler handler</span><br></pre></td></tr></table></figure><ul><li><p><code>corePoolSize=&gt; </code>线程池里的核心线程数量</p></li><li><p><code>maximumPoolSize</code>=&gt; 线程池里允许有的最大线程数量</p></li><li><p><code>keepAliveTime=&gt; </code>空闲线程存活时间</p></li><li><p><code>unit=&gt; </code>keepAliveTime的时间单位,比如分钟,小时等</p></li><li><p><code>workQueue=&gt; 缓冲</code>队列</p></li><li><p><code>threadFactory=&gt; </code>线程工厂用来创建新的线程放入线程池</p></li><li><p><code>handler=&gt; </code>线程池拒绝任务的处理策略,比如抛出异常等策略</p></li><li><p>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</p><p>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</p><p>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</p><p>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</p></li></ul><h4 id="Executors创建的线程池的类型"><a href="#Executors创建的线程池的类型" class="headerlink" title="Executors创建的线程池的类型"></a>Executors创建的线程池的类型</h4><p>java.util.concurrent.Executors 提供了一系列静态方法来创建各种线程池。下面例举出了主要的一些线程池及特性，其它未例举线程池的特性可由下面这些推导出来。</p><h5 id="线程数固定的线程池-Fixed-Thread-Pool"><a href="#线程数固定的线程池-Fixed-Thread-Pool" class="headerlink" title="线程数固定的线程池 Fixed Thread Pool"></a>线程数固定的线程池 Fixed Thread Pool</h5><p>顾名思义，这种类型线程池线程数量是固定的。如果线程数量设置为n，则任何时刻该线程池最多只有n个线程处于运行状态。当线程池中处于饱和运行状态时，再往线程池中提交的任务会被放到执行队列中。如果线程池处于不饱和状态，线程池也会一直存在，直到ExecuteService 的shutdown方法被调用，线程池才会被清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建线程数量为5的线程池。&#96;&#96;ExecutorService executorService &#x3D; Executors.newFixedThreadPool(&#96;&#96;5&#96;&#96;);</span><br></pre></td></tr></table></figure><p> 它使用的阻塞队列是Linked  无限大，所以可能会堆积大量任务 然后OOM</p><h5 id="可缓存的线程池-Cached-Thread-Pool"><a href="#可缓存的线程池-Cached-Thread-Pool" class="headerlink" title="可缓存的线程池 Cached Thread Pool"></a>可缓存的线程池 Cached Thread Pool</h5><p>这种类型的线程池初始大小为0个线程，随着往池里不断提交任务，如果线程池里面没有闲置线程（0个线程也表示没有闲置线程），则会创建新的线程，保证没有任务在等待；如果有闲置线程，则复用闲置状态线程执行任务。处于闲置状态的线程只会在线程池中缓存60秒，闲置时间达到60s的线程会被关闭并移出线程池。在处理大量短暂的（官方说法：short-lived）异步任务时可以显著得提供程序性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个可缓存的线程池 &#96;&#96;ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure><p> 他会构建一个 最大线程为无限大的线程池</p><h5 id="单线程池"><a href="#单线程池" class="headerlink" title="单线程池"></a>单线程池</h5><p>这或许不能叫线程池了，由于它里面的线程永远只有1个，而且自始至终都只有1个（为什么说这句话，因为要和 Executors.newFixedThreadPool(1) 区别开来），所以还是叫它“单线程池把”。你尽可以往单线程池中添加任务，但是每次只执行1个，且任务是按顺序执行的。如果前面的任务出现了异常，当前线程会被销毁，但1个新的线程会被创建用来执行后面的任务。以上这些和线程数只有1个的线程Fixed Thread Pool一样。两者唯一不同的是， Executors.newFixedThreadPool(1) 可以在运行时修改它里面的线程数，而 Executors.newSingleThreadExecutor() 永远只能有1个线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个单线程池&#96;&#96;ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><p> 它使用的阻塞队列是Linked  无限大，所以可能会堆积大量任务 然后OOM</p><h5 id="大小无限线程池"><a href="#大小无限线程池" class="headerlink" title="大小无限线程池"></a>大小无限线程池</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService &#x3D; Executors.newScheduledThreadPool();</span><br></pre></td></tr></table></figure><p>核心线程自定义 可以是Integer.MAX_VALUE</p><h4 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h4><ul><li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li><li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</li></ul><p>综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。</p><h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><h4 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h4><p>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</p><p>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</p><p>异常处理：submit()方便Exception处理</p><p><code>submit()</code>执行Runnable的任务时，run()方法没显式抛出异常。<br><code>execute()</code>执行Callable的任务时，call()方法有显式的抛出异常。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="如何定义一个注解"><a href="#如何定义一个注解" class="headerlink" title="如何定义一个注解"></a>如何定义一个注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Hahaha&#123;</span><br><span class="line"> <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过四种元注解修饰注解：@Target，@Retention，@Documented，@Inherited,</p><h4 id="哪里用到了线程池？"><a href="#哪里用到了线程池？" class="headerlink" title="哪里用到了线程池？"></a>哪里用到了线程池？</h4><p>连接数据库的时候Druid</p><p><strong>jion()方法：</strong>线程实例的join()方法可以使得一个线程在另一个线程结束后再执行，即也就是说使得<strong>当前线程可以阻塞其他线程执行；</strong></p><blockquote><p>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。</p><p>比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p></blockquote><h4 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h4><p>理论上，yield意味着放手，放弃，投降。一个调用yield()方法的线程告诉虚拟机它乐意让其他线程占用自己的位置。这表明该线程没有在做一些紧急的事情。注意，这仅是一个暗示，并不能保证不会产生任何影响。</p><h4 id="System-out-println-线程安全？"><a href="#System-out-println-线程安全？" class="headerlink" title="System.out.println()线程安全？"></a>System.out.println()线程安全？</h4><p>是安全的，通过synchronized实现</p><p><a href="https://blog.csdn.net/ft305977550/article/details/78769573">https://blog.csdn.net/ft305977550/article/details/78769573</a></p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="流的划分"><a href="#流的划分" class="headerlink" title="流的划分"></a>流的划分</h4><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><h4 id="四个抽象基类"><a href="#四个抽象基类" class="headerlink" title="四个抽象基类"></a>四个抽象基类</h4><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>select  poll  epoll是linux中实现io多路复用的方法，</p><h4 id="JAVA中的NIO"><a href="#JAVA中的NIO" class="headerlink" title="JAVA中的NIO"></a>JAVA中的NIO</h4><p>Java的NIO模式的Selector网络通讯，其实就是一个简单的Reactor模型。可以说是Reactor模型的朴素原型。</p><p><a href="http://www.cyc2018.xyz/Java/Java%20IO.html#%E4%B8%83%E3%80%81nio">http://www.cyc2018.xyz/Java/Java%20IO.html#%E4%B8%83%E3%80%81nio</a></p><p><strong>通道</strong> <strong>Channel</strong>  </p><p>**缓冲区 ** </p><p>**选择器 ** </p><p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p><p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p><p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存区域</title>
      <link href="2021/03/07/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>2021/03/07/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h5 id="看了好多面经，感觉还是要看书，然后自己整理一下-于是决定看深入理解java虚拟机这本书"><a href="#看了好多面经，感觉还是要看书，然后自己整理一下-于是决定看深入理解java虚拟机这本书" class="headerlink" title="###看了好多面经，感觉还是要看书，然后自己整理一下,于是决定看深入理解java虚拟机这本书###"></a>###看了好多面经，感觉还是要看书，然后自己整理一下,于是决定看深入理解java虚拟机这本书###</h5><h5 id="Java与C-之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里-面的人却想出来。"><a href="#Java与C-之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里-面的人却想出来。" class="headerlink" title="####Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里 面的人却想出来。####"></a>####Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里 面的人却想出来。####</h5><h4 id="1-JVM内存区域分为五大部分："><a href="#1-JVM内存区域分为五大部分：" class="headerlink" title="1.JVM内存区域分为五大部分："></a>1.JVM内存区域分为五大部分：</h4><h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>   java线程的栈帧，线程的每一个方法会生成一个栈帧，用于存放该线程的局部变量表、操作数栈、动态连接、方法出口等信息。随着方法的调用与结束，对应着入栈与出栈；局部变量表中存放着方法参数和内部定义的局部变量，基本存储单位是方法槽。<br>    动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用是为了支持方法调用过程中的动态连接(DynamicLinking) 这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析  另外一部分符号引用将在每一次运行期间都转化为直接引用，这部分就称为动态连接<br>    操作数栈：java虚拟机栈中的一个用于计算的临时数据存储区</p><h5 id="本地方法栈-Native方法的栈帧-和虚拟机栈差不多，只不过是调用ni方法的栈帧"><a href="#本地方法栈-Native方法的栈帧-和虚拟机栈差不多，只不过是调用ni方法的栈帧" class="headerlink" title="本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧"></a>本地方法栈 Native方法的栈帧  和虚拟机栈差不多，只不过是调用ni方法的栈帧</h5><h5 id="堆-几乎所有的对象都在这里分配内存"><a href="#堆-几乎所有的对象都在这里分配内存" class="headerlink" title="堆  几乎所有的对象都在这里分配内存"></a>堆  几乎所有的对象都在这里分配内存</h5><p>​    堆分为老年代、新生代、永久代；</p><p>​    新生代分为Eden FromSurvivors To Survivors  8：1：1</p><p>​    这两个Survivors有什么用呢？</p><p>​    在分配内存时，每次只使用一块Eden和 Survivor然后使用标记复制算法将其复制到另一块Survivor上。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）。</p><h5 id="方法区-："><a href="#方法区-：" class="headerlink" title="方法区 ："></a>方法区 ：</h5><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><h5 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h5><p> 当前线程字节码文件的行号指示器，通过改变该计数器的值来获得下一步执行的字节码指令；程序控制流的指示器，程序当中的分支、循环、线程恢复、跳转、异常处理都要由它指示。由于Java虚拟机通过时间片轮转实现多线程，所以每一个线程都需要一个程序计数器记录当前执行的位置。</p><h4 id="2-Java对象的创建过程：（每一步详细实现）"><a href="#2-Java对象的创建过程：（每一步详细实现）" class="headerlink" title="2.Java对象的创建过程：（每一步详细实现）"></a>2.Java对象的创建过程：（每一步详细实现）</h4><p>​    检查类是否加载</p><p>​    分配内存，在堆中分配内存</p><p>​    初始化   为变量赋默认值</p><p>​    设置对象头</p><p>​    执行init</p><h4 id="3-对象访问定位的方式："><a href="#3-对象访问定位的方式：" class="headerlink" title="3.对象访问定位的方式："></a>3.对象访问定位的方式：</h4><p>​    句柄池：每一个句柄   数据结构中包括对象数据的指针以及类的指针</p><p>​    直接指针 在对象数据中存放类指针</p><h4 id="4-JVM内存分配与回收："><a href="#4-JVM内存分配与回收：" class="headerlink" title="4.JVM内存分配与回收："></a>4.JVM内存分配与回收：</h4><p>​    大对象直接放在老年代</p><p>​     对象有限在eden分配</p><p>​    长期存活的对象进入老年代</p><h4 id="5堆内存中对象分配的基本策略：2种"><a href="#5堆内存中对象分配的基本策略：2种" class="headerlink" title="5堆内存中对象分配的基本策略：2种"></a>5堆内存中对象分配的基本策略：2种</h4><p>​    碰撞指针、空闲表</p><h5 id="并发问题如何解决"><a href="#并发问题如何解决" class="headerlink" title="并发问题如何解决"></a>并发问题如何解决</h5><p>   CAS乐观锁+失败重试   先创建失败了就重试  </p><p>   TLAB  为每个线程在Eden初设一点内存，现在TLAB分配 当TLAB用完后，用CAS+失败重试</p><h4 id="6-如何判断对象是否死亡："><a href="#6-如何判断对象是否死亡：" class="headerlink" title="6.如何判断对象是否死亡："></a>6.如何判断对象是否死亡：</h4><p>​    如果没有任何一个对象引用该对象则判断为死亡（可达性方法）</p><p>​     （引用计数法）没引用一次加一取消引用减一；不好解决互相引用的问题；</p><h5 id="GCRoots有哪些？"><a href="#GCRoots有哪些？" class="headerlink" title="GCRoots有哪些？"></a>GCRoots有哪些？</h5><p>​        虚拟机栈中引用的对象，本地方法栈中引用的对象</p><p>​        方法区中常量引用的对象，方法区中类静态属性引用的对象</p><h4 id="7-如何判断常量是否无用，类是否无用？"><a href="#7-如何判断常量是否无用，类是否无用？" class="headerlink" title="7.如何判断常量是否无用，类是否无用？"></a>7.如何判断常量是否无用，类是否无用？</h4><p>​    常量无用：没有引用即可</p><p>​    类无用：该Class类没有被引用、没有该类的对象还在存活、该类的ClassLoader已经销毁</p><h4 id="8-GC的算法有哪些？3种"><a href="#8-GC的算法有哪些？3种" class="headerlink" title="8.GC的算法有哪些？3种"></a>8.GC的算法有哪些？3种</h4><p>​    标记-清除 （可以标记被清除的，也可以标记不被清除的）造成空间破碎</p><p>​    标记 复制 （可利用空间减半）</p><p>​    标记 整理 老年代专用</p><h4 id="9-常见的垃圾回收器"><a href="#9-常见的垃圾回收器" class="headerlink" title="9.常见的垃圾回收器"></a>9.常见的垃圾回收器</h4><p>​    七个收集器（三个新生代 三个老年代 G1通吃）</p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210307141614043.png" alt="image-20210307141614043" style="zoom: 50%;" /><p>G1跳出了这个樊笼，它可以面向堆内存任 何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式</p><p>G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理 论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的 分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的 旧对象都能获取很好的收集效果。</p><p>两个支持低延迟垃圾收集器（ZGC  、 Sh。。。）以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</p><img src="C:\Users\花椒茴香\AppData\Roaming\Typora\typora-user-images\image-20210307142929097.png" alt="image-20210307142929097" style="zoom:50%;" /><h4 id="10-HotSpot虚拟机实现："><a href="#10-HotSpot虚拟机实现：" class="headerlink" title="10.HotSpot虚拟机实现："></a>10.HotSpot虚拟机实现：</h4><p>根节点枚举、安全点、写屏障</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标模块</title>
      <link href="2021/03/05/%E7%9B%AE%E6%A0%87%E6%A8%A1%E5%9D%97/"/>
      <url>2021/03/05/%E7%9B%AE%E6%A0%87%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>1.Lambda表达式<br>2.Stream流计算<br>3.函数式接口</p><p>4.多线程部分</p><p>5.JVM虚拟机</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>习概笔记</title>
      <link href="2021/03/04/%E4%B9%A0%E6%A6%82/"/>
      <url>2021/03/04/%E4%B9%A0%E6%A6%82/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>天下为私</p><p>大道之行也，天下为公；</p><p>今大道既隐，天下为家；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 习概 </tag>
            
            <tag> 毛概 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式的实现</title>
      <link href="2021/03/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>2021/03/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="单例模式实现的六种方法"><a href="#单例模式实现的六种方法" class="headerlink" title="单例模式实现的六种方法"></a>单例模式实现的六种方法</h4><h5 id="1懒汉模式"><a href="#1懒汉模式" class="headerlink" title="1懒汉模式"></a>1懒汉模式</h5><p> 获取时判断是否为null，然后创建</p><p> 可能会出现线程安全问题，所以对他加上Synchronize</p><h5 id="2-Synchronize修饰的get方法"><a href="#2-Synchronize修饰的get方法" class="headerlink" title="2.Synchronize修饰的get方法"></a>2.Synchronize修饰的get方法</h5><p>  速度会很慢，通过双重校验锁法来实现</p><h5 id="3-双重校验锁法"><a href="#3-双重校验锁法" class="headerlink" title="3.双重校验锁法"></a>3.双重校验锁法</h5><p>在get方法中，先判断是否为null，为空则加一个Synchronize代码块，里面还需要再判断一次，因为可能有多个线程同时阻塞在了这里，当第一个创建好后，没有判断的话还会创建其他的。</p><p>实例需要添加volatile修饰符  禁止指令重排序保证线程安全</p><h4 id="4-饿汉模式"><a href="#4-饿汉模式" class="headerlink" title="4.饿汉模式"></a>4.饿汉模式</h4><p>直接在定义的时候就实现</p><h4 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5.静态内部类"></a>5.静态内部类</h4><p>定义一个静态内部类</p><p>通过一个方法返回该内部类</p><p>实现了懒加载</p><h4 id="6-枚举类实现"><a href="#6-枚举类实现" class="headerlink" title="6.枚举类实现"></a>6.枚举类实现</h4><p><a href="https://cloud.tencent.com/developer/article/1497592">https://cloud.tencent.com/developer/article/1497592</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="2021/03/01/HashMap/"/>
      <url>2021/03/01/HashMap/</url>
      
        <content type="html"><![CDATA[<h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hash table based implementation of the &#123;@code Map&#125; interface.  This</span></span><br><span class="line"><span class="comment">//implementation provides all of the optional map operations, and permits</span></span><br><span class="line"><span class="comment">//&#123;@code null&#125; values and the &#123;@code null&#125; key. </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*  实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap继承于抽象Map类，抽象Map类为Map接口实现了一些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//This implementation provides constant-time performance for the basic</span></span><br><span class="line"><span class="comment">//operations (&#123;@code get&#125; and &#123;@code put&#125;), </span></span><br></pre></td></tr></table></figure><p>HasmMap实现了常量级的get和put操作实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//An instance of &#123;@code HashMap&#125; has two parameters that affect its</span></span><br><span class="line"><span class="comment">//performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.</span></span><br></pre></td></tr></table></figure><p>HashMap是不同步的，可以在外面套一个 Collections.synchronizedMap来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap(...));</span><br></pre></td></tr></table></figure><p>HashMap通常使用数组+链表的实现方式，当bins变得很大时，链表会变成红黑树，每一个bin都相当于TreeMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This map usually acts as a binned (bucketed) hash table, but</span></span><br><span class="line"><span class="comment">* when bins get too large, they are transformed into bins of</span></span><br><span class="line"><span class="comment">* TreeNodes, each structured similarly to those in</span></span><br><span class="line"><span class="comment">* java.util.TreeMap. Most methods try to use normal bins, but</span></span><br><span class="line"><span class="comment">* relay to TreeNode methods when applicable (simply by checking</span></span><br><span class="line"><span class="comment">* instanceof a node).  Bins of TreeNodes may be traversed and</span></span><br><span class="line"><span class="comment">* used like any others, but additionally support faster lookup</span></span><br><span class="line"><span class="comment">* when overpopulated. However, since the vast majority of bins in</span></span><br><span class="line"><span class="comment">* normal use are not overpopulated, checking for existence of</span></span><br><span class="line"><span class="comment">* tree bins may be delayed in the course of table methods.</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><h4 id="2-一些参数fields"><a href="#2-一些参数fields" class="headerlink" title="2.一些参数fields"></a>2.一些参数fields</h4><p>DEFAULT_INITIAL_CAPACITY初始化容量，默认16，且必须是2的幂。（为何要2的幂，因为哈希函数为hash(key)&amp; capacity-1 这样就可以很快的确定位置（如果使用hash%数组大小的话也可以，但是会很慢）。<a href="https://www.iteye.com/topic/539465%EF%BC%89">https://www.iteye.com/topic/539465）</a></p><p>MAXIMUM_CAPACITY 最大容量小于2^30。</p><p>DEFAULT_LOAD_FACTOR默认加载因子 0.75.</p><p>TREEIFY_THRESHOLD 当bins中的节点大于其是会转化为红黑树</p><p>UNTREEIFY_THRESHOLD 小于其时会变成链表</p><p>MIN_TREEIFY_CAPACITY 最小表容量应大于4*TREEIFY_THRESHOLD</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-Node类-普通Node和TreNode"><a href="#3-Node类-普通Node和TreNode" class="headerlink" title="3.Node类 普通Node和TreNode"></a>3.Node类 普通Node和TreNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.类的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;<span class="comment">//获得类的哈希值 右移16位</span></span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//https://blog.csdn.net/qq_42034205/article/details/90384772</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns x&#x27;s Class if it is of the form &quot;class C implements</span></span><br><span class="line"><span class="comment"> * Comparable&lt;C&gt;&quot;, else null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; ParameterizedType p;</span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Type t : ts) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((t <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType) t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable</span></span><br><span class="line"><span class="comment"> * class), else 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> 检查所传的参数是否为2的幂次方，且不能为负数（负数变为1），且不能超过常量MAXIMUM_CAPACITY（超过变为MAXIMUM_CAPACITY），如果不为2的幂次方，将其变为，比cap大的最小的2的幂次方的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-fields"><a href="#5-fields" class="headerlink" title="5.fields"></a>5.fields</h4><h5 id="Node表"><a href="#Node表" class="headerlink" title="Node表"></a>Node表</h5><p>transient<a href="https://www.cnblogs.com/lanxuezaipiao/p/3369962.html">https://www.cnblogs.com/lanxuezaipiao/p/3369962.html</a></p><h5 id="entrySet键值对集合"><a href="#entrySet键值对集合" class="headerlink" title="entrySet键值对集合"></a>entrySet键值对集合</h5><h5 id="当前数量size"><a href="#当前数量size" class="headerlink" title="当前数量size"></a>当前数量size</h5><h5 id="结构性修改的次数modcount"><a href="#结构性修改的次数modcount" class="headerlink" title="结构性修改的次数modcount"></a>结构性修改的次数modcount</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>threshold  当size&gt;threhold时变成红黑树。</p><h5 id="加载因子，默认0-75"><a href="#加载因子，默认0-75" class="headerlink" title="加载因子，默认0.75"></a>加载因子，默认0.75</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h4 id="6-构造函数"><a href="#6-构造函数" class="headerlink" title="6.构造函数"></a>6.构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &#123;<span class="doctag">@code</span> HashMap&#125; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &#123;<span class="doctag">@code</span> Map&#125;.  The &#123;<span class="doctag">@code</span> HashMap&#125; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &#123;<span class="doctag">@code</span> Map&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment"> * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7.get方法"></a>7.get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">get()方法调用getNode方法，传入hash值和key值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> 如果 table不为空 table[(n - 1) &amp; hash]不为空，说明该点有值</span></span><br><span class="line"><span class="comment"> 判断第一个是不是，然后往下判断</span></span><br><span class="line"><span class="comment"> 如果是TreeNode类型，直接getTreeNode();</span></span><br><span class="line"><span class="comment"> 否则链表往下判断；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node &lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-put方法"><a href="#8-put方法" class="headerlink" title="8.put方法"></a>8.put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">调用putVal方法，设置值或更新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment"> *         (A &#123;<span class="doctag">@code</span> null&#125; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &#123;<span class="doctag">@code</span> null&#125; with &#123;<span class="doctag">@code</span> key&#125;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//如果table为空，resize一下</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//如果当前table中(n - 1) &amp; hash位置为空，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果不为空，找到key的那个entry</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//先判断第一个</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//然后往下判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//如果是Tree实现的，调用树的putTreeVal()方法</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//说明是链表实现的 循环判断</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">//查找后存在该点，更新值返回oldValue existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明原来table中没有带key的entry ，插入了一个新的，判断是否需要resize()</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-resize方法"><a href="#9-resize方法" class="headerlink" title="9.resize方法"></a>9.resize方法</h4><p>分为三步：获取原表、创建新表、为新表添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一部分</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;  <span class="comment">//复制旧表</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//获得旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">//旧阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;<span class="comment">//新容量和新阈值</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//分支1</span></span><br><span class="line">        <span class="comment">//说明原来表中有东西zMAX_VALUE</span></span><br><span class="line">        <span class="comment">//可能是添加的时候或者其他时调用了resize方法，然后将xin容量设置为原来的两倍且小于MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="comment">//对于阈值：如果本来的oldcap已经是MAXIMUM_CAPACITY，那么将阈值调为整数最大值，其实就是MAXIMUM_CAPACITY，这样不会再扩大容量，如果newcap还是小于MAXIMUM_CAPACITY，则也将新阈值*2</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">//分支2</span></span><br><span class="line">        <span class="comment">//说明原来表里没有元素，但是还调用了resize，说明调用了带初始容量的构造方法</span></span><br><span class="line">        <span class="comment">//只需要将新容量设置为旧的阈值，然后一会判断一下新阈值是否是0；如果是0，则将新阈值设置为容量*加载因子</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">//分支3</span></span><br><span class="line">        <span class="comment">//到这里就是一开始是调用了无参构造方法，只需将容量阈值设置成默认的即可。</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面的对分支2没有设置新阈值的情况在判断一下，设置一下新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三部分</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//创建新Node数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果旧数组为空，则不需要复制；不为空就需要执行下面的赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;<span class="comment">//循环遍历数组</span></span><br><span class="line">           <span class="comment">//判断下当前位置是否有值，没有则跳过，有就将旧的复制到新的里面</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="comment">//HashMap使用数组+链表或者数组+红黑树，需要分三种情况讨论</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//说明当前桶内只有一个节点，直接复制</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是TreeNode的情况</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//链表的情况，而且由于新表是原表的两倍大。对于新表的哈希地址其实有两种情况，低位和高位，分别对应c1，c2</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//c1  如果等于0 说明e.hash的第i位是0,因为oldcap的第i位是1，当我们把newcap=oldcap&lt;&lt;1时，e.hash&amp;newCap-1不会发生变化</span></span><br><span class="line">                            <span class="comment">//说明是要放在低位</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//c2</span></span><br><span class="line">                            <span class="comment">//说明要放在高位</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将低位链表放在低位</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将低位链表放在高位</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是TreeNode类的静态方法split，将某个树枝拆分为高位树枝和低位树枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment"> * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment"> * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2021/3/2未完</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashTable</title>
      <link href="2021/03/01/HashTable/"/>
      <url>2021/03/01/HashTable/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210301230055892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YWppYW9odWl4aWFuZw==,size_16,color_FFFFFF,t_70"></p><p>HashTable继承于Dictionary类，字典类是一个抽象类，而且已经被废弃了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">NOTE:</span> This class is obsolete.  New implementations should</span></span><br><span class="line"><span class="comment">//implement the Map interface, rather than extending this class.</span></span><br></pre></td></tr></table></figure><p>对于Hashtable使用场景也很少，因为JDK中有一个和他类似的类，HashMap。</p><p>Hashtable和Hashmap的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(The &#123;<span class="meta">@code</span> HashMap&#125;<span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">roughly</span> <span class="title">equivalent</span> <span class="title">to</span> </span>&#123;<span class="meta">@code</span> Hashtable&#125;, except that it is unsynchronized and permits nulls.) </span><br></pre></td></tr></table></figure><p>HashTable比HashMap多了同步，少了对null的支持，，所以我们可以直接移步到HashMap。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronize</title>
      <link href="2021/02/25/Synchronize/"/>
      <url>2021/02/25/Synchronize/</url>
      
        <content type="html"><![CDATA[<p>Synchronized的用法<br><a href="https://blog.csdn.net/luoweifu/article/details/46613015">https://blog.csdn.net/luoweifu/article/details/46613015</a></p><p>额外：<br>同步与互斥的区别：<a href="https://www.cnblogs.com/baizhanshi/p/6844356.html">https://www.cnblogs.com/baizhanshi/p/6844356.html</a></p><p>进程线程基础<br><a href="https://blog.csdn.net/luoweifu/article/details/46595285">https://blog.csdn.net/luoweifu/article/details/46595285</a><br>java中的 多线程<a href="https://blog.csdn.net/luoweifu/article/details/46673975">https://blog.csdn.net/luoweifu/article/details/46673975</a></p><p>3/2更新</p><p>Synchronized的原理：</p><p>详细<a href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a></p><p>简单<a href="https://blog.csdn.net/u011212394/article/details/82228321">https://blog.csdn.net/u011212394/article/details/82228321</a></p><p>偏向锁、轻量锁、重量锁的升级 <a href="https://www.cnblogs.com/mcjhcnblogs/p/14226505.html">https://www.cnblogs.com/mcjhcnblogs/p/14226505.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装Redis、Mysql</title>
      <link href="2021/02/23/%E5%AE%89%E8%A3%85Redis%EF%BC%8CMysql/"/>
      <url>2021/02/23/%E5%AE%89%E8%A3%85Redis%EF%BC%8CMysql/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-Ubuntu18-01安装redis和Mysql">Linux Ubuntu18.01安装redis和Mysql</h3><h4 id="1-安装redis">1.安装redis</h4><p>​</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure><h4 id="2-启动redis">2.启动redis</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><h4 id="3-让其他电脑可以访问">3.让其他电脑可以访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S redis_server 显示包含此软件包的所有位置，</span><br></pre></td></tr></table></figure><p>有一个/etc/redis/redis.conf  文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/redis/redis.conf  <span class="comment">//打开</span></span><br></pre></td></tr></table></figure><p>关闭保护模式并将127.0.0.1换成0.0.0.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 ::1     换成 bind 0.0.0.0 ::1</span><br><span class="line">protected-mode yes     换成 protected-mode no</span><br></pre></td></tr></table></figure><p>保存退出重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart redis-server</span><br></pre></td></tr></table></figure><p>配置密码在vim 中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: /requirepass</span><br></pre></td></tr></table></figure><p>找到之后取消注释，然后将后面的密码换成自己的。然后再重启一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart redis-server</span><br></pre></td></tr></table></figure><h4 id="1-安装Mysql">1.安装Mysql</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br><span class="line">sudo systemctl status mysql  //安装完成后输入这个看看状态</span><br></pre></td></tr></table></figure><h4 id="2-然后可以根据阿里云的这个增加一下数据库安全">2.然后可以根据阿里云的这个增加一下数据库安全</h4><p><a href="https://yq.aliyun.com/articles/758177">https://yq.aliyun.com/articles/758177</a></p><h4 id="3-配置外网访问">3.配置外网访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/mysql</span><br><span class="line"></span><br><span class="line">//然后ls一下 我的有下面这些东西，配置文件在mysql.conf.d中</span><br><span class="line">//conf.d      debian-start  my.cnf.fallback  mysql.conf.d</span><br><span class="line">//debian.cnf  my.cnf        mysql.cnf</span><br><span class="line"></span><br><span class="line">cd mysql.conf.d</span><br><span class="line">vim mysqld.cnf</span><br><span class="line">     //将地址127.0.0.1 改成0.0.0.0</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Redis </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拦截器</title>
      <link href="2021/02/23/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>2021/02/23/%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot配置拦截器"><a href="#SpringBoot配置拦截器" class="headerlink" title="SpringBoot配置拦截器"></a>SpringBoot配置拦截器</h3><h4 id="1-实现一个拦截器"><a href="#1-实现一个拦截器" class="headerlink" title="1.实现一个拦截器"></a>1.实现一个拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实现HandlerInterceptor</span><br><span class="line">重写preHandle方法，postHandler，afterCompletion方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//这里就可以根据request判断token session等等。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进入拦截器啦！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了TestInterceptor的afterCompletion方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.将拦截器配置到SpringBoot程序中，在Spring中，使用XML的方式，而在Boot中只需要定义一个带有@Configuration的配置类即可，需要实现WebMvcConfigure接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testMvcConfigure</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        InterceptorRegistration registration = registry.addInterceptor(<span class="keyword">new</span> testInterceptor());</span><br><span class="line">        registration.addPathPatterns(<span class="string">&quot;/**&quot;</span>);                      <span class="comment">//所有路径都被拦截</span></span><br><span class="line">        registration.excludePathPatterns(                         <span class="comment">//添加不拦截路径</span></span><br><span class="line">                <span class="string">&quot;/vip/wang&quot;</span>          </span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer38</title>
      <link href="2021/02/23/%E5%89%91%E6%8C%87offer38/"/>
      <url>2021/02/23/%E5%89%91%E6%8C%87offer38/</url>
      
        <content type="html"><![CDATA[<p>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>一开始的做法，回溯法模拟了一遍全排列；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; tempResult;<span class="comment">//因为字符串中可能有重复的元素，所以用了它去重</span></span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;used.push_back(<span class="literal">false</span>);&#125;</span><br><span class="line">        huiSu(tempResult,s,temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:tempResult)&#123;</span><br><span class="line">            result.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">huiSu</span><span class="params">(<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; result,<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp; temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.length()==s.length())&#123;</span><br><span class="line">            result.insert(temp);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[j])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;     </span><br><span class="line">            temp.push_back(s[j]);</span><br><span class="line">            used[j]=<span class="literal">true</span>;</span><br><span class="line">            huiSu(result,s,temp);</span><br><span class="line">            used[j]=<span class="literal">false</span>;</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于有重复元素的情况，我使用了set集合先把所有的结果加进去，然后再返回到vector中</p><p>还可以先将字符串排序，排序后相同的元素在一起，然后把他们看成一个即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span>&amp; temp,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size()==s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;s[i<span class="number">-1</span>]==s[i]&amp;&amp;!used[i<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                temp.push_back(s[i]);</span><br><span class="line">                used[i]=<span class="literal">true</span>;</span><br><span class="line">                backtrack(s,temp,used);</span><br><span class="line">                used[i]=<span class="literal">false</span>;</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;used(s.size());</span><br><span class="line">        backtrack(s,temp,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进行通过字符交换来实现全排列,然后使用unordered_set去重（这个去重与上面的作用完全不一样），如果某个已经交换过了，就不用在交换了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        dfs(s, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt;= s.size()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; used;  <span class="comment">//局部set去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = depth; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used.find(s[i]) != used.end())   <span class="keyword">continue</span>;   <span class="comment">//去重</span></span><br><span class="line">            used.insert(s[i]);</span><br><span class="line">            swap(s[depth],s[i]);</span><br><span class="line">            dfs(s, res, depth+<span class="number">1</span>);</span><br><span class="line">            swap(s[depth],s[i]);        <span class="comment">//回溯撤销操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：zrita</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/chui-su-z-by-zrita-gvc0/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda</title>
      <link href="2021/02/22/Lambda/"/>
      <url>2021/02/22/Lambda/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="2021/02/22/maven/"/>
      <url>2021/02/22/maven/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单元测试</title>
      <link href="2021/02/22/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>2021/02/22/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="2021/02/22/%E9%9B%86%E5%90%88/"/>
      <url>2021/02/22/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>异常错误</title>
      <link href="2021/02/22/%E5%BC%82%E5%B8%B8/"/>
      <url>2021/02/22/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h4 id="1-异常和错误都是类，基类Throwable-只实现了序列化接口。"><a href="#1-异常和错误都是类，基类Throwable-只实现了序列化接口。" class="headerlink" title="1.异常和错误都是类，基类Throwable 只实现了序列化接口。"></a>1.异常和错误都是类，基类Throwable 只实现了序列化接口。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Throwable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.printStackTrace()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    printStackTrace(System.err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">(PrintStream s)</span> </span>&#123;</span><br><span class="line">    printStackTrace(<span class="keyword">new</span> WrappedPrintStream(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">(PrintStreamOrWriter s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Guard against malicious overrides of Throwable.equals by</span></span><br><span class="line">    <span class="comment">// using a Set with identity equality semantics.</span></span><br><span class="line">    Set&lt;Throwable&gt; dejaVu = Collections.newSetFromMap(<span class="keyword">new</span> IdentityHashMap&lt;&gt;());</span><br><span class="line">    dejaVu.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (s.lock()) &#123;</span><br><span class="line">        <span class="comment">// Print our stack trace</span></span><br><span class="line">        s.println(<span class="keyword">this</span>);</span><br><span class="line">        StackTraceElement[] trace = getOurStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement traceElement : trace)</span><br><span class="line">            s.println(<span class="string">&quot;\tat &quot;</span> + traceElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print suppressed exceptions, if any</span></span><br><span class="line">        <span class="keyword">for</span> (Throwable se : getSuppressed())</span><br><span class="line">            se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, <span class="string">&quot;\t&quot;</span>, dejaVu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print cause, if any</span></span><br><span class="line">        Throwable ourCause = getCause();</span><br><span class="line">        <span class="keyword">if</span> (ourCause != <span class="keyword">null</span>)</span><br><span class="line">            ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, <span class="string">&quot;&quot;</span>, dejaVu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-捕获异常-都很熟悉"><a href="#3-捕获异常-都很熟悉" class="headerlink" title="3.捕获异常  (都很熟悉)"></a>3.捕获异常  (都很熟悉)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e1)&#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e2)&#123;</span><br><span class="line">e2.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-抛出异常"><a href="#4-抛出异常" class="headerlink" title="4.抛出异常"></a>4.抛出异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用throw + 异常对象</span></span><br><span class="line">Exception exception2=<span class="keyword">new</span> Exception();</span><br><span class="line"><span class="keyword">throw</span> exception2;</span><br><span class="line"></span><br><span class="line">或者<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br></pre></td></tr></table></figure><h4 id="5-Java异常体系"><a href="#5-Java异常体系" class="headerlink" title="5.Java异常体系"></a>5.Java异常体系</h4><p>Java标准库定义的常用异常包括：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure><h4 id="6-assert关键字"><a href="#6-assert关键字" class="headerlink" title="6.assert关键字"></a>6.assert关键字</h4><p>assert用来开发的时候使用，如果断言失败会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x&gt;<span class="number">0</span>; </span><br><span class="line"><span class="keyword">assert</span> x&gt;=<span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure><p>JVM默认关闭断言，开启断言需要编译时额外参数，实际上一般不用断言，都是使用JUnit。</p><h4 id="7-使用Logger日志系统代替System-out-println"><a href="#7-使用Logger日志系统代替System-out-println" class="headerlink" title="7.使用Logger日志系统代替System.out.println()"></a>7.使用Logger日志系统代替System.out.println()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = Logger.getGlobal();</span><br><span class="line">logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br></pre></td></tr></table></figure><p>logger一共有七个等级</p><ul><li><p>SEVERE</p></li><li><p>WARNING</p></li><li><p>INFO</p></li><li><p>CONFIG</p></li><li><p>FINE</p></li><li><p>FINER</p></li><li><p>FINEST</p><p>Config和下面的都不会打印出来。</p></li></ul><p>实际上一般也不用，也需要额外的参数。</p><h4 id="8-日志库Commons-Logging"><a href="#8-日志库Commons-Logging" class="headerlink" title="8.日志库Commons Logging"></a>8.日志库Commons Logging</h4><p>Commons Logging定义了6个日志级别：</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul><p>使用的话Log log = LogFactory.getLog(Class名);</p><h4 id="9-广泛使用的Log4j日志系统，xml配置麻烦，搭配SpringBoot应该会简单吧"><a href="#9-广泛使用的Log4j日志系统，xml配置麻烦，搭配SpringBoot应该会简单吧" class="headerlink" title="9.广泛使用的Log4j日志系统，xml配置麻烦，搭配SpringBoot应该会简单吧"></a>9.广泛使用的Log4j日志系统，xml配置麻烦，搭配SpringBoot应该会简单吧</h4><h4 id="10-和89对应的分别是SLF4J和Logback"><a href="#10-和89对应的分别是SLF4J和Logback" class="headerlink" title="10.和89对应的分别是SLF4J和Logback"></a>10.和89对应的分别是SLF4J和Logback</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuffer和StringBuilder</title>
      <link href="2021/02/21/StringBuffer/"/>
      <url>2021/02/21/StringBuffer/</url>
      
        <content type="html"><![CDATA[<p><img src="Y:\个人博客\hexo\source\photoes\StringBuffer.png"></p><p><img src="Y:\个人博客\hexo\source\photoes\StringBuilder.png" alt="StringBuilder"></p><p>首先两者继承的类，实现的接口都是一模一样，所提供的接口也是完全相同，不同的是StringBuffer是线程安全的，StringBuilder是不安全的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="2021/02/21/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>2021/02/21/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1376414781669409">https://www.liaoxuefeng.com/wiki/1252599548343744/1376414781669409</a></p><p>嵌套类分为三种内部类 ,匿名类，静态内部类</p><p>InnerClass和匿名类本质上相同，都需要依靠外部类才能实现，静态内部类不需要依赖外部类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="2021/02/21/%E5%A4%9A%E6%80%81/"/>
      <url>2021/02/21/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>多态：对于某个类型的方法调用，实际调用的方法取决于运行时实际类型的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">p.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class Person&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Class Teacher extends Person&#123; </span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Teacher&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">Person p1=<span class="keyword">new</span> Person();</span><br><span class="line">Person p2=<span class="keyword">new</span> Teacher();</span><br><span class="line">run(p1);</span><br><span class="line">    run(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码分别会打印各自的run  ， 因为两者的实际类型不同，通过声明类型传值</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举类</title>
      <link href="2021/02/21/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>2021/02/21/%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>我们可以使用这种方式来实现枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weekday</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Tu=<span class="number">2</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以实现，但是在使用的时候会出现问题，编译器不能检测出不在类中的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> day=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(day==Weekday.MON)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们用enum来实现枚举类:(编译器会将他们编译成final class Weekday extends Enum{…})</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span></span>&#123;</span><br><span class="line">MON,Tue,Wed,Thur,Fri,Sat,Sun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与enum类似的还有record类 14后才有。</p><p>用enum实现单例模式</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块</title>
      <link href="2021/02/21/%E6%A8%A1%E5%9D%97/"/>
      <url>2021/02/21/%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>java模块</p><p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938">https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修饰符</title>
      <link href="2021/02/21/4%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>2021/02/21/4%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>private  只能自己访问，子类extends后也不能访问</p><p>protected  子类可以访问</p><p>默认的（无） 同一个包内</p><p>public 所有都可以访问</p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>final  该类不能被继承</p><p>sealed + permits 指定某些类继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="title">permits</span> <span class="title">a</span>,<span class="title">b</span>,<span class="title">c</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="interface接口的default方法"><a href="#interface接口的default方法" class="headerlink" title="interface接口的default方法"></a>interface接口的default方法</h4><p>因为接口没有字段，所以接口无法定义非抽象的函数，这时候需要default修饰符来实现default方法，可以给予实现。default方法的目的主要是因为如果想往接口中增加一个方法但是又会影响所有实现接口的类都要实现该新增的方法，使用default便可以不影响所有类。</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><h5 id="static-fields"><a href="#static-fields" class="headerlink" title="static  fields"></a>static  fields</h5><p>​    静态字段</p><p>​    对于接口来说是不能拥有fields的，但是如果你直接写 int a;是不会报错的，因为编译器自动将其转换为了static final int a;</p><h5 id="static-methods"><a href="#static-methods" class="headerlink" title="static methods"></a>static methods</h5><p>​    静态方法主要用于工具方法和辅助方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;...&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-ArrayList</title>
      <link href="2021/02/20/ArrayList/"/>
      <url>2021/02/20/ArrayList/</url>
      
        <content type="html"><![CDATA[<p>JDK8版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ArrayList  数组列表，分别实现了列表、随机访问、可克隆、序列化，继承了抽象列表,其关系如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20210220234227663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YWppYW9odWl4aWFuZw==,size_16,color_FFFFFF,t_70"></p><h4 id="1-几个参数"><a href="#1-几个参数" class="headerlink" title="1.几个参数"></a>1.几个参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h4 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2.主要方法"></a>2.主要方法</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>如果是ArrayList arrayList=new ArrayList(20);只初始化了一次，算没扩容吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>传入另一个集合，先将collection转为数组，然后copy到elementData中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// defend against c.toArray (incorrectly) not returning Object[]</span></span><br><span class="line">        <span class="comment">// (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-trimToSize-修剪大小到size"><a href="#3-trimToSize-修剪大小到size" class="headerlink" title="3.trimToSize()修剪大小到size"></a>3.trimToSize()修剪大小到size</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-增加容量（这个是给用户调用的，ArrayList内部没有调用）"><a href="#4-增加容量（这个是给用户调用的，ArrayList内部没有调用）" class="headerlink" title="4. 增加容量（这个是给用户调用的，ArrayList内部没有调用）"></a>4. 增加容量（这个是给用户调用的，ArrayList内部没有调用）</h4><p>如果要大批量插入数据，那么调用该函数主动增加容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">用到了grow() ,newCapacity(minCapacity) ,hugeCapacity(<span class="keyword">int</span> minCapacity)方法</span><br></pre></td></tr></table></figure><h4 id="5-得到O地址"><a href="#5-得到O地址" class="headerlink" title="5.得到O地址"></a>5.得到O地址</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfRange</span><span class="params">(Object o, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-扩容"><a href="#6-扩容" class="headerlink" title="6.扩容"></a>6.扩容</h4><p>​    JDK11去掉了</p><p>add方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This helper method split out from add(E) to keep method</span></span><br><span class="line"><span class="comment"> * bytecode size under 35 (the -XX:MaxInlineSize default value),</span></span><br><span class="line"><span class="comment"> * which helps when add(E) is called in a C1-compiled loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐阅读<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90?id=_1-arraylist-%e7%ae%80%e4%bb%8b">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90?id=_1-arraylist-%e7%ae%80%e4%bb%8b</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-LinkedList</title>
      <link href="2021/02/20/LinkedList/"/>
      <url>2021/02/20/LinkedList/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210220234227665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YWppYW9odWl4aWFuZw==,size_16,color_FFFFFF,t_70"></p><p>比ArrayList多实现了Queue和Deque 即实现了双向队列，ArrayList直接继承AbstractList，LinkedList继承于AbstractSequentialList,即顺序访问，AbstractList适合随机访问。</p><p>LinkedList底层就是链表实现，有内部类Node ，然后又first节点、last节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>Node类，item内容，前指针和后指针，双向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是对链表的一些操作以及toArray等等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-List</title>
      <link href="2021/02/20/List/"/>
      <url>2021/02/20/List/</url>
      
        <content type="html"><![CDATA[<p>List接口实现了Collection接口，主要有以下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否包含</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除掉不在c中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> ListIterator&lt;E&gt; li = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">        li.set(operator.apply(li.next()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是比Collection多的方法</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// List Iterators</span></span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// View</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重写了Collection的可分割迭代器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractList.RandomAccessSpliterator&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的暂时还没看</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableCollections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(e1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(e1, e2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,</span><br><span class="line">                                            e6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,</span><br><span class="line">                                            e6, e7);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,</span><br><span class="line">                                            e6, e7, e8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,</span><br><span class="line">                                            e6, e7, e8, e9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,</span><br><span class="line">                                            e6, e7, e8, e9, e10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;varargs&quot;)</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E... elements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (elements.length) &#123; <span class="comment">// implicit null check of elements</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ImmutableCollections.emptyList();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(elements[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(elements[<span class="number">0</span>], elements[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-transient</title>
      <link href="2021/02/20/transient/"/>
      <url>2021/02/20/transient/</url>
      
        <content type="html"><![CDATA[<p>参考资料<a href="https://www.cnblogs.com/lanxuezaipiao/p/3369962.html">https://www.cnblogs.com/lanxuezaipiao/p/3369962.html</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698">https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698</a></p><p>在java中，只要实现了java.io.Serializable接口，该类就可以序列化。</p><p>transient关键字用来标明不想序列化的某个属性，例如在ArrayList源码中，elementData就不想被序列化，则使用了transient。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Collection</title>
      <link href="2021/02/20/Collection/"/>
      <url>2021/02/20/Collection/</url>
      
        <content type="html"><![CDATA[<h3 id="interface-Collection"><a href="#interface-Collection" class="headerlink" title="interface Collection"></a>interface Collection<T></h3><p>集合层次结构中的根接口。集合代表一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。有些是有序的，而另一些则是无序的。JDK不提供 此接口的任何直接实现：它提供了更多特定子接口的实现，例如{@code Set}和{@code List}。该接口通常用于传递集合并在需要最大通用性的地方操纵它们。</p><p>Bags或multisets（可能包含重复元素的无序集合）应直接实现此接口。</p><p>所有通用的{@code Collection}实现类（通常通过其子接口之一间接实现{@code Collection}）应提供两个“标准”构造函数：void（无自变量）构造函数，该构造函数创建一个空的集合，以及一个带有单个实参类型为{@code Collection}的构造函数，该构造函数创建一个新集合，其元素与实参相同。实际上，后一个构造函数允许用户复制任何集合，从而产生所需实现类型的等效集合。没有强制执行此约定的方法（因为接口不能包含构造函数），但是Java平台库中的所有通用{@code Collection} 实现都可以遵循。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@see</span>     Set</span><br><span class="line"><span class="meta">@see</span>     List</span><br><span class="line"><span class="meta">@see</span>     SortedSet</span><br><span class="line"><span class="meta">@see</span>     HashSet</span><br><span class="line"><span class="meta">@see</span>     TreeSet</span><br><span class="line"><span class="meta">@see</span>     ArrayList</span><br><span class="line"><span class="meta">@see</span>     LinkedList</span><br><span class="line"><span class="meta">@see</span>     Vector</span><br><span class="line"><span class="meta">@see</span>     AbstractCollection</span><br><span class="line"> <span class="comment">//   以上这些实现了Collection接口</span></span><br></pre></td></tr></table></figure><h4 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h4><p>1.size()返回集合大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of elements in this collection.  If this collection</span></span><br><span class="line"><span class="comment"> * contains more than &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125; elements, returns</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of elements in this collection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>2.isEmpty() </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this collection contains no elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this collection contains no elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>3.contains(Object o)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this collection contains the specified element.</span></span><br><span class="line"><span class="comment"> * More formally, returns &#123;<span class="doctag">@code</span> true&#125; if and only if this collection</span></span><br><span class="line"><span class="comment"> * contains at least one element &#123;<span class="doctag">@code</span> e&#125; such that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Objects.equals(o, e)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element whose presence in this collection is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this collection contains the specified</span></span><br><span class="line"><span class="comment"> *         element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the type of the specified element</span></span><br><span class="line"><span class="comment"> *         is incompatible with this collection</span></span><br><span class="line"><span class="comment"> *         (&lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null and this</span></span><br><span class="line"><span class="comment"> *         collection does not permit null elements</span></span><br><span class="line"><span class="comment"> *         (&lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.iterator()返回一个迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an iterator over the elements in this collection.  There are no</span></span><br><span class="line"><span class="comment"> * guarantees concerning the order in which the elements are returned</span></span><br><span class="line"><span class="comment"> * (unless this collection is an instance of some class that provides a</span></span><br><span class="line"><span class="comment"> * guarantee).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Iterator&#125; over the elements in this collection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>5.toArray()转换成数组 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) &#123;</span><br><span class="line">    <span class="keyword">return</span> toArray(generator.apply(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.add()添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>7.去除元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>8.containAll()返回是否包含该集合的所有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this collection contains all of the elements</span></span><br><span class="line"><span class="comment"> * in the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c collection to be checked for containment in this collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this collection contains all of the elements</span></span><br><span class="line"><span class="comment"> *         in the specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the types of one or more elements</span></span><br><span class="line"><span class="comment"> *         in the specified collection are incompatible with this</span></span><br><span class="line"><span class="comment"> *         collection</span></span><br><span class="line"><span class="comment"> *         (&lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection contains one</span></span><br><span class="line"><span class="comment"> *         or more null elements and this collection does not permit null</span></span><br><span class="line"><span class="comment"> *         elements</span></span><br><span class="line"><span class="comment"> *         (&lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),</span></span><br><span class="line"><span class="comment"> *         or if the specified collection is null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>    #contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br></pre></td></tr></table></figure><p>9.addALL()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br></pre></td></tr></table></figure><p>10.removeAll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br></pre></td></tr></table></figure><p>11.removesif()去除所有符合条件的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">    <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">            each.remove();</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12.retainAll()去除所有不在c中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this collection (optional operation).</span></span><br><span class="line"><span class="comment"> * The collection will be empty after this method returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException if the &#123;<span class="doctag">@code</span> clear&#125; operation</span></span><br><span class="line"><span class="comment"> *         is not supported by this collection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>13.clear()清楚所有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>14.equals和hashcode</p><p>15.可分割迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>16.Stream  获得流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是串行流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure><p>以上的流程转换为 Java 代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.runoob.com/java/java8-streams.html">https://www.runoob.com/java/java8-streams.html</a></p><p>17.获得并行流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并行流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Iterable</title>
      <link href="2021/02/20/Iterable/"/>
      <url>2021/02/20/Iterable/</url>
      
        <content type="html"><![CDATA[<h3 id="interface-Iterable"><a href="#interface-Iterable" class="headerlink" title="interface Iterable"></a>interface Iterable<T></h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Implementing <span class="keyword">this</span> <span class="class"><span class="keyword">interface</span> <span class="title">allows</span> <span class="title">an</span> <span class="title">object</span> <span class="title">to</span> <span class="title">be</span> <span class="title">the</span> <span class="title">target</span> <span class="title">of</span> <span class="title">the</span> <span class="title">enhanced</span></span></span><br><span class="line"><span class="class">* </span>&#123;<span class="meta">@code</span> <span class="keyword">for</span>&#125; statement (sometimes called the <span class="string">&quot;for-each loop&quot;</span> statement).</span><br><span class="line">*</span><br><span class="line">* <span class="meta">@param</span> &lt;T&gt; the type of elements returned by the iterator</span><br><span class="line">*</span><br><span class="line">* <span class="meta">@since</span> <span class="number">1.5</span></span><br><span class="line">* <span class="meta">@jls</span> <span class="number">14.14</span><span class="number">.2</span> The enhanced &#123;<span class="meta">@code</span> <span class="keyword">for</span>&#125; statement</span><br></pre></td></tr></table></figure><p>实现此接口允许一个对象成为增强for语句的目标,就是下面这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a.forEach(</span><br><span class="line">        <span class="keyword">new</span> Consumer&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an iterator over elements of type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an Iterator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="forEach-函数，重点"><a href="#forEach-函数，重点" class="headerlink" title="forEach()函数，重点"></a>forEach()函数，重点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs the given action for each element of the &#123;<span class="doctag">@code</span> Iterable&#125;</span></span><br><span class="line"><span class="comment"> * until all elements have been processed or the action throws an</span></span><br><span class="line"><span class="comment"> * exception.  Actions are performed in the order of iteration, if that</span></span><br><span class="line"><span class="comment"> * order is specified.  Exceptions thrown by the action are relayed to the</span></span><br><span class="line"><span class="comment"> * caller.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The behavior of this method is unspecified if the action performs</span></span><br><span class="line"><span class="comment"> * side-effects that modify the underlying source of elements, unless an</span></span><br><span class="line"><span class="comment"> * overriding class has specified a concurrent modification policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation behaves as if:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     for (T t : this)</span></span><br><span class="line"><span class="comment"> *         action.accept(t);</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action The action to be performed for each element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified action is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的话可以通过匿名类、lamda表达式、现有方法的名称。</p><h4 id="Spliterator-spliterator"><a href="#Spliterator-spliterator" class="headerlink" title="Spliterator spliterator()"></a>Spliterator<T> spliterator()</h4><p>Spliterator是一个可分割迭代器(splitable iterator)，可以和iterator顺序遍历迭代器一起看。jdk1.8发布后，对于并行处理的能力大大增强，Spliterator就是为了并行遍历元素而设计的一个迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@link</span> Spliterator&#125; over the elements described by this</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Iterable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment"> * The default implementation creates an</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;&lt;a href=&quot;../util/Spliterator.html#binding&quot;&gt;early-binding&lt;/a&gt;&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * spliterator from the iterable&#x27;s &#123;<span class="doctag">@code</span> Iterator&#125;.  The spliterator</span></span><br><span class="line"><span class="comment"> * inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterable&#x27;s iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implNote</span></span></span><br><span class="line"><span class="comment"> * The default implementation should usually be overridden.  The</span></span><br><span class="line"><span class="comment"> * spliterator returned by the default implementation has poor splitting</span></span><br><span class="line"><span class="comment"> * capabilities, is unsized, and does not report any spliterator</span></span><br><span class="line"><span class="comment"> * characteristics. Implementing classes can nearly always provide a</span></span><br><span class="line"><span class="comment"> * better implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Spliterator&#125; over the elements described by this</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Iterable&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Reference</title>
      <link href="2021/02/20/%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
      <url>2021/02/20/%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>Java四种引用：强引用、软引用、弱引用、虚引用</p><p>强引用：new一个对象就是强引用，可以通过赋null来取消引用，被强引用的对象永远都不会被回收即使Out of memory。</p><p>软引用：SoftReference，被软引用的对象将会在内存不够用时被GC回收</p><p>弱引用：WeakReference，将会在下一轮GC被回收，如果对象有finalize()，将会先执行finalize()，然后再回收，这时可能会延后一个GC</p><p>虚引用：用来标记对象是否要回收，如果一个对象只有虚引用，那么将会回收</p><p>参考：<a href="https://zhanghaoxin.blog.csdn.net/article/details/80991802">https://zhanghaoxin.blog.csdn.net/article/details/80991802</a></p><p>​            <a href="https://www.cnblogs.com/skywang12345/p/3154474.html">https://www.cnblogs.com/skywang12345/p/3154474.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kinect获取 骨骼图骨骼三维坐标</title>
      <link href="2021/02/19/Kinect%E8%8E%B7%E5%8F%96-%E9%AA%A8%E9%AA%BC%E5%9B%BE%E9%AA%A8%E9%AA%BC%E4%B8%89%E7%BB%B4%E5%9D%90%E6%A0%87/"/>
      <url>2021/02/19/Kinect%E8%8E%B7%E5%8F%96-%E9%AA%A8%E9%AA%BC%E5%9B%BE%E9%AA%A8%E9%AA%BC%E4%B8%89%E7%BB%B4%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Kinect获取-骨骼图骨骼三维坐标"><a href="#Kinect获取-骨骼图骨骼三维坐标" class="headerlink" title="Kinect获取 骨骼图骨骼三维坐标"></a>Kinect获取 骨骼图骨骼三维坐标</h2><p>该项目需要我们利用KinectV2 获取骨骼图并得到头部坐标，每一秒取一帧，一共五分钟，将坐标输出。</p><p>KinectV2 可以获得色彩图、深度图、骨骼图等等，其实一开始我也不知道该从哪里下手，但对骨骼图的代码进行了一下分析找到了突破点。</p><h4 id="对KinectV2大体了解："><a href="#对KinectV2大体了解：" class="headerlink" title="对KinectV2大体了解："></a>对KinectV2大体了解：</h4><p>Kinect一共有三个坐标空间，分别是相机空间、深度空间、色彩空间，相机空间对应骨骼图等，深度空间对应深度图，色彩空间对应色彩图，并且KInectSDK中有CoordinateMapper类来实现深度空间到相机空间和深度空间到色彩空间的转换。<br>具体查看官方文档：<a href="https://docs.microsoft.com/en-us/previous-versions/windows/kinect/dn785530(v=ieb.10)">https://docs.microsoft.com/en-us/previous-versions/windows/kinect/dn785530(v=ieb.10)</a></p><p>重点需要关心获取的帧的数据如何存储的，对于骨骼图，SDK中有两个重要的类分别是IBody 和 Joint 分别代表人和骨骼点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IBody : <span class="keyword">public</span> IUnknown</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">GetJoints</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="comment">/* [annotation] */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">          _Pre_equal_to_(JointType_Count)  UINT capacity,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="comment">/* [annotation][size_is][out] */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">          _Out_writes_all_(capacity)  Joint *joints)</span> </span>= <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">virtual</span> <span class="comment">/* [propget] */</span> <span class="function">HRESULT STDMETHODCALLTYPE <span class="title">get_IsTracked</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="comment">/* [annotation][out][retval] */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">          _Out_  BOOLEAN *tracked)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>分别利用GetJoints函数和get_IsTracked函数可以获得Joints和判断是否被记录到了。</p><p>对于Joints</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Joint_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Joint_</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Joint</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    JointType JointType;</span><br><span class="line">    CameraSpacePoint Position;</span><br><span class="line">    TrackingState TrackingState;</span><br><span class="line">    &#125; Joint;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _Joint_</span></span></span><br></pre></td></tr></table></figure><p>一个struct  里面有Joint类型、相机空间位置、追踪状态（是否被观测到），接着往里看CameSpacePoint</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CameraSpacePoint_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CameraSpacePoint_</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CameraSpacePoint</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">float</span> X;</span><br><span class="line">    <span class="keyword">float</span> Y;</span><br><span class="line">    <span class="keyword">float</span> Z;</span><br><span class="line">    &#125; CameraSpacePoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _CameraSpacePoint_</span></span></span><br></pre></td></tr></table></figure><p>到这里就很清楚了，直接就可以得到相机空间地址了。（本来我以为需要先获得深度图地址，然后自己进行坐标计算的。。。）</p><p>然后SDK还定义了一下常量和其他类，在这里贴一下以防看代码的时候不懂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">JointType</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        JointType_SpineBase= <span class="number">0</span>,</span><br><span class="line">        JointType_SpineMid= <span class="number">1</span>,</span><br><span class="line">        JointType_Neck= <span class="number">2</span>,</span><br><span class="line">        JointType_Head= <span class="number">3</span>,</span><br><span class="line">        JointType_ShoulderLeft= <span class="number">4</span>,</span><br><span class="line">        JointType_ElbowLeft= <span class="number">5</span>,</span><br><span class="line">        JointType_WristLeft= <span class="number">6</span>,</span><br><span class="line">        JointType_HandLeft= <span class="number">7</span>,</span><br><span class="line">        JointType_ShoulderRight= <span class="number">8</span>,</span><br><span class="line">        JointType_ElbowRight= <span class="number">9</span>,</span><br><span class="line">        JointType_WristRight= <span class="number">10</span>,</span><br><span class="line">        JointType_HandRight= <span class="number">11</span>,</span><br><span class="line">        JointType_HipLeft= <span class="number">12</span>,</span><br><span class="line">        JointType_KneeLeft= <span class="number">13</span>,</span><br><span class="line">        JointType_AnkleLeft= <span class="number">14</span>,</span><br><span class="line">        JointType_FootLeft= <span class="number">15</span>,</span><br><span class="line">        JointType_HipRight= <span class="number">16</span>,</span><br><span class="line">        JointType_KneeRight= <span class="number">17</span>,</span><br><span class="line">        JointType_AnkleRight= <span class="number">18</span>,</span><br><span class="line">        JointType_FootRight= <span class="number">19</span>,</span><br><span class="line">        JointType_SpineShoulder= <span class="number">20</span>,</span><br><span class="line">        JointType_HandTipLeft= <span class="number">21</span>,</span><br><span class="line">        JointType_ThumbLeft= <span class="number">22</span>,</span><br><span class="line">        JointType_HandTipRight= <span class="number">23</span>,</span><br><span class="line">        JointType_ThumbRight= <span class="number">24</span>,</span><br><span class="line">        JointType_Count= ( JointType_ThumbRight + <span class="number">1</span> ) </span><br><span class="line">    &#125; ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _JointType_</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TrackingState_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TrackingState_</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">TrackingState</span> <span class="title">TrackingState</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">TrackingState</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        TrackingState_NotTracked= <span class="number">0</span>,</span><br><span class="line">        TrackingState_Inferred= <span class="number">1</span>,</span><br><span class="line">        TrackingState_Tracked= <span class="number">2</span></span><br><span class="line">    &#125; ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _TrackingState_</span></span></span><br><span class="line"></span><br><span class="line"> IBodyFrame : <span class="keyword">public</span> IUnknown</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">GetAndRefreshBodyData</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">            UINT capacity,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">/* [annotation][size_is][out][in] */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            _Inout_updates_all_(capacity)  IBody **bodies)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">virtual</span> <span class="comment">/* [propget] */</span> <span class="function">HRESULT STDMETHODCALLTYPE <span class="title">get_FloorClipPlane</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">/* [annotation][out][retval] */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            _Out_  Vector4 *floorClipPlane)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">virtual</span> <span class="comment">/* [propget] */</span> <span class="function">HRESULT STDMETHODCALLTYPE <span class="title">get_RelativeTime</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">/* [annotation][out][retval] */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            _Out_  TIMESPAN *relativeTime)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">virtual</span> <span class="comment">/* [propget] */</span> <span class="function">HRESULT STDMETHODCALLTYPE <span class="title">get_BodyFrameSource</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">/* [annotation][out][retval] */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            _COM_Outptr_  IBodyFrameSource **bodyFrameSource)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>下面是项目代码的详细步骤：</p><p>第一步需要安装Kinect 的SDK，然后再Visual Studio进行项目配置，具体可以参考一下文章：</p><p><a href="https://blog.csdn.net/lizhiguo18/article/details/51037672">https://blog.csdn.net/lizhiguo18/article/details/51037672</a></p><p><a href="https://blog.csdn.net/weixin_43850620/article/details/103874847">https://blog.csdn.net/weixin_43850620/article/details/103874847</a></p><p>对项目配置好后就可以写代码啦。</p><p>1.这一步应该是获取Kinect，然后打开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IKinectSensor   * mySensor = <span class="literal">nullptr</span>;</span><br><span class="line">GetDefaultKinectSensor(&amp;mySensor);</span><br><span class="line">mySensor-&gt;Open();</span><br></pre></td></tr></table></figure><p>2.准备读取ColorFrame</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   IColorFrameSource   * myColorSource = <span class="literal">nullptr</span>;</span><br><span class="line">mySensor-&gt;get_ColorFrameSource(&amp;myColorSource);</span><br><span class="line">IColorFrameReader   * myColorReader = <span class="literal">nullptr</span>;</span><br><span class="line">myColorSource-&gt;OpenReader(&amp;myColorReader);</span><br><span class="line"><span class="keyword">int</span> colorHeight = <span class="number">0</span>, colorWidth = <span class="number">0</span>;</span><br><span class="line">IFrameDescription   * myDescription = <span class="literal">nullptr</span>;</span><br><span class="line">myColorSource-&gt;get_FrameDescription(&amp;myDescription);</span><br><span class="line">myDescription-&gt;get_Height(&amp;colorHeight);</span><br><span class="line">myDescription-&gt;get_Width(&amp;colorWidth);</span><br><span class="line">IColorFrame * myColorFrame = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">Mat <span class="title">original</span><span class="params">(colorHeight, colorWidth, CV_8UC4)</span></span>;</span><br></pre></td></tr></table></figure><p>3.准备读取BodyFrame</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   IBodyFrameSource    * myBodySource = <span class="literal">nullptr</span>;</span><br><span class="line">mySensor-&gt;get_BodyFrameSource(&amp;myBodySource);</span><br><span class="line">IBodyFrameReader    * myBodyReader = <span class="literal">nullptr</span>;</span><br><span class="line">myBodySource-&gt;OpenReader(&amp;myBodyReader);</span><br><span class="line"><span class="keyword">int</span> myBodyCount = <span class="number">0</span>;</span><br><span class="line">myBodySource-&gt;get_BodyCount(&amp;myBodyCount);</span><br><span class="line">IBodyFrame  * myBodyFrame = <span class="literal">nullptr</span>;</span><br><span class="line">ICoordinateMapper   * myMapper = <span class="literal">nullptr</span>;</span><br><span class="line">mySensor-&gt;get_CoordinateMapper(&amp;myMapper);</span><br></pre></td></tr></table></figure><p>4.每30帧获取一帧然后输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> fps = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (myColorReader-&gt;AcquireLatestFrame(&amp;myColorFrame) != S_OK);</span><br><span class="line">myColorFrame-&gt;CopyConvertedFrameDataToArray(colorHeight * colorWidth * <span class="number">4</span>, original.data, ColorImageFormat_Bgra);</span><br><span class="line">Mat copy = original.clone();        <span class="comment">//读取彩色图像并输出到矩阵</span></span><br><span class="line"><span class="keyword">while</span> (myBodyReader-&gt;AcquireLatestFrame(&amp;myBodyFrame) != S_OK); <span class="comment">//读取身体图像</span></span><br><span class="line">IBody   **  myBodyArr = <span class="keyword">new</span> IBody *[myBodyCount];       <span class="comment">//为存身体数据的数组做准备</span></span><br><span class="line"><span class="keyword">if</span> (fps != <span class="number">0</span>) &#123;</span><br><span class="line">fps++;</span><br><span class="line">fps = fps % <span class="number">30</span>;</span><br><span class="line"><span class="keyword">delete</span>[]myBodyArr;</span><br><span class="line">myBodyFrame-&gt;Release();</span><br><span class="line">myColorFrame-&gt;Release();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">fps++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myBodyCount; i++)</span><br><span class="line">myBodyArr[i] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (myBodyFrame-&gt;GetAndRefreshBodyData(myBodyCount, myBodyArr) == S_OK)     <span class="comment">//把身体数据输入数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myBodyCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">BOOLEAN     result = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (myBodyArr[i]-&gt;get_IsTracked(&amp;result) == S_OK &amp;&amp; result) <span class="comment">//先判断是否侦测到</span></span><br><span class="line">&#123;</span><br><span class="line">Joint   myJointArr[JointType_Count];</span><br><span class="line"><span class="keyword">if</span> (myBodyArr[i]-&gt;GetJoints(JointType_Count, myJointArr) == S_OK)  </span><br><span class="line">&#123;</span><br><span class="line">draw(copy, myJointArr[JointType_Head], myJointArr[JointType_Neck], myMapper);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]myBodyArr;</span><br><span class="line">myBodyFrame-&gt;Release();</span><br><span class="line">myColorFrame-&gt;Release();</span><br><span class="line"><span class="keyword">if</span> (countFrame == <span class="number">330</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.关闭Kinect并退出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myMapper-&gt;Release();</span><br><span class="line">myDescription-&gt;Release();</span><br><span class="line">myColorReader-&gt;Release();</span><br><span class="line">myColorSource-&gt;Release();</span><br><span class="line">myBodyReader-&gt;Release();</span><br><span class="line">myBodySource-&gt;Release();</span><br><span class="line">mySensor-&gt;Close();</span><br><span class="line">mySensor-&gt;Release();</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>6.函数draw()</p><p>​    获取时间然后直接输出坐标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void    draw(Mat &amp; img, Joint &amp; r_1, Joint &amp; r_2, ICoordinateMapper * myMapper)</span><br><span class="line">&#123;</span><br><span class="line">countFrame++;</span><br><span class="line">if (r_1.TrackingState &#x3D;&#x3D; TrackingState_Tracked )</span><br><span class="line">&#123;</span><br><span class="line">now &#x3D; clock();</span><br><span class="line">ofstream fout(&quot;01.txt&quot;, ios::app);</span><br><span class="line">cout &lt;&lt; now;</span><br><span class="line">cout &lt;&lt; r_1.Position.X &lt;&lt; r_1.Position.Y &lt;&lt; r_1.Position.Z &lt;&lt; &#39;\t ,&#39;&lt;&lt;countFrame&lt;&lt;endl;</span><br><span class="line">fout &lt;&lt; r_1.Position.X&lt;&lt;&#39;,&#39; &lt;&lt; r_1.Position.Y &lt;&lt; &#39;,&#39; &lt;&lt; r_1.Position.Z &lt;&lt;&#39;,&#39;&lt;&lt;now&lt;&lt; endl;</span><br><span class="line">fout.close();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">now &#x3D; clock();</span><br><span class="line">ofstream fout(&quot;01.txt&quot;, ios::app);</span><br><span class="line">cout &lt;&lt; now;</span><br><span class="line">cout &lt;&lt; 0 &lt;&lt; 0 &lt;&lt;0 &lt;&lt; endl;</span><br><span class="line">fout &lt;&lt; 0 &lt;&lt; &#39;,&#39; &lt;&lt;0 &lt;&lt; &#39;,&#39; &lt;&lt; 0 &lt;&lt; &#39;,&#39; &lt;&lt; now&lt;&lt;endl;</span><br><span class="line">fout.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码如下："><a href="#完整代码如下：" class="headerlink" title="完整代码如下："></a>完整代码如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整代码</span></span><br><span class="line"><span class="comment">//其实本项目并没有用到opencv  我这是copy的别人的代码然后修改了一下。代码有很多和本项目无关的东西，等有时间删除精炼一下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\imgproc.hpp&gt;//opencv头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\calib3d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Kinect.h&gt;//Kinect头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>   <span class="keyword">namespace</span>   <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span>   <span class="keyword">namespace</span>   cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> countFrame = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">clock_t</span> pre, now;</span><br><span class="line"><span class="keyword">clock_t</span> begintime, endtime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">draw</span><span class="params">(Mat &amp; img, Joint &amp; r_1, Joint &amp; r_2, ICoordinateMapper * myMapper)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">begintime = clock();</span><br><span class="line">IKinectSensor   * mySensor = <span class="literal">nullptr</span>;</span><br><span class="line">GetDefaultKinectSensor(&amp;mySensor);</span><br><span class="line">mySensor-&gt;Open();</span><br><span class="line"></span><br><span class="line">IColorFrameSource   * myColorSource = <span class="literal">nullptr</span>;</span><br><span class="line">mySensor-&gt;get_ColorFrameSource(&amp;myColorSource);</span><br><span class="line"></span><br><span class="line">IColorFrameReader   * myColorReader = <span class="literal">nullptr</span>;</span><br><span class="line">myColorSource-&gt;OpenReader(&amp;myColorReader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> colorHeight = <span class="number">0</span>, colorWidth = <span class="number">0</span>;</span><br><span class="line">IFrameDescription   * myDescription = <span class="literal">nullptr</span>;</span><br><span class="line">myColorSource-&gt;get_FrameDescription(&amp;myDescription);</span><br><span class="line">myDescription-&gt;get_Height(&amp;colorHeight);</span><br><span class="line">myDescription-&gt;get_Width(&amp;colorWidth);</span><br><span class="line"></span><br><span class="line">IColorFrame * myColorFrame = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">Mat <span class="title">original</span><span class="params">(colorHeight, colorWidth, CV_8UC4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************以上为ColorFrame的读取前准备**************************</span></span><br><span class="line"></span><br><span class="line">IBodyFrameSource    * myBodySource = <span class="literal">nullptr</span>;</span><br><span class="line">mySensor-&gt;get_BodyFrameSource(&amp;myBodySource);</span><br><span class="line">IBodyFrameReader    * myBodyReader = <span class="literal">nullptr</span>;</span><br><span class="line">myBodySource-&gt;OpenReader(&amp;myBodyReader);</span><br><span class="line"><span class="keyword">int</span> myBodyCount = <span class="number">0</span>;</span><br><span class="line">myBodySource-&gt;get_BodyCount(&amp;myBodyCount);</span><br><span class="line">IBodyFrame  * myBodyFrame = <span class="literal">nullptr</span>;</span><br><span class="line">ICoordinateMapper   * myMapper = <span class="literal">nullptr</span>;</span><br><span class="line">mySensor-&gt;get_CoordinateMapper(&amp;myMapper);</span><br><span class="line"><span class="keyword">int</span> fps = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//**********************以上为BodyFrame以及Mapper的准备***********************</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (myColorReader-&gt;AcquireLatestFrame(&amp;myColorFrame) != S_OK);</span><br><span class="line">myColorFrame-&gt;CopyConvertedFrameDataToArray(colorHeight * colorWidth * <span class="number">4</span>, original.data, ColorImageFormat_Bgra);</span><br><span class="line">Mat copy = original.clone();        <span class="comment">//读取彩色图像并输出到矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (myBodyReader-&gt;AcquireLatestFrame(&amp;myBodyFrame) != S_OK); <span class="comment">//读取身体图像</span></span><br><span class="line">IBody   **  myBodyArr = <span class="keyword">new</span> IBody *[myBodyCount];       <span class="comment">//为存身体数据的数组做准备</span></span><br><span class="line"><span class="keyword">if</span> (fps != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; fps &lt;&lt; endl;</span></span><br><span class="line">fps++;</span><br><span class="line">fps = fps % <span class="number">30</span>;</span><br><span class="line"><span class="keyword">delete</span>[]myBodyArr;</span><br><span class="line">myBodyFrame-&gt;Release();</span><br><span class="line">myColorFrame-&gt;Release();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">fps++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myBodyCount; i++)</span><br><span class="line">myBodyArr[i] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (myBodyFrame-&gt;GetAndRefreshBodyData(myBodyCount, myBodyArr) == S_OK)     <span class="comment">//把身体数据输入数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myBodyCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">BOOLEAN     result = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (myBodyArr[i]-&gt;get_IsTracked(&amp;result) == S_OK &amp;&amp; result) <span class="comment">//先判断是否侦测到</span></span><br><span class="line">&#123;</span><br><span class="line">Joint   myJointArr[JointType_Count];</span><br><span class="line"><span class="keyword">if</span> (myBodyArr[i]-&gt;GetJoints(JointType_Count, myJointArr) == S_OK)   <span class="comment">//如果侦测到就把关节数据输入到数组并画图</span></span><br><span class="line">&#123;</span><br><span class="line">draw(copy, myJointArr[JointType_Head], myJointArr[JointType_Neck], myMapper);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]myBodyArr;</span><br><span class="line">myBodyFrame-&gt;Release();</span><br><span class="line">myColorFrame-&gt;Release();</span><br><span class="line"><span class="keyword">if</span> (countFrame == <span class="number">330</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myMapper-&gt;Release();</span><br><span class="line">myDescription-&gt;Release();</span><br><span class="line">myColorReader-&gt;Release();</span><br><span class="line">myColorSource-&gt;Release();</span><br><span class="line">myBodyReader-&gt;Release();</span><br><span class="line">myBodySource-&gt;Release();</span><br><span class="line">mySensor-&gt;Close();</span><br><span class="line">mySensor-&gt;Release();</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">draw</span><span class="params">(Mat &amp; img, Joint &amp; r_1, Joint &amp; r_2, ICoordinateMapper * myMapper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">countFrame++;</span><br><span class="line"><span class="keyword">if</span> (r_1.TrackingState == TrackingState_Tracked )</span><br><span class="line">&#123;</span><br><span class="line">now = clock();</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;01.txt&quot;</span>, ios::app)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; now;</span><br><span class="line">cout &lt;&lt; r_1.Position.X &lt;&lt; r_1.Position.Y &lt;&lt; r_1.Position.Z &lt;&lt; &#x27;\t ,&#x27;&lt;&lt;countFrame&lt;&lt;endl;</span><br><span class="line">fout &lt;&lt; r_1.Position.X&lt;&lt;<span class="string">&#x27;,&#x27;</span> &lt;&lt; r_1.Position.Y &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; r_1.Position.Z &lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;now&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fout.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">now = clock();</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;01.txt&quot;</span>, ios::app)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; now;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt;<span class="number">0</span> &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; now&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">fout.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Kinect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用</title>
      <link href="2021/02/19/huxo%E4%BD%BF%E7%94%A8/"/>
      <url>2021/02/19/huxo%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>使用Hexo+Github部署<br>参考官方文档：<a href="https://hexo.io/docs/">https://hexo.io/docs/</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli  或者 cnpm install  hexo  安装Hexo</span><br><span class="line">hexo init &lt;foldername&gt;    新建一个Hexo项目</span><br><span class="line">cd foldername             </span><br><span class="line">cnpm install              安装依赖</span><br></pre></td></tr></table></figure><h4 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt; 新建一个帖子&#x2F;页面&#x2F;草稿   分别对应layout中post&#x2F;page&#x2F;draft  title是名字  对于草稿写完后还需要 hexo publish [layout] &lt;title&gt;</span><br><span class="line">&#x2F;&#x2F;创建post时可以根据scaffolds中的模板进行创建 命令为 hexo new &lt;模板名字&gt; &lt;post名字&gt; 例如scaffolds中有一个a.md  以它为模板的命令为 hexo new a “hi”</span><br></pre></td></tr></table></figure><h4 id="部署在github上"><a href="#部署在github上" class="headerlink" title="部署在github上"></a>部署在github上</h4><p>首先在github上创建huajiaohuixiang.github.io的Repo<br>然后在本地hexo下  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;huajiaohuixiang&#x2F;huajiaohuixiang.github.io.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git push origin -u origin main  第一次需要-u origin commit</span><br></pre></td></tr></table></figure><p>然后安装hexo-deployer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br><span class="line">修改 _config.yml  将deploy修改成下面（huajiaohuixiang应该改成你的repo名字）</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;huajiaohuixiang&#x2F;huajiaohuixiang.github.io</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>打开<a href="https://huajioahuixiang.github.io即可/">https://huajioahuixiang.github.io即可</a><br>本人第一次hexo deploy的时候报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (Y:\个人博客\hexo\node_modules\_hexo-util@2.4.0@hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (Y:\个人博客\hexo\node_modules\_cross-spawn@7.0.3@cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在deploy一次就好了</p><p>可能有用的文章：<br><a href="https://1187100546.github.io/2019/11/24/spawn-failed/">https://1187100546.github.io/2019/11/24/spawn-failed/</a><br><a href="https://perry96.com/archives/882898e3.html">https://perry96.com/archives/882898e3.html</a>  这个是回退本地git版本  回退了就好了，很奇怪</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-@HotSpotIntrinsicCandidate</title>
      <link href="2021/02/19/@HotSpotIntrinsicCandidate/"/>
      <url>2021/02/19/@HotSpotIntrinsicCandidate/</url>
      
        <content type="html"><![CDATA[<h3 id="HotSpotIntrinsicCandidate"><a href="#HotSpotIntrinsicCandidate" class="headerlink" title="@HotSpotIntrinsicCandidate"></a>@HotSpotIntrinsicCandidate</h3><p>看源码的时候看到了很多这种注释 ，</p><h4 id="JDK的Object类源码中，被-HotSpotIntrinsicCandidate标注的方法，在HotSpot中都有一套高效的实现，该高效实现基于CPU指令，运行时，HotSpot维护的高效实现会替代JDK的源码实现，从而获得更高的效率。"><a href="#JDK的Object类源码中，被-HotSpotIntrinsicCandidate标注的方法，在HotSpot中都有一套高效的实现，该高效实现基于CPU指令，运行时，HotSpot维护的高效实现会替代JDK的源码实现，从而获得更高的效率。" class="headerlink" title="JDK的Object类源码中，被@HotSpotIntrinsicCandidate标注的方法，在HotSpot中都有一套高效的实现，该高效实现基于CPU指令，运行时，HotSpot维护的高效实现会替代JDK的源码实现，从而获得更高的效率。"></a>JDK的Object类源码中，被@HotSpotIntrinsicCandidate标注的方法，在HotSpot中都有一套高效的实现，该高效实现基于CPU指令，运行时，HotSpot维护的高效实现会替代JDK的源码实现，从而获得更高的效率。</h4><p>参考<a href="https://blog.csdn.net/javaer_lee/article/details/87161952">https://blog.csdn.net/javaer_lee/article/details/87161952</a></p><p>下面的源码对其的解释</p><p>The {@code @HotSpotIntrinsicCandidate} annotation is specific to the  HotSpot Virtual Machine. It indicates that an annotated method  may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method  is intrinsified if the HotSpot VM replaces the annotated method with hand-written  assembly and/or hand-written compiler IR – a compiler intrinsic – to improve  performance. The {@code @HotSpotIntrinsicCandidate} annotation is internal to the  Java libraries and is therefore not supposed to have any relevance for application code. Maintainers of the Java libraries must consider the following when  modifying methods annotated with {@code @HotSpotIntrinsicCandidate}. </p><ul><li></li><li><p>When modifying a method annotated with {@code @HotSpotIntrinsicCandidate},  the corresponding intrinsic code in the HotSpot VM implementation must be  updated to match the semantics of the annotated method.</p></li><li></li><li><p>For some annotated methods, the corresponding intrinsic may omit some low-level * checks that would be performed as a matter of course if the intrinsic is implemented * using Java bytecodes. This is because individual Java bytecodes implicitly check * for exceptions like {@code NullPointerException} and {@code ArrayStoreException}. * If such a method is replaced by an intrinsic coded in assembly language, any * checks performed as a matter of normal bytecode operation must be performed * before entry into the assembly code. These checks must be performed, as * appropriate, on all arguments to the intrinsic, and on other values (if any) obtained * by the intrinsic through those arguments. The checks may be deduced by inspecting * the non-intrinsic Java code for the method, and determining exactly which exceptions * may be thrown by the code, including undeclared implicit {@code RuntimeException}s. * Therefore, depending on the data accesses performed by the intrinsic, * the checks may include: </p><ul><li></li><li><p>null checks on references</p></li><li></li><li><p>range checks on primitive values used as array indexes</p></li><li></li><li><p>other validity checks on primitive values (e.g., for divide-by-zero conditions)</p></li><li></li><li><p>store checks on reference values stored into arrays</p></li><li></li><li><p>array length checks on arrays indexed from within the intrinsic</p></li><li></li><li><p>reference casts (when formal parameters are {@code Object} or some other weak type)</p></li><li></li></ul></li><li><p>Note that the receiver value ({@code this}) is passed as a extra argument * to all non-static methods. If a non-static method is an intrinsic, the receiver * value does not need a null check, but (as stated above) any values loaded by the * intrinsic from object fields must also be checked. As a matter of clarity, it is * better to make intrinisics be static methods, to make the dependency on {@code this} * clear. Also, it is better to explicitly load all required values from object * fields before entering the intrinsic code, and pass those values as explicit arguments. * First, this may be necessary for null checks (or other checks). Second, if the * intrinsic reloads the values from fields and operates on those without checks, * race conditions may be able to introduce unchecked invalid values into the intrinsic. * If the intrinsic needs to store a value back to an object field, that value should be * returned explicitly from the intrinsic; if there are multiple return values, coders * should consider buffering them in an array. Removing field access from intrinsics * not only clarifies the interface with between the JVM and JDK; it also helps decouple * the HotSpot and JDK implementations, since if JDK code before and after the intrinsic * manages all field accesses, then intrinsics can be coded to be agnostic of object * layouts.</p></li><li><p>* * Maintainers of the HotSpot VM must consider the following when modifying intrinsics. * *</p></li><li><ul><li></li><li><p>When adding a new intrinsic, make sure that the corresponding method * in the Java libraries is annotated with {@code @HotSpotIntrinsicCandidate} * and that all possible call sequences that result in calling the intrinsic contain * the checks omitted by the intrinsic (if any).</p></li><li></li><li><p>When modifying an existing intrinsic, the Java libraries must be updated * to match the semantics of the intrinsic and to execute all checks omitted * by the intrinsic (if any).</p></li><li></li></ul></li><li><p>Persons not directly involved with maintaining the Java libraries or the * HotSpot VM can safely ignore the fact that a method is annotated with * {@code @HotSpotIntrinsicCandidate}. * * The HotSpot VM defines (internally) a list of intrinsics. Not all intrinsic * are available on all platforms supported by the HotSpot VM. Furthermore, * the availability of an intrinsic on a given platform depends on the * configuration of the HotSpot VM (e.g., the set of VM flags enabled). * Therefore, annotating a method with {@code @HotSpotIntrinsicCandidate} does * not guarantee that the marked method is intrinsified by the HotSpot VM. * * If the {@code CheckIntrinsics} VM flag is enabled, the HotSpot VM checks * (when loading a class) that (1) all methods of that class that are also on * the VM’s list of intrinsics are annotated with {@code @HotSpotIntrinsicCandidate} * and that (2) for all methods of that class annotated with * {@code @HotSpotIntrinsicCandidate} there is an intrinsic in the list.</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Object</title>
      <link href="2021/02/19/Object/"/>
      <url>2021/02/19/Object/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class &#123;@code Object&#125; is the root of the class hierarchy. Every class has &#123;@code Object&#125; as a superclass. All objects, including arrays, implement the methods of this class.</span><br><span class="line">类Object是类层次结构的根。 每个类都把Object作为父类。 所有对象，包括数组，实现该类的方法。</span><br></pre></td></tr></table></figure><p>源码介绍如上。</p><h4 id="1-hashcode"><a href="#1-hashcode" class="headerlink" title="1.hashcode()"></a>1.hashcode()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>native修饰的方法，不由java实现，hashcode()方法就是将该对象再内存中的位置转换为整数然后返回，所有的对象由JVM管理。</p><h4 id="2-equals"><a href="#2-equals" class="headerlink" title="2.equals()"></a>2.equals()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==即判断两者的内存地址是否相同。</p><p>对于String来说，其重写了equals()函数，先判断内存地址然后再判断内容。</p><p>需要注意的是必须保证如果两者的equals()为true，那么hashcode()相同。即重写的话也要先判断内存地址是否相同，然后对于不同的情况再判断其他的。</p><p><strong>建议但不强制对于不相等的对象的hashCode一定要不同。</strong></p><h4 id="3-clone-方法"><a href="#3-clone-方法" class="headerlink" title="3.clone()方法"></a>3.clone()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* The method &#123;@code clone&#125; for class &#123;@code Object&#125; performs a</span></span><br><span class="line"><span class="comment"> * specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment"> * not implement the interface &#123;@code Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment"> * &#123;@code CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class="line"><span class="comment"> * are considered to implement the interface &#123;@code Cloneable&#125; and that</span></span><br><span class="line"><span class="comment"> * the return type of the &#123;@code clone&#125; method of an array type &#123;@code T[]&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;@code T[]&#125; where T is any reference or primitive type.</span></span><br><span class="line"><span class="comment"> * Otherwise, this method creates a new instance of the class of this</span></span><br><span class="line"><span class="comment"> * object and initializes all its fields with exactly the contents of</span></span><br><span class="line"><span class="comment"> * the corresponding fields of this object, as if by assignment; the</span></span><br><span class="line"><span class="comment"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment"> * performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>只包含了部分注释，这一部分注释解释了该函数的内容：</p><p>如果该类没有实现Cloneable接口，会抛出CloneNotSupportedException异常。</p><p>如果实现了Cloneable接口，那么该方法将会创建该类的新实例，并且初始化所有字段，字段的内容本身不是克隆的。 从而，这种方法执行此对象的“浅拷贝”，而不是“深拷贝”操作</p><h4 id="4-toString"><a href="#4-toString" class="headerlink" title="4.toString()"></a>4.toString()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//It is recommended that all subclasses override this method.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回类名+@+哈希值（内存地址转换而成）</p><h4 id="5-wait-notify-notifyAll"><a href="#5-wait-notify-notifyAll" class="headerlink" title="5.wait(), notify(), notifyAll()"></a>5.wait(), notify(), notifyAll()</h4><p>java的线程同步函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeoutMillis value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeoutMillis++;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-finalize-函数"><a href="#6-finalize-函数" class="headerlink" title="6.finalize()函数"></a>6.finalize()函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated(since&#x3D;&quot;9&quot;)</span><br><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>finalize()方法就是再JVM确定已经没有任何线程可以访问该对象，那么将会清空该内存区域，如果其他类又使用了该类将会报异常。抛出的是Throwable，说明除了常规的异常Exceprion外，还有可能是JVM错误。当一个对象在回收前想要执行一些操作，就要覆写Object类中的finalize( )方法。</p><p>@Deprecated(since=”9”)表示自从JDK9已废除该方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-String</title>
      <link href="2021/02/19/String/"/>
      <url>2021/02/19/String/</url>
      
        <content type="html"><![CDATA[<p>关于字符串  推荐阅读源码，或者<a href="https://blog.csdn.net/zhxdick/article/details/80803507">https://blog.csdn.net/zhxdick/article/details/80803507</a></p><p>以下是几个String的问题，总结一下。</p><h4 id="String-被final修饰-不能被继承"><a href="#String-被final修饰-不能被继承" class="headerlink" title="String 被final修饰  不能被继承"></a>String 被final修饰  不能被继承</h4><p>final的作用：</p><ol><li><p>​    修饰变量    表示变量只能一次赋值以后值不能被修改</p><p>​    如果是修饰了一个基本类型数据，就表示一个常量</p><p>​    如果是引用类型数据，则引用初始化后将永远指向一个内存地址（就相当于一个不能变的指针）</p><p>​    但是该引用对象中的内容是可以变的</p></li><li><p>​    修饰方法    该方法不能被重写，但可以继承</p></li><li><p>​    修饰类   该类不能被继承</p></li></ol><p>final修饰变量的<strong>本质</strong>: final修饰的变量会指向一块固定的内存, 这块内存中的值不能改变.</p><p>参考<a href="https://blog.csdn.net/qq_24309787/article/details/100942044">https://blog.csdn.net/qq_24309787/article/details/100942044</a></p><h4 id="那为何String要被修饰成final？"><a href="#那为何String要被修饰成final？" class="headerlink" title="那为何String要被修饰成final？"></a>那为何String要被修饰成final？</h4><p> 为了实现字符串常量池：字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量池中的同一个对象。这样一方面能够节约内存，另一方面也提升了性能。</p><p>但是仅有一个final不能保证字符串常量，原因在上面final作用第一条已说明。我们看String源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">//String类被final修饰了，表明其不可被继承。</span></span><br><span class="line">    <span class="comment">//实现了 Serializable接口---&gt;使其可以序列化，方便数据的传输</span></span><br><span class="line">    <span class="comment">//实现了Comparable接口，可以调用Collections.sort() 和 Arrays.sort() 方法排序，并且String类实现 compareTo() 方法。</span></span><br><span class="line">    <span class="comment">//实现了CharSequence接口，该接口能表示char值的一个可读序列。几个String兄弟类都实现了此接口。</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的final修饰的byte数组用来存储String内容，然后再加上private修饰，本身也没有提供修改自己value数组的方法，所以value数组不可变，即字符串不可变，生成了字符串常量池。</p><p>还有因为其不可变所以String是线程安全的，同一个字符串实例可以被多个线程共享。</p><p> 因为字符串是不可变的，所以在它创建的时候<strong>HashCode</strong>就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p><p>​        参考<a href="https://blog.csdn.net/zhxdick/article/details/80803507">https://blog.csdn.net/zhxdick/article/details/80803507</a></p><p>​                <a href="https://www.jianshu.com/p/9c7f5daac283">https://www.jianshu.com/p/9c7f5daac283</a></p><h4 id="JDK8-和JDK9-String的变化"><a href="#JDK8-和JDK9-String的变化" class="headerlink" title="JDK8 和JDK9 String的变化"></a>JDK8 和JDK9 String的变化</h4><p>​    再JDK8中 String中是用char数组来存储  char是由UTF16编码咱用两个字节，但是很多都只用了一个字节（ASICII），所有再9中对其进行了优化，将char[]  更改为了 byte [] 以及一个coder来存储。</p><p>​    coder一般只有两个值：分别用来表示8位表示还剩16位表示 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static final byte LATIN1 &#x3D; 0; </span><br><span class="line">static final byte UTF16  &#x3D; 1;</span><br></pre></td></tr></table></figure><h4 id="关于-和equal"><a href="#关于-和equal" class="headerlink" title="关于== 和equal()"></a>关于== 和equal()</h4><p>“==”判断的是两个对象的内存地址是否一样，适用于原始数据类型和枚举类型（它们的变量存储的是值本身，而引用类型变量存储的是引用）；equals是Object类的方法，Object对它的实现是比较内存地址，我们可以重写这个方法来自定义“相等”这个概念。比如类库中的String、Date等类就对这个方法进行了重写。<br>综上，对于枚举类型和原始数据类型的相等性比较，应该使用”==”；对于引用类型的相等性比较，应该使用equals方法。</p><p>下面是String的equal函数,equal()函数的object的一个函数，String对其进行了重写，首先它判断了两者内存地址是否一样，然后将anObject转换为String比较内容。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String aString = (String)anObject;</span><br><span class="line">        <span class="keyword">if</span> (coder() == aString.coder()) &#123;</span><br><span class="line">            <span class="keyword">return</span> isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">                              : StringUTF16.equals(value, aString.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-@Native</title>
      <link href="2021/02/19/native/"/>
      <url>2021/02/19/native/</url>
      
        <content type="html"><![CDATA[<p>看Object的源码的时候发现了从未见过的修饰符native，雨伞学习一下。</p><p>就是这几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博客<a href="https://www.cnblogs.com/KingIceMou/p/7239668.html">https://www.cnblogs.com/KingIceMou/p/7239668.html</a></p><p>被native修饰的方法就是不是由java实现的，而是由C或者C++实现，并且编译成了dll，然后由java调用，调用过程如下：<br><img src="https://images2015.cnblogs.com/blog/690102/201607/690102-20160725102547356-2054241629.png"></p><p>实现步骤</p><p>　　１、在Java中声明native()方法，然后编译；<br>　　２、用javah产生一个.h文件；<br>　　３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；<br>　　４、将第三步的.cpp文件编译成动态链接库文件；<br>　　５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悲惨世界</title>
      <link href="2020/12/04/%E6%82%B2%E6%83%A8%E4%B8%96%E7%95%8C/"/>
      <url>2020/12/04/%E6%82%B2%E6%83%A8%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>人有肉体，这对人来说，既是负担优势诱惑。人拖着肉体，又屈从于肉体。</p><p>有罪的人并不是犯罪的人，而是制造黑暗的人。</p><p>最好看的祭坛，是不幸者因得到了安慰而感谢上帝的一颗心灵</p><p>我在这世上不是守护自己的生命，而是守护灵魂。</p><p>p34-44</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 学习</title>
      <link href="2020/11/20/SpringBoot/"/>
      <url>2020/11/20/SpringBoot/</url>
      
        <content type="html"><![CDATA[<ul><li><p>依赖：spring-boot-plugin  可以将应用打包成一个jar包</p></li><li><p>@SpringBootApplication 注解可以用来标注主程序</p><p>其实是一个组合注解 @SpringBootConfiguration、@EnableAutoConfiguration等等</p></li><li><p>@Reponse Body 返回主体  @Controller  控制器</p><p>​    这俩合成一个@RestController</p></li><li><p>4.跨域的话+@CrossOrigin</p></li><li><p>5.YAML新的配置文件类型。k： v格式   冒号后面要有空格</p></li><li><p>6.@ConfigurationProperties(prefix=” “)来标识一个配置类，松散绑定</p><p>   @Value()   也可以只不过是标识一个变量，不支持松散绑定</p></li></ul><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来，也可以避免循环依赖的问题。</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux/Windows系统命令</title>
      <link href="2020/11/16/Linux%20Window%E5%91%BD%E4%BB%A4/"/>
      <url>2020/11/16/Linux%20Window%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h6 id="1-Putty-传送文件到服务器："><a href="#1-Putty-传送文件到服务器：" class="headerlink" title="1.Putty 传送文件到服务器："></a>1.Putty 传送文件到服务器：</h6><p>​    打开putty目录：命令行运行 psftp<br>​    put -r  foldername  上传文件夹</p><h6 id="2-Linux获取应用程序位置"><a href="#2-Linux获取应用程序位置" class="headerlink" title="2.Linux获取应用程序位置"></a>2.Linux获取应用程序位置</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S softwarename 显示包含此软件包的所有位置，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L softwarename 显示安装路径。</span><br></pre></td></tr></table></figure><h6 id="3-开启关闭HypeV"><a href="#3-开启关闭HypeV" class="headerlink" title="3.开启关闭HypeV"></a>3.开启关闭HypeV</h6><p> 管理员打开命令行             </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;set hypervisorlaunchtype off </span><br><span class="line"></span><br><span class="line">   bcdedit &#x2F;set hypervisorlaunchtype Auto</span><br></pre></td></tr></table></figure><h6 id="4-Linux-命令"><a href="#4-Linux-命令" class="headerlink" title="4.Linux 命令"></a>4.Linux 命令</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntlp  查看端口使用情况</span><br><span class="line"></span><br><span class="line">ps ux 查看nohup进程</span><br><span class="line"></span><br><span class="line">jobs  未退出过终端 查看nohup进程</span><br><span class="line"></span><br><span class="line">kill -9 id</span><br></pre></td></tr></table></figure><h4 id="5-查找当前文件夹下所有以-go的文件数目"><a href="#5-查找当前文件夹下所有以-go的文件数目" class="headerlink" title="5.查找当前文件夹下所有以.go的文件数目"></a>5.查找当前文件夹下所有以.go的文件数目</h4><p>find ./ -name “*.go” | wc -l</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
